[Music] So far, AI tools have been created with one purpose, to replace the experts. But today, for the first time, we are creating an AI SAS that is built for designers, an AI tool that does not work without them. And by the end of this video, you will have a finished SAS product ready to launch and ready to accept customers. S2C is an AI powered SAS application that allows designers to sketch wireframes and then using the power of AI convert these wireframes to full-blown designs. Let's take a quick look at the demo. Our application will feature a minimal yet stunning UI design. Users can use Google authentication to sign into our application. The user is then redirected into the project dashboard. We can create projects by clicking on the new project button. But notice how blazing fast our application reacts. This is because we are using convex as our database. Convex gives us realtime functionality that gives us the ability to use optimistic UI in our application. When you click on a project, you are redirected to the project canvas. This might look familiar. The design closely resembles something like Figma and Excaliraw. You can click on tools from the toolbar. You have a pen tool, rectangle, circle, and you can also drag across the canvas. You can zoom into the canvas as well. You can erase elements, draw arrows, lines, and also write text. Selecting a text element will show its sidebar options on the right hand side. You can tweak these. You can change the font family and pretty much all the settings for this text. You can also select other shapes, move them around, and even scale them up and down. Now, let's take a look at the style guide. The reason why our application stands out is our app is powered with a mood board. The mood board is where the designer can drop inspiration images and it'll show up just like this with cards side by side. You can also delete these images in real time and also upload newer images. Now for one of the best features of this application, the users can generate a style guide with colors and typography by clicking on the generate with AI button. Once that's completed, the AI will create a custom color palette from the colors that it finds from these mood boards, and it will create these little color swatches that the user can use inside the design. This creates a global standardized theme across the entire project. It'll also give you the typography with the right font that matches your design. Now, let's go back to our canvas. The user can create designs through wireframes. They can do this by selecting the frame, creating the frame, and then sketching out their wireframe within it. I just went ahead and sketched something real quick. It's not the best, but it does the job. Once you have completed sketching out your wireframe, you can click on the generate design button. But before that, here's another awesome feature. The user can upload inspiration designs for every single frame. I'm going to drag and drop a design in here. And there we go. It's now uploaded to the server. The AI generation feature will take whatever we have sketched inside this frame along with the inspiration designs and will create designs that look very similar. But before you can generate a design, you're going to need some credits. That's when the user can upgrade to our paid plan in order to purchase 10 credits. Our checkout page looks very modern and minimal and is powered by Oler. Once your payment is successful, you're redirected back to your application. Our canvas also stores where the user stops scrolling. This data is then saved in the database. And if you refresh this, you will load in the exact same location. Now, when the user clicks on generate design, this is exactly what you can expect to see. Check this out, guys. This looks like magic. Everything you see on the screen is being generated by AI and is being streamed in real time. Now, the reason why we see four screens being generated and streamed at the same time is because I am in workflow mode, which gives you the ability to have multiple pages streamed at the same time. But you can also generate a single design at a time. This product not only solves a real world problem, but I can almost guarantee you that if you post something like this on social media, you are bound to go viral. I mean, no one has created a product just like this, right? So, you're going to be the only person to take over this market. Once the designs are generated, you can chat with a specific screen by clicking on the design chat. This shows a minimal looking design chat box, and you can go ahead and say whatever you like about this design, and the AI is going to go ahead and redesign this as per your request. You can also zoom in and zoom out through the buttons at the bottom right corner of the screen. So, I hope you're excited. Let's jump straight right into the video. What's up, Prodigies? How's it going? Before we move forward, I just wanted to quickly introduce Mochi, our first premium SAS course coming soon. Now, some of you have already heard about Mochi and uh you're probably already excited about this announcement. And I I mean in this video I just want to help those who haven't heard about it and help them know exactly what Mochi is, why it's going to be the best investment they will make into their into their SAS journey and why it has taken us more than 9 months to build this product and why I believe that Mochi is going to crush the market and it's going to be the best SAS to run in 2025 or 2026 2027 anytime into the future because this is evergreen. this business model that I have created here is going to last forever. Okay? And so in this short video, you're going to get u a quick glimpse into the features into just a little bit of them. All right? Not all of it, right? We have some secrets too. And uh I want to make sure that you are equally as hyped as I am. That's pretty much it. But before that, I just want to say thank you for all the support that Mochi has received. I am lost for words. We have thousands and thousands of people on the Mochi weight list. I did not expect Mochi to grow so fast before I've even started it before I've even you know showed you guys every single feature. So, thank you for trusting in me. Thank you for u you know for believing in this product as much as I do because I am so confident that I am going to you know keep my word and I'm going to make sure that you get the best product ever. Okay, so let's just quickly take a look at this. So, Mochi is an all-in-one white labeled CRM SAS application. If that sounds like uh you know inception, I promise you it's not. First of all, what is the business model behind this white labeled CRM SAS application? It is a B2B business model. You being the first B. Okay, your direct customers being agency owners, which is the second B. And third, their business clients. So, their clients, so the second B, their clients are going to be the third B. And so in a simpler term, this is essentially what it is. So you get access to Mochi. You're going to run it as a SAS, right? So you're going to run this product as a SAS, giving your direct customers who are agency owners access to a studio account inside Mochi for whatever amount it is. You can charge billion dollars if you like. Doesn't matter. Okay? But you get to charge them XYZ amount. And I'm going to get to that towards the end as well, which is how much you can charge. but you're going to charge them a certain amount and they get access to this studio account. Now, inside this studio account, they can manage all of their clients. Okay? And the way they manage their clients is by creating a little client account inside these studio accounts. So, you have one studio account and they will create maybe five clients. So, they'll have five client accounts and they'll give their clients access to their portals. That's pretty much it. Okay? But now I'm going to show you why this software is so powerful that your customers will physically not leave you. So each of these client accounts are bundled in with a ton of features that otherwise would cost these people thousands of dollars to get individually. Okay? And I've mentioned just a few of them on the screen. You have website building, you have payments, contracts, you have a product creation, you have a portal link, you like you have login system, e-commerce pages. There's pretty much every single thing these small business owners would need. And it's bundled into a client account. And that way your direct customer, who is the agency owner, which we are now going to call studio account owners, will essentially own. So that means you as the SAS owner, you are going to have a studio account owner who is directly making money by just having a subscription with you. How awesome is that? So what you're trying to create here is a SAS application that directly rewards someone. They can they can see they can tangibly see their results by owning your SAS, right? So they essentially white label your SAS. They open a studio account. They sell to their client account to their clients through those client accounts and every client to them is XYZ amount. They can charge thousands of dollars per month. And so let me ask you this question, right? If your customers by simply just using your platform were making thousands of dollars per month, why would they ever turn? Ask that question. Why would they ever turn? They would never turn. I'll give you another example. Imagine you have a funnel through your window. It's a pipe through your window that keeps pushing in cash every second of the day. Every day there's there's bundles of money falling through this tunnel. Would you ever block that tunnel? No. Why? Because it's a no-brainer. There's money coming through that tunnel. You're going to always want to keep that open. And so you are going to build a sticky solution where your customers will pretty much never turn because they are they're making money just by having a subscription with you because their clients are going to be paying them thousands of dollars and it's going to be a no-brainer to the studio to these studio account owners because if they were to build a SAS from scratch, they would be spending millions a month, right? So they get unlimited infrastructure for just a onetime simple fee. How awesome is this? So, that is the problem that Mochi tries to solve at the heart of it, at the core of it, but there's more inside all of this, right? And so, obviously, I'm not going to show you everything. There's so much more, but I just wanted to say that's the overall, I guess, a 10,000 foot overview of what Mochi does and what Mochi is trying to accomplish. Now, this product has been 9 months in the making. 9 months. We have been working day in and out because we believe so much in this product, right? And thank you so much to everyone who has joined the weight list. I am lost for words because there is thousands and thousands of people on the Mochi weight list already. And so if you haven't joined the Mochi weight list already, look in the description. You're going to find our website. Just go to our website and you're going to find Mochi somewhere. It is obviously a weight list right now. you can join that weight list and when when this product is launched, you're going to get a surprise. Okay, that is my promise to you guys. I promise to deliver as much as I physically can to help you succeed. I share updates on the product. I share pictures, screenshots, I get your feedback. I I run polls. I see what you guys like and I add it inside the product as well. And uh that's pretty much how we're how we're been working with Mochi so far. Now, like I said, this is one of the biggest products we have ever worked on. It has everything you're going to need. Email marketing, email campaigns, u invoices. Like remember I told you, it has pretty much every feature you will need, right? It's bu it's also built in such a way that you can expand on Mochi, build as many features as you like and the three pillars of having a successful SAS. First, you can sell the SAS uniquely in a vacuum so that your competitors can never compete with you. That's point number one, and I'm going to show you how. Second, it's a high ticket SAS. That means you can charge your studio account owners, who are your direct customers, thousands of dollars per month if you like, because they are going to be having unlimited clients. And so, they can be making 100K per month and paying you whatever amount is probably not going to be a not going to be a big deal uh to them. And so, you just need to figure out the math. How many clients do they need to run in order for this to be a no-brainer offer to them? And so this is what I've been sp this is what I've been speaking about all this while which is high ticket SAS. I've helped so many students so many clients inside Prodigy's University accomplish the same thing, right? One of my students was was able to make $30,000 through his high ticket SAS. Same exact principle. You sell uniquely in a vacuum. That means you wrap your own offer around this. Whether it is focusing on a s super niche, focusing on a special niche like fitness coaches only. You see what I'm saying? And because you're going to put that tagline on it that you are the only person offering this solution, you're going to sell uniquely regardless whether you sell uniquely or not. You already have a product that is so unique in itself that it's the product in itself is going to sell. There are a few more questions that I've also received which is when is this going to come out? I'm ready to buy. Please take my money. All this kind of stuff. Um we don't know. We're trying our best to get this out by the end of this year, right? It's already been 9 months in the making. we might as well spend as much time as we need to make it a a perfect product. So, if you'd like to know more and you'd like to be a, you know, with the process of me building this application, you'd like to give feedback, you'd like to tweak the product, then I highly recommend you join the weight list because I'm going to be sharing polls not only on my not only on the Telegram channel, but also on my Twitter. So, you guys can vote there as well for features that you like. And I highly highly recommend that you join the wait list because you're going to get an an awesome awesome gift. Okay, that's pretty much it for my end and let's continue with the video. So, the first thing you're going to want to do is open up cursor. Now, you can use Visual Studio Code if you like. I just love using Cursor. So, I'm going to be using this IDE for this project. Then, create a folder pretty much wherever you like. I would prefer you put it in somewhere where you're going to remember. Okay. So, I'm going to put it right here. And please name it the exact same way that I'm naming it as well. So, I'm going to call it web prodigies- s2c. Okay. And everything should be lowercase. And then once that's done, drag and drop it into your IDE. And that should open up your project. And you can also verify by opening up the terminal. Next, you're going to go ahead and type npx create- next- app. You're going to put at like this. And now, we're going to paste a version number. So, go ahead and say 15.4. 4.6. Hit spacebar and then you want to put the period sign. And this is essentially going to install Nex.js in this root directory. Once you hit enter, it's going to give you a prompt here. Hit yes for TypeScript. Hit yes for ESLint. Yes for Tailwind CSS. For source directory as well, we're going to hit yes. For app router, yes. Turbopac, yes. Import alias, hit no. And there we go. And now you should see this message if everything went well. And then the next thing you're going to do is you're going to create a file called enenv. And inside this file you're going to paste the following values. Now you will find this.env.example file from the YouTube kit in the description down below. That's completely free. And that essentially gets you all the assets that you need to build this project. Um if you were just if you just wanted to just watch the video and not buy the codebase. Okay. Now, I highly highly recommend you get the codebase because you can build side by side. You can refer to the codebase as you're coding along. That way, you don't face any bugs and if you're looking to start it as a SAS, you have that ready to go as well cuz you have a free license. Okay. So, go ahead and paste this and then let's move on to the next section. Then go ahead and open up a tab in the browser and just look up SHAT CNUI and then click on installation down here. Click on X.js and they're going to tell you exactly what you need to do. So I'm going to copy this command and inside my terminal I'm going to paste this command and hit enter. And that's going to essentially initialize SHA CN. So let's go ahead and hit yes for this. And that's going to ask you what colors you want. Just select neutral for now. All right, there we go. You should see the success message as well. Then the next thing you want to do is copy the second command here. And then we're going to paste this in the terminal and we're going to remove the word button and hit enter. And that's going to give us a way to hack around it to just install all components. Now, I I mean, you don't have to do this in production, but I prefer to have all the components up front because if you're trying to use AI, you would rather have the current version of all components installed, right? Cuz it's going to always need it. And if if you're using something like Cursor and Cursor cannot find an accordion, for example, it's going to create its own accordion. So, you see the the problem here, right? So, I would highly recommend you install all components once and for all. So, go ahead and hit A and then hit enter. And let's just give this a second. Next, go ahead and shrink all of your folders. And inside the source directory, I'm going to create Oops, that's that's not supposed to happen. Let's go ahead and create a new folder here. And this folder is called theme. And inside this, I'm going to create a provider.tsx. Now, this is essentially the theme provider, which you will also find in inside chats if you just go to their website. But I've already done this uh for you, right? So all you'd have to do is you can pause the screen and type it right now or I'll also show you where you can copy paste it from Shatsen. Now the reason why I gave you this first is because Shhatzen really hides this which is super weird. But if you click on the menu here you're going to find themes. And if you click on this it's going to take you to the theme picker which is not what we need. But if you see documentation I mean you should see documentation right here. Click on that. Okay. And that's going to take you to the theming page. And then you want to scroll all the way to the bottom and you should find this next page right here. And if you click on that, it's going to take you to dark mode. So one way to find this is to say UI dark mode, whatever. And then it's going to take you to this page. Then go ahead and click on X.js. Just copy this component and paste it in here. Next, go ahead and shrink your folder again so it's easy to navigate. I'm going to click on app on the app folder and then I'm going to click on layout.tsx. And then in here, you can go ahead and change all the metadata if you'd like, but my main priority right now is to get the theme provider to wrap our children components. And so all I'm going to do right here above children is I'm going to say theme provider just like this. And I'm going to move this into this and import theme provider from above. Now, if you're wondering how I'm able to do all of this with just clicking tab, that's because I'm using cursor. Okay? So if you use cursor, it's going to give you all of these shortcuts. They're not sponsoring this video. I just want to show you different ways to code faster. Okay, so um once that's done, this also needs a couple props. So inside the theme provider, you want to make sure you have these. Okay, if you don't have this, it's going to essentially um set it always to light mode or system mode. Okay, so make sure it's forced to dark mode. Now, another thing I like to do when I'm setting up the application is to provide the toaster. And the reason is because most in most applications, you're going to need a toast, right? Maybe to show confirmation messages or error messages. And so it's always it just makes more sense to just render it out right now cuz we're already at it. Okay. So go ahead and render that out in here as well. So now I believe we have the base for our application. Let's go ahead and say npm rundev and let's hit enter. And then make sure you open another browser tab and you want to hit localhost 3000. Okay, it's not going to open up automatically. You have to call you have to make a call to the server to send you this file. Okay, so now that you've done uh that part, you should have Nex.js show up like this. If something happened and you don't see this or you see some errors, please pause the video, go back and follow through from start to finish. You should get the correct format. Okay, let's move on to the next section. Now, this video is sponsored by Savella. Now, Savella is an application hosting platform that allows you to deploy your web applications and your SAS products from anywhere. Now, some of the awesome features that they have is you can set up automatic deployments when you push code to your main branch. And this way, you don't have to manually deploy every time you make a change, right? They also have Docker file support, so you can create Docker containers for custom applications. And you can test your changes before you merge, which I think is huge. Now, one of my favorite features in SELLA is that you can create multiple environments of your application. So, typically if you were to do CI/CD from scratch, it's a pain because you have to set up a ton of things under the hood and CLA makes it a breeze. There's just one button. You just set up the different environments and you can create as many environments as you like and then you can promote your changes through the through each stage in this pipeline. And one more nice thing about this is you can essentially isolate the data and you can isolate the environment variables to every single independent environment, right? So your development environment can have development keys and it can also have its own database. So this way your development and production branches will will never get corrupt. They also have a ton of support to pretty much any framework of your choice. And since we're using Nex.js JS in this project to build this SAS application. I'm going to show you how to set up SELLA, deploy your app, and also implement all of the features that I just explained. The other nice thing to have when you're picking a a hosting provider is to make sure that they have some sort of scaling in place when you grow, right? So if you have a ton of users all of a sudden and you you can't handle that because the deployment platform that you chose does not have not only vertical but also horizontal scaling then your your servers are going to crash. Now CLA gives you both which is awesome. So this is definitely one of the best uh hosting platforms that I have found so far. And uh the other thing that I think most of you guys would love is that they automatically set up Cloudflare DOS protection into your Cella dashboard itself. So your application is automatically protected with under attack mode. So anytime you go through a DOS attack, u Cella has already got you covered because they have connected this to Cloudflare services. Now if you have a development team, you probably want to give access to them right into your deployment uh into your SELLA dashboard. You can do that as well because they have access control and team management as well, right? Um another cool feature is I mean you can just see all of your runtime logs. This way you know exactly what's happening. And so if your app crashed or you saw an error, you can go into the logs and you can see what message was printed, right? So yeah, guys, they have a ton of awesome features and quite frankly speaking, this is one of the best providers that I have found that offer all of these features for very affordable price. Okay, so go ahead and use the link in the description. That way you can set up your free account and then we'll get started. Now, if you already have an app and you would like to know how to deploy, you can go ahead and skip to the ending part of this application and uh you can essentially learn how to deploy and how to set up these multiple environments and how to move your application from another provider if you have something into SELA. And with that being said, let's proceed with this video. Now, the next thing I'm going to work on is the authentication section. So, go ahead, open up the app and then you want to say O like this. And then inside this you want to create a sign-in folder which is a route and then apage.tsx for that as well. And then inside this off I'm going to create another folder called sign-up and inside that apage.tsx as well. Now I'm going to show you a really cool hack. And I think a lot of you already know about this but if you don't know Shadsian offers free blocks that you can just simply install into your application. So, it's going to install whatever you see here into your components folder and then you can use it the way you like. Now, the other cool part about chaten is they give other creators the ability to create their own blocks, right? And so, I found one communitybuilt, I think, block components, whatever you want to call it, called Taylor. So, shout out to this guy, whoever created this. Uh, great stuff. These are some great components that you can use for your application. And as far as I know, this is free right now. So, you can just grab these and obviously if you don't have this right now and it's not free for some reason, you can just install the blocks from here, right? So, you can go to login and you can install Shadzian's free blocks, but I'm going to use Tailorarch just to stand out a little bit more uh from, you know, the crowd. Everyone's going to be using the same thing, right? So, let's go ahead and first click on the signup block here. And then you're going to find a package manager. You want to change that to npm. And then go ahead and copy the terminal command. And you can paste that and hit enter. Now just a quick pointer. If you try to paste this and hit enter, it's going to give you something here. Essentially, it's throwing an error. So let's just quickly take a look at what this is, right? Just give me a second. So I believe the error is happening because we are we might be on a slightly different version of Shaden. And so what I would suggest which is also another cool part with blocks and using chats is that you can just directly copy the code and paste it right. So this gives us maximum flexibility with u you know with the way we can build using chats. So go back into your signup component. Let's make sure this is the signup component as well. And inside our signup component I'm just going to paste whatever I just copied. And that should paste as such. And you might have an error here. No problem. We're going to solve that in just a second. So, go ahead and remove this logo just like this. You can just remove this link as well. And that should solve that bug. And obviously, there's a whole bunch of colors on this page. We're going to go through it one by one. And we're going to remove things that we don't need. Okay. So, let's go to our web application. And now, let's go to dash sign-up and let's hit enter. Okay. Looks like something is wrong here. Just give me one second, guys. So the directory is actually o/signup, right? Okay, there we go. Take a look at that. Super easy. We did not have to build anything and we already have a design. So now let's go ahead and remove some stuff from here and let's create um a more I guess tailored experience for S2C. So the first thing is we're going to remove this and we're going to say S2C account and then this can remain as is no problem. So, the first thing I'm going to do is right here after this message, you're going to find a div. Just copy this. Just remove it from here. And maybe we can also take the HR. So, let's go back up top and let's take the HR as well. And now we're going to find all the input fields. Right. This is cool. We're just going to scroll down to the div that separates that. And we're going to paste this back here. Okay. And then we're going to take this HR element and we're going to place it above our sign in uh sign-in elements right here. Now, we also have to make a few more tweaks to this. So, let's tweak this design. Just a second. So, down here where we had this HR element, you see it looks like cursor is already telling me what to do. We're going to go in here and we're going to change this because I want it to say or, right? So, or continue with something like that. So, first thing I'm going to do here is I'm going to create a div. And this div is going to have the following class names. There we go. And inside this div, I'm going to bring the HR element in here. So, you see, just like that. And we're going to duplicate this once more. And inside this, we're going to put a span. And that should separate the elements for us. And go ahead and remove this margin here and this margin from the bottom section. And that now looks much more presentable. Awesome. Now go ahead and open up your folder structure. And I would like for you to take this up as a challenge. If you are a web developer who's just looking to code, I think this is a great opportunity for you to practice, right? Because this way you learn how to do these things without me. Okay? So go ahead and try to get a sign-in component of your choice, maybe from tailor or from shaten blocks. It doesn't really matter. I I used tailor. So, if you want to follow through with me, then you can use tailor as well. So, go ahead and install that component and then I'll see you on the other side. Okay, awesome. Welcome back. Hopefully, you got the right answer. If you didn't, no problem. All you have to do is go into Tail Arc. You have to select another component, just click on login, click on code, copy the code, and just paste it inside your sign-in page. That's pretty much it. Okay. And now we're going to have something that looks like this. And obviously I don't know who's using Microsoft login anymore, but we're going to need to remove all that stuff. Or actually, let's keep that in there so it looks nice, right? And if you want, you can add Microsoft login if you'd like. But um so far, I think we are I mean, we're very close. We just have to change this page as well. So let's go ahead and change this to S2C. And I think it's giving me some more tips and tricks. What do I need to do? Okay, so it's trying to get me to paste the signup. So before I do that without showing you what I did, I'm going to go back to the signup component and remember that HR stuff, right? So I'm going to copy that the horizontal rule and the button, the sign-in buttons as well. Let's go back. And now I'm going to replace what we have in here. So where you find this button, you want to go up top here, shrink this so it's easier to delete. And you want to delete the HR and the other one. Okay. And now I'm going to scroll down here. So I'm going to sc I'm just going to shrink this cuz it's easier this way as well. Then you want to hit enter and I'm going to paste the following and that should give you the same design as your signup component. Okay, if you did this, awesome. Great job. You are ready to proceed to the next stage. All right, so now that we're done setting up the designs for authentication pages, let's go ahead and wire up the database and the authentication itself into our application. So open up a different tab inside your browser and you want to look up convex.dev. Now, Convex is one of the best solutions you can use for a project just like this. Now, my favorite reason to use Convex is first, it is a reactive database. That means your data your your schemas and your database is always going to be in sync because once you create a schema property that will automatically update in the database and not just that, you can also get feedback on the front end through realtime updates. So, they show you an example here. If you create a new uh you know if you create some data in the data in the database you can listen to these changes and create an optimistic experience for your users on the front end as well and convex also supports Nex.js and a bunch of other frameworks. So if you have other applications switching to convex shouldn't be too complicated. And another nice thing is convex is open source. So for some of you who are afraid of vendor lock or you know you you don't want to spend too much money or some there's some sort of a a budget constraint you could just host Convex on your own and uh essentially you could deploy it the same way that we deployed uh the application at the end of this video. Convex also offers authentication wired in into the app. Okay. So you don't have to go and use a third party provider just for authentication. You could directly use uh Convex's odd services. And since our goal is to get our application as fast as possible in front of our users, um we need to make sure that we pick the right text stack. Okay, we don't want to get c caught up in deciding what type of database to use, what type of schema to use, what type of uh you know OM to use and all these kind of things. And so Convex just makes it simple and easy to understand. And it's all in one simple location, right? You don't have to download or install a bunch of other thirdparty packages. It's it's one single thing. It's Convex and they have everything you need to essentially create the SAS. And with that being said, Convex is also the sponsor of today's video. So, thank you so much to Convex for making this possible and helping out the Prodigy's community. And that way, this course can be free for them to watch. Go ahead and open up a different tab. And you want to look up Convex docs. Okay. And hit enter. Let me zoom in a little bit more. And then it's going to take you to this one. Click on this. Click on X.js. and it's going to give you the commands you need to run. Now, we already did this, so we don't need that, but we do need the npm install convex. So, let's go ahead and shrink our browser. And inside the terminal, I'm going to say npm install convex, but don't hit enter yet because I'm going to see if I can get the exact version number as well. So, I think this is the current latest version of Convex. Um, regardless because you're I mean, it wouldn't matter because you're on the same version that I am on, right? So, as long as you put 1.25.4, before you should be good to go. Okay, now let's scroll down here and it says put this command and then we're going to set it up later. Okay, so go ahead and hit enter and then copy the next command here. You want to paste it into your terminal and hit enter as well. And essentially what this is going to do is it's going to create uh the boilerplate code that we need for convex to run. So obviously here because we've already created an account, I'm going to say login or create an account. Okay. So, let's go ahead and click on that. Okay. So, it's asking me for the device name. So, I'm just going to put something in here. And then it's giving me some credentials. So, let's take a look at this. It says, okay, so it's giving me an O URL. So, I'm going to copy this to finish logging in. You would see the following code which expires. Okay. All right. So, I'm going to give this a shot. So, let's open it up right here. Okay. Okay. So, confirm this code is what you see. Awesome. So, I'm just going to say confirm. Okay. Your device is logged in and open the browser. I'm just going to say yes for now. Okay, it opened it up. Awesome. And now I need to log in. So, obviously you can't see this, but I'm logging in right here. So, okay. I think it already logged me in, guys. I think it already did. Let's see. So, what would you like to configure? So, I'm just going to choose an existing project. Okay, there we go. So, we're going to say yes for this and hit enter. And awesome. So, now it's going to create the Convex deployment key and the public convex URL inside your environment variables. So, just to make sure that you also installed Convex correctly, you should find a convex folder like this inside your root folder right right here. And then if you scroll down to your env, you should find those two variables. Now, because we already pasted it in here, we're good to go, right? We don't need to do anything here. But, um, if you did not paste it, then these would have autopop populated on its own. Okay. So, if it did not put it into your environment file, it's because it put it into the local file. Okay. So, because I have this here, I'm going to remove this and I'm going to paste it into my environment file. And please make sure you delete this. It doesn't matter guys. You can use the local environment, but I just prefer to have one environment file. Um it doesn't matter again like I said if you like to have two different type of um you know keys local keys and production keys, you can have another file called dot uh you can use the same local file that they provided. Now just to confirm that your convex server is running, remember when we ran that command, right? We did the npx convex dev. You should see this convex functions ready and you should have a check mark right here. Okay, if you don't see this, that means something is wrong. You can quit the terminal and try it once more. Next, go ahead and open up a different tab and you're going to say convex off just like this. And let's click on the first link. And I'm just going to expand this so you guys can see clearly. You're going to find the manual setup right here. So, click on this one first. And you want to copy this command. Now, I have not used this command before. I've only used this process, which is completely doing it from scratch. But, uh, let's just try to see if this helps us, right? So, I'm going to shrink this again. And let's open up the terminal. I'm going to open up a different terminal here. And I'm going to say npx convex at convex-dev/, but please don't hit enter yet. And I put the version number set to at 0.0. 0.88. So, this is the latest version that we're using right now. But regardless, if you use this, you shouldn't have any issues. Now, let's go ahead and hit enter and let's just see how this handles everything. So, first it's asking me to install this package. We're going to say yes and we're going to hit enter. Okay, so it's saying something was deprecated. Okay, this is something else. There are unstaged and uncommitted changes in the working directory. Please comment. Okay, that's fine. So, let's go ahead and um actually I think we should be fine. We don't need to stage really, but let me just see guys. Give me a second. Okay. So, I'm just going to commit all of my changes. I'm just going to say get add space period get commit. I'm just going to say init. And we're just going to leave it as such. Okay. So, now we just have all of our changes. And now let's go back to that console and continue. Anyways, I'm just going to hit yes. Now, once you hit yes and hit enter, it's going to ask you this question, which is to enter the local web server URL. And so, you can just put localhost 3000. So, http slash localhost 3000 like this. Okay? And you can also find this inside the documentation. So, if you take a look at it, it's going to show you right here, right? It's going to say just like this. But obviously, don't put this one. But, um, I mean, don't don't type this command. It's already doing it for you. That's why we use this one. But this is what you need to paste. So once that's done, I'm going to hit enter. And in just a few moments, it's going to essentially create a JWT private key and something else for you. I don't really know how it's using this, but it needs it for authentication, right? And then next, it's going to modify some files inside your account, inside, sorry, inside your folder, and it's going to just change some stuff here and there. And uh you're pretty much set, ready to go. Now, I just want to point one thing out. So, here we added localhost 3000 as the local web server, which is fine. This should work. But now, when you have something like Google Cloud, I'm sorry, Google authentication, which we're going to set up in just a second, it's going to need a callback URL. And so, typically, you would need a hosted URL because obviously Google O cannot just call your local host endpoint. And so I think the best thing to do here would be to first go into your environment variables inside your convex and you should see inside environment variables you should see these three variables right here. Okay. If you don't see this it means you haven't set up whatever we just did correctly. So please make sure you have these three set up and if you don't go back watch the section watch the uh manual setup and so that way you can set this up from here. Okay. So if you click on this O Google O right here, you see it's asking us somewhere down here that we need to set this O Google ID, right? So because we're going to need those type of endpoints, which is a temporary hosted endpoint endpoint, we're going to need um a tool called Enrock. Now, if you don't know what Enro is, you can watch my other videos. There's so many videos, I mean, where I've used Enro. It's essentially just a way for you to get an endpoint that you can call. And so if you're using something like a web hook service, it needs to reach an endpoint, right? Enro helps retra send that traffic to your local host even though it can't access local host online. That's what Enro does in very simple easy to digest words. Okay. So you can either copy this one for your Enro URL or which is a localhost not 8080 3000 or you could use this temporary URL. Now they give this to you, right? So you can essentially use this URL and I think if I'm not wrong I think at the moment this is a paid service. So you could just get it for $9 or $10. And I would highly highly recommend you do it this way, which is to get a permanent static domain because u if you don't do it this way, then every time you reconfigure enrock, it's going to give you a new URL and you're going to need to use that URL and update everything. So you have to go into convex, you have to update the site URL in here. Then you'll have to update that URL inside con uh inside inside Google uh inside your Google console. and you'll have to also update those on other services that we're going to use as well. We don't want that, right? So, I would highly recommend you use this. So, I'm going to click on static domain and I'm going to copy this URL right here. So, now go ahead, copy that. Like I said, open up your Convex dashboard. You want to click on environment variables and then you're going to click on the site URL right here and you're going to change it to the following. So, I'm going to remove this and I'm going to put this in front and I'm going to say https. Okay, I believe like I said this I think this is a free static URL. So, you should be I mean for for me it was a free static URL cuz all I had to do was say claim free URL. But if it's not, then you probably need to spend like5 or $10. And I'd highly recommend you do that. Okay, so go ahead and save this. And now you should have this new URL in here. Okay, if you don't have this, please pause, go back, watch the section again so you can add this into your convex environment file. Now, we go ahead and open up a different tab and you're going to look up Google Cloud like this. It's going to take you in here. Click on that and if you've already signed up, you can just click on console up top here and that's going to take you into your Google Cloud console. Okay, so it's console.cloud.google.com. Okay, you can use that so it's easier to navigate. And then we're going to go and create a new project. So click on new project here. And you want to change this to web prodigies S2C. Create that. And that's going to take a second to spin up. So let's just give that a moment. Okay, there we go. And now we're going to go ahead and click on select project. It's going to take you into that project. And then you're going to click on API services right here. And you're going to click on credentials. And I think this should essentially give you that first consent. All right, there we go. So click on the configure consent screen. That's going to take you back here. And then it's going to tell you, hey, you need to essentially set up your Google O first. So go ahead and click on get started. And now we're going to say Web Prodigies S2C. Please put the same names again so you don't have any errors. And then I'm just going to select the same email here. Click next. I'm going to say external or actually if you say internal, it's only available to users within the organization. So you will not need to submit app for verification. But if it's external until it goes live, you're going to need to make sure that you give access to each person. Okay? But I'm just going to select external for now and click next. And I'm going to put the same email. And then go ahead and click next again. and then click on I agree and obviously read their terms and service and then click on continue. Then click on create and this is going to configure this project for you and it's going to take you to a page that that looks like this. This is called the OOTH consent screen or I think it's oath review page or overview page and then you want to click on the create OOTH client. Okay. And that's going to take you in here which is now going to create the OOTH client ID. So first click on web application and then in here I'm just going to say web prodigies S2C again and then in here we have to add a couple URLs and uh let's go ahead and do that as well. Now, for the next set of set of environment variables, um, we're actually going to first, guys, go back to your convex. Copy this one, right? Just copy this. And you're going to go back into your into your Google Cloud. And sorry, these are not environment variables. These are essentially authorized origins. And you're going to paste this in here. Okay, I had to quickly just read through this to make sure I'm doing it correctly. And so, you can do that. Now, if you're using local host, obviously you'd put the local host address, right? And I mean, you might as well do it there. Nothing. There's no harm in doing it. You can say localhost and set it to 30,000. So, all of these are considered authorized URLs. And then the next one is it says the authorized callback URL. This is the next thing you need, right? So, first thing you want to do is go in here and you want to copy this. Actually, before you copy that, go to the convex off and copy this file. this link right here. You want to paste it inside authorized redirect URLs and then go back to Convex. Copy this URL. Go back to your to your Google Cloud and you're going to replace all the way up to site. Sorry guys, I am wrong. This is this is incorrect. Sorry guys, that's that's not the right URL. This is the right URL. So go back in here. You want to click on URL and deploy key. And then in here, you're going to click on this dropdown. And you're going to find this uh this action URL. That's what they that's what they said inside this documentation as well. So, copy the action URL. Go back to your go back to your Google Cloud. We're going to paste that first. We're going to put a backslash right there. And then we're going to copy slap API slot and we're going to say slash instead of GitHub obviously we're going to say Google right and if you click on Google I think they have that here as well. There we go. So API/callback/google. So let's paste that in here. Let's remove that extra trailing backslash. And now I'm also going to copy this. And I'm going to put this in here as well. Even though we don't need to, we might as well. So, I'm going to say h and we're going to say localhost like this. Okay, localhost 3000 and we're going to say / ai/callback/google. Now, in production, you might need to also add another URL in here that is your main website URL. Okay? So that way your app, your website can also the authorized source to receive this if that makes sense. Okay, cool. Now, if we need to do this once more, we'll do it. Don't worry about it. It's not too big of a deal. Go ahead and create this. And it's going to give you a couple keys. This this is super important. Okay, so first thing, copy this and paste it into your environment file. The client ID and the client secret. Okay, I'm going to pause the screen and do it so I can do it quicker. So copy these two and paste it into your environment file. Okay. Now obviously those those IDs uh those those names were not here so you're not going to find them but I just pasted it in here in case I lose the screen. Right. That's that's the whole point. And now go ahead and click on okay. And that's going to create your OOTH client right here. Awesome. Now if you go back to the documentation. So if you go back right here it says you need to run this section right here. Okay. So essentially once we I mean we've already completed this now we need to set the convex environment variables for Google o and so what we're going to do here is we're going to copy this command okay we're going to go back to our env ID this is the client ID. So that's the first one we copied. So I'm going to replace this with the new ID like this. And I'm also going to copy the second one. paste it in here and I'm going to replace it with this one. This is the Google secret. Okay. And now all we have to do is just follow the documentation. So the first one is we have to set the Google ID. So copy this, open up the terminal and right here you're going to paste it and you want to hit enter. There you go. Successfully set the authentication. And then I'm going to copy the second one as well right here. And this is a Google secret ID. So hit enter. And there you go. Awesome. Now, just to confirm that everything worked, if you go into your environment variables, you should see these two new variables in here. Okay? If you don't, please pause the video and go repeat this step. Now, we're still not done. We have a couple more things to do. So, you want to go back to the uh the convex o setup, and you're going to find these two libraries here. Essentially, it tells us to install this. Now, I don't know if npx this one does it for us, so we're going to need to do that. Okay. So, go ahead, copy this command and let's shrink this real quick. Let's open up the terminal and we're going to paste this right in here. There we go. Awesome. And the version numbers are as follows. So, we're still good to go. Uh, if you need to get the correct version numbers, this is what you should put. Okay. So, remember I taught you in the first command, right? You have to put at and then put the version number. And the same for the other one as well. Now, it tells that I mean it tells us that we need to copy this command. So, let's open this up. Okay, so it says we need to copy this into convex/s schema.typescript and that's how we put the o tables into our schema for the entire entire the entire application. Okay, so obviously we don't have that. So let's go ahead and say convex slash and it is schema. So I'm going to say scma.typescript and I'm just going to paste whatever I have in here. So whatever tables we want to create that goes right inside this function. Next, down here, you want to click on the Nex.js version, not the React version. And it's going to give you this convex off next server provider that you have to wrap around your layout.tsx. Okay. How do I know that? Well, it tells me right here. So, this is how you guys should read documentation. Okay. Um, so let's go ahead and let's scroll to our layout.tsx. And then in here, I'm going to copy this and write above everything. Okay. It's telling me to paste it above everything. So, that's what I'm going to do. And I'm just going to move all of this stuff into this new convex o provider. And let's go ahead and also import it. So I'm going to say convex o next.js server provider and we're going to get this version. Okay. So I think there's some sort of a type. Okay. I think I made a typing error. So let me just quickly All right. There we go. I made a typing error. Okay. So now we have imported and we're we're wrapping our entire application inside this provider and that provider is the server provider. Okay. And now we need another provider called client provider. So what we're going to do is we're going to copy this same thing again. So I'm going to copy uh make sure this is next.js. Okay. So this is app router with server side. Okay. With SSA. Okay. So let's go down. And now we need to copy that specific uh new provider which is the client side provider. And inside the body tag you're going to hit enter and you're going to paste this new provider. And now I'm also going to need to move this. So let's move it to the bottom and let's quickly import this. Okay. Looks like it's not giving it to me. So let's go ahead go up top here. And you're going to import this from actually I made an error here guys. Give me one second. Okay. So this one right here is the client provider that we need. Okay. So open up your folder structure. Actually just shrink everything real quick. You're going to go into your source and inside source you're going to create another folder called convex like this. And inside that a provider.tsx. And inside this provider.tsx we're going to just copy and paste whatever they gave us. And now let's go back in here and we're going to import this from the correct provider. So that is a client provider. And the reason it's a client provider is we're saying use client up top here. Now it's telling us to create a middleware file. And this middleware file is going to need to have all of the matro logic inside it. So let's go ahead copy that. And we're going to go into the root of our application. Now for your middleware file, please do not make this error cuz I've done this so many times. It has to be inside your source directory. Okay? So you want to say middle middleware.typescript TypeScript and you want to paste whatever they gave you. Now, inside this, I'm going to do some custom setup, guys. So, please just follow through with me. So, inside this function right here, we're going to pass in an arrow function. And this function is going to be async like this. And it's going to give us access to the request. Okay. And it's going to give us access to Okay, it looks like this took 10 steps ahead. We need the request and we need an object here. So, we're going to dstructure it and it's going to give us the convex o object. And then inside this, we're going to essentially say if and we're going to check um we're going to essentially check a matcher. And to check this matcher, we have something called a bypass matcher. So, we're going to create a route matcher for a for a bypassable route. Okay? And if you want me want it to be multiple routes, we're going to create an array of different bypassable routes. So let's go ahead and do that. So we're going to open up the folder structure inside libs. We're going to say permissions.typescript like this. And I'm going to say export const is bypass route, which is going to be the following. So it's going to be uh forget about these two for now. We're going to get to that later, but we might as well just do it right now, right? So, this is a bypassable route, and this route is also bypassable. So, once this is done, let's go back in here. And now we're going to need to import that. So, I'm going to create that bypass route. So, to do that, I'm going to say const bypass matcher. And I'm going to say this should be equal to create route matcher, which comes from convex dev. So, you just have to import it from here. And now you have to pass in the bypassable routes. Okay. So if this is true, so we're going to say if this is true, then we're going to return. So remove this and just say return. Then after this, so let's remove this section here. Let's remove this so it's clean. After this, we're going to say const equal08 convex oisauthenticated. And then if we're going to check if it's a public route, then we're going to reroute the user to the dashboard, right? And um if it's a protected matcher, then we're going to redirect them to an sign-in page. So first thing we're going to do is I'm going to say if public matcher, which is another matcher we need to create. So up here I'm going to say public route matcher. Public matcher equal create route matcher. And this is is public routes which is another array we need to create inside the same file. So go into the lib permissions and in here I'm going to say is public routes is equal to / and slash um the dashboard page essentially the main page right and let's quickly import that as well and then in here I'm going to say middleware redirect and this comes from convex as well. We're going to redirect the user to dashboard. So essentially if they are authenticated and they're trying to access some of the public matcher routes just send the user to the dashboard page. That's what we're doing here. And then after that if the user is not authenticated so if it's a protected matcher and just like always we're going to create that matcher up here. And let's go into this file libs file and let's create the is protected um is protected routes as well. So is protected is everything inside dashboard. Okay. So if this is true then we're going to go back here and down here we're going to say if they're not authenticated then return the UR uh the user to the sign-in page. Okay. And then finally down in here we're just going to say return and we have to set a cookie config. So after this right here we're going to put comma we're going to say cookie config. So, it's an object with cookie config config set to the following date. Okay, you can change this if you like, but um this is how I'm going to set it up in here. Now, let's go back to their documentation and let's make sure we're finished everything else. So, next we're going to click on manual setup because that's how we did it, right? We're just going to take a look at what this stuff is and make sure we have everything in here. Okay, so now it's telling me to add this tsconfig.json JSON file inside convex /tsconfig. So inside this I'm going to say tsconfig.json just like this. But I'm actually going to paste um a set of uh other commands that I had options that I already had. It tells you to set it to node. I'm just going to keep it to bundler. I just want to see what happens. Okay. But um this should be good. So make sure you just pause the screen and type these uh type these options out. Yeah, we probably should have done this this part first before we moved on to the next page, which was to set up the I guess the next one was not custom schema, but it was this stuff, right? So, what we're going to need to do now is delete the other JS files cuz this is now a TSconfig file, right? So, you're going to find a schema.js. Delete that. You're going to find HTTP. Just go ahead and delete all these JS files. The next thing it's telling us to do is to create this oconfig file. Now, that's already created for us right here. And uh inside this, it's telling us to add the following. So, we have convex site URL, which is something we got to add. And let's just make sure we have that as well. All right. So, it looks like I did not have that inside my environment file, but I don't think it's going to matter. But just in case, just paste that value that it wanted, which is this one. So go ahead and paste that in inside your environment file. And you want to paste your site URL in here as well, which is basically your Enro URL. Next, we need to initialize our authentication. Okay, so since we're using Google O and password, which is the two main ways our users can enter into our application. If you click on this, you're going to find um you're essentially going to find the authentication part already set up because we invoked that u those commands, right? We did the main setup in the beginning. So that's why it already created the boiler plate uh boiler plate for us. So what we're going to do is we just need to import Google from the O core package and password from convex's package as well. Okay. Now since we did this guys we're not going to need to do all of this but I'm just confirming to make sure I have everything right. So we also have this HTTP file which is cool. Set. Awesome. Okay. And I think that's all the files we're going to need to create for now. Now, go ahead and go back into your O folder into signin. And let's go ahead and complete this part as well. Now, the first thing I'm going to do on this page is I'm going to check if the user has signed in or not. Now, there's a little bit of back and forth here. So, just, you know, bear with me. We're not going to see any UI for now. I mean, you can see this, but it's not going to make too much sense. That's because we're in the process of pretty much wrapping this up, which is the main heart of the authentication flow, right? So, just please bear with me. Just keep coding along with me and it's all going to make sense. So, the first thing we're going to do is we're going to create a hook. And this hook is called use. Okay? I don't know why it changed that for me. Okay, there we go. That's the hook's name. And so, let's go ahead and create this hook. So, open up your folder structure. Inside hook, you're going to create use o.typescript. And inside this we're essentially going to create that that hook that we can use now. So in here I'm going to say export const use o equal to an arrow function. And this arrow function first is going to check if the user is authenticated. And so we're going to essentially use the use o actions hook. And this comes from convex. So let's go ahead and import that. All right guys, this is supposed to be a TypeScript file. So let's go ahead and change that as well. Okay. And uh I think I've also imported it incorrectly or maybe Okay. So this is the Nex.js version. We just need React. That's because this is a client side hook, right? So we're good to go. So we're going to say use o and we're going to get sign in and sign out here. Next, we're going to also need use router. So let's go ahead and grab that as well. And we're going to create a state here to see if we're loading or not. Okay. So, I'm going to say is loading equal use state just like this. Then, first thing is for the sign-in form, we're going to need to essentially create uh a use hook form zod resolver. If you don't know what all this stuff is, it's basically react hook forms and how we use the use form hook and the resolver to pass in a schema. So, it validates the entry, validates the data that's been that's been passed in. So, that's pretty much it. Okay. So use form when you think of that just remember validation of form. Okay. So all we're going to do here is we're going to say const signin equal to use form and let's bring that in as well. And this essentially is going to pass in a form schema called signin data. So first I'm going to dynamically create this. So up top I'm just going to say type signin data is z which comes from zod. And so up top I'm going to say import z from zod. And if you're wondering where this came from, we never installed it. It's it comes from shatzian UI. Okay, it automatically installs all of this stuff for us. And now we have to create the schema. So this is how we can infer the type of an object. Okay, so up here I'm going to say const signin schema equal to z.object. And in here we're going to need email and password. But I'm going to change this really quick. So I'm going to provide um an error message. So, for email, I'm going to say invalid email address. And for password, I'm going to pass in a minimum of six characters instead of eight. And I'm going to say password must be at least six characters. Now, I want you to take this up as a challenge. Pause this video and try to build the schema for the signup information. And for the signup schema, we're essentially going to need the first name, last name, email, and password. So, that's a hint for you. So go ahead, pause this video and if you can't do it, I'll show you exactly how to do this. Okay, welcome back. Hopefully you got the right answer. If not, no worries. This is all you had to do. So you had to say signup schema and you had to provide the same properties like this and you had to also put the error messages if you wanted them. Okay? And obviously we need that. So that's why we're going to do this. Next down here there's something called Zod resolver. Now, this is essentially how it resolves the schema data to our form data. So, I'm going to import the ZOD resolver, and this always acts up. So, we're going to need to go up top and import it from React Hook Form. So, at hookforms/resolvers/zod. So, go ahead and install that. And then down here, we're creating the sign-in use for hook and we're setting up the resolver. Right? So, go ahead, pause this video and take this up as a challenge as well. try to create the use form and the the the res the the resolvers for the signup form as well. Welcome back. Hopefully you got the right answer. If not, this is exactly what you needed to do. So, first thing is you got to say con signup form use form just like usual, but this time you're going to infer a newer type and this type is of type signup data. Okay? And that infers the type of this schema that we just created. So, if you did this, great job to you. You're paying attention. You're going to come a long way. You're going to go a long way in this project. Okay? If not, don't worry. You can still try. Give this a shot. Okay? These these tests are kind of like quizzes for you. Okay? So, take the quiz and do it honestly. All right? So, the first thing we're going to we're going to need now is um right down here, we're going to create some handle handlers. And the first one is the handle sign in the handle sign up and the handle sign out. So let's go ahead and do that. So right here I'm going to say const handle signin equal async data which is essentially the param right here. And this is of type signin data. And that is going to do the following right here. So right now I'm just going to set it to nothing, right? And we'll we'll come back to this in a second. And then we also need the handle sign up which does the exact same thing but this is using the sign up data. And then we also need the sign out data the sign out handle sign out as well. So I'm going to say const handle sign out just like this. And obviously this is a hook. So we need to return something from here. So I'm going to just return everything that we just created. The sign out signin the handle submit right? all of this even the sign-in form, the signup form and all the data that we need. So now let's go ahead and just complete these. So first for the signin what we're going to do here is we're going to create a try catch block and inside the try we're going to say await signin and this comes from convex which we just imported up here. So we're going to scroll down here and we're going to say sign in. We're going to invoke it and we're going to pass in the data. Now this data here is actually you can't pass it in like this guys. First you have to tell it what data this is. So you're going to say password and we're going to pass in the email data. The password is data.p password and the flow is signin just like this. And then after this if this is successful we're going to say router.push. We're going to send the user to the dashboard. Now, if there is an error, we're going to print the error. Then, we're going to say signin form dot set error, and we're going to pass in password is invalid. And then finally down here, we're going to create a finally block quite literally. And inside this, we're going to set is loading to false. So, we don't need this at the bottom. Okay. So, in here, you can also send a toast message. So, you can say toast. Invalid. You can do a bunch of stuff, right? So that's why it gave me that fill that uh that autocomplete. So go ahead, take this up as a challenge again and try to complete the handle signup function. Okay, welcome back. This is just slightly different. It's not too complicated. It's the same thing, but the only difference is first of all, we're using the sign in here, which should actually be the signup, but I don't think that should matter. Okay, so essentially Convex is just going to handle it um behind the scenes. they're going to do it if it needs to be a sign up. So, we're good to go. So, we're just going to say password, the email, and the password. But for name, we're going to say data.irstame and data.ast name. And we're going to use back tick right here. This way, we create the full name of the user. And for the flow, we're going to set it up to sign up. Okay, so that's the only difference here. Everything else is exactly the same. And here we're going to throw an error and we're going to say root for this error. And we're going to say fail to create account. Okay, so this is slightly different. And root essentially means for the entire form and this for password essentially means we're triggering it only for the password. And finally for sign out, we're just going to await the sign out that we got from convex and we're going to push the user to the sign-in flow or we're just going to show an error message. Now let's go back to our sign-in component. And now we can import this hook that we just created. Okay, make sure you import it from the right place. And now let's dstructure this to give us all the data that we just uh exported from there. And at the bottom now we're going to essentially get the sign-in form and we're going to dstructure some data from that. Okay, cuz it uses use form. So we're going to say register handle submit errors from the form state and we're going to set this equal to this because we're destructuring it from here. Now, hopefully you remember from all our past videos, if we're using a hook inside a page, what happens to that page? So, pause this video and try to guess. And if you don't know, I'll tell you exactly uh what the answer is. All right, welcome back. So, hopefully you said this component becomes a client component. And that's exactly what we need to do. We need to make this component a client component up here. So, that way we can use these hooks. If you don't use use client up top here, it's going to become a server component. Okay. And that will throw errors and then obviously you it'll probably either automatically convert it to a client tree or you have to state it up top. Okay. So once that's done, the next thing we need is the handle the handle submit. And what we're going to do is we're going to pass it into this onsubmit handler. So we're going to say handle submit handle signin like this. And everything else is going to remain the same, but we're going to change the input down here. So this input is going to be the email input, right? So let's go ahead and change that and we're going to say type email id email and we're going to use the spread operator for the register and we're going to invoke email as the type in there and then we're going to pass in the class name which is if there is an error just show border destructive. That's it. So that's how you set it up for the input. Now for the message for this we're essentially just going to use a paragraph and we're going to say errors.e. So if if this specific value has an error, return this. Okay. Then down here for password, we're going to ask actually for password, where is the So we have label. Okay, it's right here. So for this input, same exact process. We're going to change it to password just like this. And we also have to render the error message for the pro for the password as well. And then down here, if there's a root error, we're going to hit enter after this. And I'm going to say if there's errors.root, return that error message. And this has to be text destructive and text- center. Okay. And then we're going to have a button down here. And so for this button, first we're going to pass in is loading. And uh that goes into the disabled prop. So if it is loading, then we want to disable the button. And then finally, this has to be submit. So type submit. And then in here, we're going to say if this is loading, then we're going to return a loading spinner. Okay. So let's remove this stuff right here. And just give me one second, guys. There we go. So now it's loading with the loader saying signing in. And it says sign in at the bottom. And everything else is just for design purpose. You can do whatever you want with it. Doesn't really matter. However, there is one Google button right here. And obviously, we need to set up Google authentication through that, right? So, let's go ahead and set that up. So, first for this button, everything that's inside this, um, let's just quickly select everything and we're going to do command X. So, we're going to cut it out and maybe we might use it in a different component. So now go ahead and open up your folder structure. And you want to scroll down to the components directory. Why can't I find it? All right, there we go. And inside this, I'm going to create a folder in here called buttons. And I'm going to say ooth and I'm going to say Google.tsx. And in here, I'm going to return React snippets. And I'm just going to return this SVG just like this. Now, this is the same SVG that I got from the previous one, right? So, we just cut it out. So, I just pasted it in here. And now, I need a button here. So, first things first, I'm going to import this button from where is UI components. Okay. So, I'm going to first create the closing tag and then I'm going to try once more. Okay. UI button. So, there we go. And now we need this from the use O hook, right? So to uh actually sorry from the use o actions. So let's go ahead and import that. And that one comes from from convex just like this. And this also needs to be a use client component. Something seems to be wrong here. Okay. It's the name of this. All right. My bad. So we're going to change this to Google like this. And down here to Google as well. And that should solve that problem. It's just a TypeScript error. Uh we don't really need any props in this one. So let's go ahead and remove that. And so this button is essentially invoking the Google signin. And we're just saying void here. And at the bottom, we also have to pass in Google just like this. So that's going to return Google for us. But let's go back here. And where is that button? Okay, so that button was right here. This is going back to our sign-in page. So let's render out our Google button which comes from components off Google. Just like that. Oh, and one more thing. You can't put this inside another button or you're going to have errors. But, um, there we go. That's all you needed. So, now for the moment of truth. If everything went correctly, if you click on Google, it should take you to Google O. Okay, that's the consent screen. So, let's go ahead and click on that. Hey, there we go. Awesome. So, I'm going to try to log in. And when you try, it's going to give you the Convex site URL, and that's what you need. And then it's going to ask for the following information. Go ahead and click on continue. Okay, looks like something is wrong. So the the problem here is that we haven't set up Enro to actually run. So go back to the static domain. We're going to copy this domain. We're going to go back to our application and let's open up a different terminal and let's paste that and hit enter. And if you can see, our new URL is in here. And that's going to actually send it to the wrong address. So, what I'm going to do is I'm going to disconnect this and I'm going to change this guys from 80 to 3,000. Okay, please make sure you do this as well. That way, it redirects all um all requests to this endpoint. So, now if we go back to our application, let's give this a chance. Uh let's give this one more chance and hopefully everything went goes smoothly. Okay, so when I click on login, it's taking me to this page. Let's just click on visit site. Let's see what happens. Okay, I think we're logged in. Let's uh let's check once more. All right, that makes more sense. So, when you hit this endpoint, essentially, it says, "Well, I I can't find any of your endpoints." So, there's no call back URL. So, I think that might be the reason why we're seeing these errors. So, let's go ahead and shrink this. Let's open up our folder structure. and inside source inside app we're going to create the API folder and now let's go ahead and build the callback routes. Okay, so I think I found out what's going on. So right here we're using the site URL and if you try to log in using localhost, Google is essentially going to send you back to this URL. So that means you can use this to sign in as well. And so that's exactly what I did. And I signed in. And just to show you that I'm actually signed in. If I try to go to the odd/signin route after being signed in the middleware, it's going to redirect me to the dashboard page. Okay. So throughout this project, we'll be using this URL. If we need to swap to the local host URL, no problem. We'll do that. We don't have to worry too much about that right now. But so far, we have completed authentication. Awesome. Now let's move on to the next part. Now, let's go ahead and create our schema for the tables in our application. So, go into your convex folder. Click on schema.typescript. And after this, you're going to hit enter right here. And now, we're going to create the tables. Now, this is not too big, but at the same time, it's a big waste of time if I just explain what's already written on the screen. Um, and so I'm just going to give you an overall idea of how to create a table, how to create, I guess, columns within that table. So the first thing is this V here which is a value. A value is essentially how you determine the table the column of that table. So if it is a number you'd say V dot number. Now that column becomes a number. Simple. The other thing you need to understand is how to create a table itself. So if you want to create a table you have to call define table. Once you invoke define table, you can essentially pass in the properties which are the column titles and the values. That's literally it. So with that being said, I'm going to go down here and the first thing I'm going to create is project counters. So go ahead and pause this video and type the following. And these are going to have these two properties right here. The next question you might have is what are these indexes? Now I'm not going to get into too much detail. that's out of the scope of this video. Our goal, like I said, is just to build an MVP as fast as possible, right? So, there's no point understanding the technical stuff. In fact, if you probably just use AI, it would do all of this for you and you wouldn't even need to think about all of this. But just for those who want to understand a little bit more. So, these indexes essentially, it's kind of like a book index. Okay? And it basically creates a faster way, a faster system to look up items. So essentially it just it's a faster lookup path so you can query and get results faster. That's literally it. So the key takeaways is indexes equal speed. Indexes are faster to query and get results. So that's basically what an index is in a very non I guess engineering way. Okay. So next let's go ahead and create the next table. So the next one is the projects table. So up here I'm just going to say projects like this and this is going to have the following. So please don't put this. This is just AI. So the first properties that we're going to put is this. So we're going to have user ID, name, description, style guide, and sketches data. And when you get the codebase guys, you're also going to get more code comments just like this. So it might help you understand a little more about the codebase as well. Okay, but um this is essentially the JSON structure and it's going to be used inside Redux to match the shapes. Okay, and all of the other states for that specific project will be managed through of sketch related data will be managed through this property. Okay, the next one is viewport data. So this is essentially for the viewport state. And then we have a couple more. So I'm going to go ahead and grab these as well. And the mood board image is maybe something you'd be curious to know. So this is essentially an array of different images that sets the theme for the application. Okay. Next we have inspiration image and we have a few more. So let's go ahead. Okay. Let's go ahead and grab that. Right here we have last modified created at is public tags and project number. Okay. So please pause the video and type whatever we have so far or obviously you guys can get the codebase. So you know you have it side by side so you don't have to waste time on this and you can just understand a little bit about how the codebase works or uh maybe you can just spin it up and you're ready to go right the next one we're going to create is the credits ledger. So this is essentially how we keep track of the credits used uh by the user. Okay, very straightforward. User ID, subscription, the amount of credits, the type uh reason and we just need some more values. So we're going to store that as well. And as you can see, we're using these indexes right here as well. Finally, we have one more these um in this table is called subscriptions table. And this is going to look just like this. Okay. So, it's going to have uh user and we're we're going to be using polar for subscriptions. So, I might as well put it right now. And that's going to have the price ID, the plan code, status, all this kind of data that we need. Okay. Very important stuff. So please, please pause the screen, type the indexes, type all of the tables that you see on my screen right now, and once you're done, we should be good to go. All right, so here's the coolest part of using Convex. So unlike in Prisma where we need to create a new entry, a new property in the schema, and then need to run Prisma generate and Prisma migrate to push these to the database. All of this happens in real time without you needing to do anything. So what that means is as we were creating all of our tables inside this this schema file, it automatically updates inside the database. How cool is this, right? And obviously it's also the other aspects of it being reactive is once something changes inside the database through the mutations, you can use that data. I mean it will instantly refresh your front end. you can get that data without needing to use a pooler or without needing to do, you know, do some sort of invalidation of cache, all that kind of stuff. It will render in real time. So, here's like a quick run through, I guess. Let me just show you what that looks like. So, let's refresh this real quick. Now, you don't have to do this, but I just want to show you, right? So if I add something in here, let's say I just say credit grants, something like this, that's going to show inside my database, right? And you see it updates in real time. So before this, I actually pasted it and then removed it. And so that's why it was trying to remove it. And it just gives you a warning. It doesn't immediately delete it obviously cuz that's not good. But it shows you this is not in your schema. So if I if I remove it, it's going to have this little, you know, star symbol here. And if you hover over it, it's going to say this is not in your schema. All right, so it's all in real time. All right, and that wraps up the database section. Let's move on to the next part now. Now, in this section, we're going to be looking at the design and theme for our application. Now, for some of you, this might be quite a task because designing is not, you know, not for everybody, but I love designing, right? I have been doing this for a very long time and that's why all of my projects have a very I mean it has a similar touch, right? Because I I like this kind of dark mode design. It's just my vibe and I put that in all my projects cuz I I love it, right? But um I just wanted to say that we took a lot of our time aside. We put a lot of our time aside just to figure out this design. So I really believe that the way to get the outcome to your customer is through this user flow which is they create a project they create the mood board. So they add a bunch of images which uses AI extracts the mood board into some reusable styles and obviously a font and then that's it. Whatever they design will use that mood board. Super cool right? So we have spent a lot of our time doing this and so do not try to create your own variation. Just follow the video, right? Or at least you can grab these from the description. These are available for you to grab. You can get it as you know just as a Figma design or you can get it with the bundle with the codebase as well. Right? And the other cool part of this is it comes with every single Shatsian component. Right? And here's a another another really nice thing about this Figma project is if you click on any one of the containers, you can change it from light to dark mode as well. So all components are light and dark mode compatible. Okay, every single one of them. And so now you have a scalable Figma design system, UI system with all of the components built in. So if you have a development team and they need a feature, your feature can be converted into a design and the other way which is design to development smoothly. And the what makes it really smooth is obviously light and dark mode. That's the first one cuz they're all set up with primitives. And the other thing is each of the colors. So if you click on these, you're going to see some colors here, right? So if you notice all of these are shadsian naming conventions. So these are shadsian gener or tailwind classes right and in shadsian they use the same tailwind class and so it's easier for your development team to know what they're doing. So I would highly recommend you grab this from the description. It's obviously it's going to teach you a lot or you can just grab the codebase which comes with everything. So hopefully that that gives you all of this value, right? But this is pretty much a ballpark of what our application is going to look like. Obviously, we're not going to be able to do this exact thing right now because we're in a time constraint and this is an MVP. However, you can use this design to expand uh in into the future, right? U but that's pretty much it. This is what our design looks like. So, now let me show you um how you can translate this or how to essentially copy the styles in inside your application. So the first thing that we you should probably do to convert this into into your application is be in development mode. Okay, there is a design mode and there is a development mode. You would need to be in that so this is easier for you to convert. Now obviously I'm not going to do everything right now. The best way to do this is just go to Shats and themes and cap just grab a theme and put it into your CSS file, but I just want to show you in case you get the Figma design how to get all of these colors from it. Right. So, first thing is make sure you're in development mode. The second thing is right here. Make sure the colors are not hex but set to HSL. Okay. So, you can copy these values. And I believe so that let's just go let's go to design real quick. Sorry guys. You want to click on this one. So, don't click on this because this is going to just copy the name. Instead, you want to click on this. And there you're going to find the HSLA values. Okay. And I think Shadzen uses this as well. So this way it's easier for you to translate. Now you can also just use the hardcoded colors. This is fine too. Um you and to do that I'm going to show you an easier way. So in our application uh sorry in our Figma project we're using variables. And so if you click on this and switch this from internals to primitives you can essentially see the colors for each individual style. So for border what do we have? Right? So you can go through each and every single one of them. And this is for all type all type of colors. And then we also have tokens. So tokens are especially for you know spacing uh border radius all that kind of stuff. And it just maps all of the values to these uh to these defaults. Okay. So the value so bg secondary 50 maps to this. That's that's pretty much how it works. And this is essentially from the primitive section. Okay. So light and dark mode are set up through the primitives. So, light and dark and that will alternate inside the app. So, that's pretty much how it works. If you're wondering what's the sauce to do those cool uh you know light and dark mode swapped uh primitives, right? This is how to do that. Now, uh you can grab this from the description or you can get the codebase and you will get this uh along with that and I think that is for a limited time. So, don't forget to scroll to the description and grab the codebase. Okay, so let's move on now. So, I've already done that piece by piece, every single letter at a time, and I've got all of these styles ready, right? So, I've pasted it into another file. And so, all I'm going to do now is go into my source, go into my app globals.css, and I'm going to replace whatever is in this file with the new styles, the new classes, the new colors that I've created. Okay. um only some of them are changed, not every single thing, but uh I'm going to use what I have at least as a closer resemblance to my design. So once this is done, let's uh make sure the okay, we don't have a Tailwind config. So that means we are on Tailwind V4. So the next thing you want to do, go ahead and shrink your folder structure. Inside app, I'm going to create a route group called protected. And inside this, I'm going to create a dashboard route and a page.tsx. tsx and also let's go ahead and just quickly return a react fragment just like this and let's remove these props we no longer need this now I like to think about the linear flow of my user when they first visit my application so after signing in what happens next that's very important right so in this page it's not actually the dashboard it's kind of like a redirect I guess path right where in this page We decide if the user has a subscription or not and then we send them into the next page. Okay. So obviously this is done at the page level. Now in a production grade environment you'd want to use what we call a DAL structure DAL architecture data access layer and then through this you should basically look at all of the uh user requirements and then do it do this verification not just at the page level but also at the API level. Okay. So this way if someone forgets to do this logic in a different page that is supposed to be protected, it will still throw them back to the buildings page or you know the sign-in page whatever their condition is regardless if a developer forgets to put that check inside this page. So never always let only this be let this be the only check that the user has to go through. Okay. So, we have middleware, we have this, we're going to have in the future, you should probably upgrade, do the data access layer as well, all that kind of stuff. Okay? But I'm just giving you a heads up as to, you know, what a production grade version would look like. So, that's what we're going to do in here. Okay? So, the first thing I'm going to do is I'm going to create a subscription checker. Now, obviously, we don't have the subscription logic, right? So, I'm just going to say add billing logic in here. and I'm going to get the information I need. So, first thing I need is the profile name. So, I'm going to get the user's name. So, I can add that as their session. So, inside the dashboard, I'm going to have a dynamic route called dashboard/ whatever their name is. So, let's say if it's parent, it's going to say dashboard parent, right? So, they know their project uh list page. That's what it is. And so, to get that, I need to use this helper. So what I'm going to do is I'm going to create this helper here called subscription entitlement query and also this needs to become an async component. So let's switch that as well. And let's go ahead and create this one right now. Now open up your folder structure and inside the root directory. So inside root of source right here you have this convex folder right. So inside this you're going to say query.config.typ TypeScript. Okay. And inside this we're going to say export const and we're going to export this arrow function. Oops. What am I saying? This is supposed to be equal to. Okay. Nice. All right. And obviously make sure you're exporting it as well. Right. Uh now just put your pen down and just focus for one second. I just want to explain a quick concept. Okay. So there in convex we have something called queries and mutations. So what do they mean? Now before I give you the answer, I want you to look this up. I want you to learn how to do research. So this this is for my my nerdy developers out there. Okay? I want you to get into the habit of reading documentation. So pause this video and just Google and look up what are these mutations and what are um you know what are these queries? What do they mean? Okay, awesome. Welcome back. Hopefully you got the right answer. If you didn't, no worries. This is a low-level explanation. Okay, it's not going to be too technical. It's just enough to help you understand what these core concepts are. So, what's a query? So, a query is essentially like a readonly function that um that runs on convex's servers. Okay, it helps you fetch data from their database. So a real world example would be something like what are what is what does my data look like or show me my users's profile. These are queries. Okay. What's a mutation? A mutation is the opposite. It's a write function that changes data in the database. So an example would be something like create this new project or delete this project. That's a mutation. Now, there's another awesome feature in Convex called preload queries. Now, if you're not a web development nerd, you may not understand, but just to show you. So, preload query, I want to make sure I get you the right definition. Okay. Okay. There we go. This is how I use AI. So, what a preload query essentially does, think about it this way, right? Before you access data t in a typical NexJS application, it would make a request to the server and then that would show you a loading screen, right? Or it would just be like it would just pause, right? Cuz it's getting the data that it needs. Now, with the help of the preload query, you can load this data before the app even starts. How awesome is that, right? So, this means your users get instant data in front of them. they would not even know they it would feel like it never fetched right so convex can really come in handy especially for applications like this right especially for S2C where real-time data preload all this kind of stuff comes in handy okay so now that you know these concepts I'm not going to explain all of these things over time right because I expect you to do this research yourself all right so moving on that was enough of uh Prof Professor, Professor Parrot. Now, right in here, in order to get the subscription data, I need to understand what is the profile data look like for the user. So, I can determine if the user has access or not. Right? Very straightforward. So, in order to do that, I'm going to create another query up here. And this query is called profile query. So, what this query does is it uses this preload query, right? And it's going to load in the users. Now, I'm going to point out and show you exactly why we're seeing this error, and hopefully everything else makes sense from there. But we essentially need to preload a query. Okay, that's what we're doing in here. So, let's go ahead and quickly import this. So, first thing we need is a pre-load query. It comes from convex next.js. I'm just going to bring that in. And we also need this fetch, but I'm just going to remove it for now. And we also need this token. So, let's go ahead and bring that in as well. So, you see this API, right? This one comes from convex's generated file. But hey, it says we don't have any users. You can look into it. You'll not find anything. That's because this query does not actually exist. We haven't created that query. Remember I told you it's a function, right? So let's go ahead and create that query. So because all of this is powered by convex, it has to be under the convex folder. So inside this, I'm going to say user.typescript. And inside this we're going to say export const get current user equal to an async function. And this actually is not an async function. It uses query. And query comes from generated from the generated folder. So generated /server. So let's go ahead and invoke this. And inside this first we're going to pass in the arguments as empty. And then we're going to need the handler. And the handler is going to say async. And we're going to say user ID is await get user ID. Okay. And this is uh a function that we need. So let's go ahead and grab that. And the good thing here is this is already created by the convex dev oserver. So you see a lot of the work is already done for you, right? So now you can invoke this. You can pass in all the values from here. And if there is no user ID, return null. And if there is, then we're going to say db.get get for this specific user ID. Okay, now let's go back really quick. And now you see it the user uh the API has this user stuff. Okay, awesome. So now let's go back to our query.config.typescript file and then inside this we can now proceed from here. So I'm going to go ahead and call this profile query right here. So that way we can get the raw profile data. So I'm going to say raw profile data equal to await profile query. Now, we're going to normalize this data. And this normalize comes from another custom function. So, I'm going to create that in just a section, but essentially in just a second, but we're just going to normalize the profile data and just extract all of its names. You know, the name of the user, remove underscores, all that kind of stuff. And then, um, we're just going to also set this type on top of it. So, let me import this one as well. And actually, sorry, it comes from the same file. So, we'll go into the same file and we'll do it. So go ahead and copy this normalized prof profile data and then you want to open up your folder structures and folder structure and you're going to go into types. So create a folder inside the source directory. You want to call it types like this and inside this we're going to say user.typescript. And in here we're going to create that normalized profile. So first thing I'm going to do is I'm going to export this function like this. Right? So export sorry const normalize profile data. And we need this convex uh user raw data. So let's go up top here. Going to hit enter and I'm going to create this type. Please please pause the screen and type it with me. Okay. And we also need the profile information. So for this I'm going to say profile like this. And I've also put some some code comments here and there so it helps you understand a little bit more. Uh this is not too informative but throughout the application you'll find more code comments. Okay. And now here we need to essentially return this data right. So let's go ahead and first say if the raw data is uh not existent then we're going to return null. But if the data does exist then first I'm going to say const extra name from uh extract name from email. We're going to get their email like this. I'm going to say it's a function here that takes the email and it returns a string. We're going to say username at the first element and then we're going to split it using this uh these functions. Okay, so please pause the screen and type this out. We're just extracting the name from the email. And now obviously we need to call this. So I'm going to say const name and I'm going to use another helper function. And this helper function is called combine slug. So it's going to help us combine the raw name or extract it from the email. So, let's go ahead and open up your folder structure. You want to go into libs inside utils. And remember, we used this um actually, sorry, we never I don't think we've used this before. Yeah. So, what we're going to do is paste this in here. That was just me uh kind of testing things before I showed you, but um now we're going to create this combined slug. Okay. Takes the the name and the max characters and it just breaks down whatever you give it into a name. That's pretty much it. So, pause the screen and type this out. So it gives you a slug essentially. So now going back here, let's quickly import this. And now we have the new name. So now we can return this data. So I'm going to say raw ID created ATMs, whatever, you know, whatever we need, whatever data we need. Um, which is this. And that's pretty much it. So now let's go back and let's import the normalized profile function. And we also have this one. So let's import that one as well. And now we have the profile information. Next, we're going to preload this query. So it does this earlier. And what's this query? So this is a subscription query. Now, obviously, we don't have subscriptions set up, but we can essentially do a part of the work, right? So let's go ahead and set that up as well. So go ahead and please type this out with me. I'm going to say const entitlement equal await. And we're going to say preload query. But now we're not going to have this, right? Just just a moment. But before that, I'm going to change this as well. So as a second argument, I'm going to pass in the following. So I'm going to say ID as generic generic, which comes from data model. So let's go up top and let's bring that in. Okay. And now we just need to uh fix this error here, which is the subscriptions. So let's go back into our convex folder. I'm going to create a new query file. call subscriptions.typescript actually please rename this to subscription. Okay, that should be it. And now let's go back here and let's copy this name get enti entitlement and uh now we can we can search we can create that inside that file. So I'm going to go into subscription not subscriptions like this. Okay. And inside this file, I'm going to say export const uh has entitlement. All right, sorry guys. One more quick error. This is not get entitlement. This is has. Okay, so has entitlement right here. So now we can copy this and let's go in here. I was wondering why I have the wrong name. So now I'm going to say export const has entitlement equal to a query. We're going to invoke this and inside this query first we're going to need to pass in the arguments. So I'm going to say user which is v do ID and remember this is the value. So we're going to bring that from here as well. Uh so v do ID and for users. Then the next one is the handler. So let's go ahead and bring that in as well. So import query real quick from generated servers. And then down here, first thing I'm going to do is I'm going to say const now equal date.now. And then for so just please type this with me, re so right here, I'm going to say for const uh subscription from this specific entryquery subscriptions within the index. So you see how this comes in handy, right? Because now we can query faster. And uh we're just going to check if it they have a current active subscription. That's pretty much it. Okay. So current period end equal equal null or it's greater than now. So if it is greater than now then we're going to check if status is equal to active and we also have an a currently active period then we'll return true. If not we have to return false. So down here return false. Now if you go back into your query.config config file down in here. We are essentially passing this. All right, there we go. No more errors. And now we have to return this data. So I'm going to say return entitlement uh profile name, which is profile.name. Now let's go back in here into our dashboard page. And the first thing I'm going to do is I'm going to import this new subscription entitlement query. And then in here I'm going to say if there is no entitlement value JSON then I'm going to resend I'm going to send the user sorry going to send them to / billilling combine slug and pass in that profile name. Okay. And uh if not then we're going to I mean if they don't have entitlement then we're going to send them to billing so they can make a payment. And if they do then we're just going to send them into the dashboard page. Right. And now we can remove this page.tsx. We don't need react as well. Awesome. So now we can uh remove this logic. We don't really need the to-do because we have completed it. Awesome. Now just so that we don't miss this, I'm going to create a billing page here. And I'm going to return a React fragment real quick. Call this page. And then in here I'm going to say to-do add subscription billing logic. Okay. Awesome. Now, to show you what this looks like, if I access the dashboard page, it should create a new session for me, right? And send me to the billing page. So, let's go ahead and hit enter. Oops, that was a flash. Sorry if I blinded anyone. And as you can see, it's it now has sent me to my own session. Okay, awesome. Great job. Sorry about that. Sent me to my billing, not my session, but billing page slashmy session. That's what I meant to say. Okay, so that's what's going to come in here. But obviously, we don't have the dynamic route for billing setup and all that kind of stuff. We'll get to that stuff later. But for now, what I'm going to do is create another to-do here, and I'm going to say remove billing hardcoded path, whatever. Okay. And now what I'm going to do here is I'm going to copy this. We're going to shide that away. And now it should take me into the right page. There we go. Dashboard. Great job. Now, one more thing I'm going to do in here is for the dashboard page, I'm going to create a loading page. So, in here, actually, let's not save that. So, loading.tsx. And I'm just going to paste something in here, guys. Now, I'm not going to create all these loading states for you. I think you already know how to do that. Um, you can also use AI or you can just go online and find a loading state and just paste it. Okay? It's just a loading state for the dashboard. So now let's go ahead and create the dynamic route. So inside dashboard you want to create a folder like this called session. And inside the session you're going to create a page.tsx a layout.tsx as well. And inside this we're going to also create our canvas style guide style guide all those kind of pages. Okay. But for now inside this page.tsx tsx. Let's quickly return a React fragment just like this. And I'm also going to remove the props. Now, in here, the first thing we're going to do is we're going to grab all of the projects. So, first thing it's actually throwing default export is not a React component. Which page is this? Layout.tsx. Okay. So, we got to return a layout in here as well. So, let's go ahead and do that, too. And a layout.tsx tsx gra we get the children items we're going to grab that in here and we're going to pass it down in here okay now the first thing first thing we got to do here is we're going to make this an async component because we're going to also get the subscription entitlement from here as well so go ahead change it to async and I'm going to say profile name entitlement like this equals subscription entitlement query and then I'm going to say if nothing is here redirect the user to this specific page. So, redirect to billing combined slug. But obviously, we don't want to go there, right? Because it's going to take me there all the time. So, what I'm going to do here is I'm going to put a to-do and I'm going to say remove this path and dashboard just like this. All right, there we go. Now, you can see a page render. Great job. So, down here, what I'm going to do is I'm going to return another component like this. And this component is going to have a navbar component. And that's going to look something just like this, right? Something very similar to this. So, let's go ahead and copy this title. We're going to open up our folder structure. And we're going to scroll down into components. We're going to create navbar. And we're going to say page.ts. Oh, sorry. We don't need page index.tsx. And now we're going to render a React fragment as well. And the uh the props in here. Actually, we don't need any props for this component, but this needs to be a use client component. And the first thing we're going to do in here is we're going to get search params. So, I'm going to say search params just like this. And we're going to get the project ID. So, I'm going to say project ID is params.get project ID just I'm sorry, project just like this. Now, we're going to render this out somewhere else, not right now. So what you're going to do is you're going to scroll down here and you're going to remove this return statement. Actually, you're going to have a div. And this div is going to have the following class names. So please pause and type with me. Okay. So you're going to create a grid in here. And the first thing is going to be a link item with the project name. So I'm going to say div link like this. And this is going to have the name. And this me actually comes from another variable here that we did not create yet. And I'll and I'll show you what we're going to do with that. But for now, I'm just going to remove this. Okay. And I'm just going to hardcode it to a URL like this. Okay. But eventually, we're going to store that data locally inside a state provider. And then we're going to grab that quickly and render it out on the screen. So now let's see if we can also render this navbar. So let's go ahead and import the navbar from our layout.tsx. PSX. And if you if you refresh this, let's see if it throws any errors. Okay. So, I was wondering why why was this page showing up? It's because it's coming from the layout.tsx, right? So, um after this, what I'm going to do first is just go back to the page.tsx and I'm just going to remove that. So, it removes that for me. Okay. And now, let's go back into this component right here. And down here, we're going to check for some values. That means we're going to check if they have a canvas or um you know they have some data and accordingly we're going to render the project name. So if it's if it's active that means they're actively on a canvas or on a style guide we'll show that there. Sorry we will not show that there. Okay. So what I'm going to do is if they're not on canvas or they're not on style guide then we're going to show the project name. So this is what that's going to look like and it's going to hide itself on desktop. sorry, on mobile device. So, this is what it looks like right here. And we're kind of going for that Excaliraw type vibe. I mean, apparently that's that's like the best way to do this, right? So, um that's why we went with that design and uh we thought about it because it I mean, we thought it'd make more sense because people are more familiar with Excaliraw and all those kind of tools, right? So, now let's go ahead and grab those params. So, I'm going to scroll up top here and I'm going to say if the path name and where is this path name coming from? Well, the path name is going to come from use path name. Okay, so let's go ahead and say use path name after this project right here. So, use path name and let's import that from next navigation. If that has the following canvas or style guide, then we're going to render those down in here. Okay, great job. Then the next thing we want to do is we want to render the project's name. So right now in here we want to render that name right and in order to get that we need to make that query call. So what I'm going to do is I'm going to use a query call api slash sorry api.p projects.get project and I'm going to uh check for the following and we're going to return the project detail. Okay, so obviously this does not exist because we haven't created those queries. So let's go up top here and let's create that as well. So inside your convex folder, I'm going to create projects.typescript just like this. And then inside this folder, I'm going to say const. So export const get project is query like this. We're going to invoke that and we're going to get the value which comes from context convex/v values and we're going to get the o user ID which also comes from convex o and then we're going to say if there's no user ID throw an authentication error and if not we're going to get the project ID. Now if there's no project also we're going to throw an error from here. And if there is a project user ID and it's not equal to the user ID and there's no project. So project is public. So this is uh set to not true. Then we're going to throw access denied as well. Okay. And then we're just going to simply return the project from here. So this essentially uh helps you expand on if you want to share the project outside all that kind of fun stuff. We don't have to get into that right now. Okay, so now let's go back and that should satisfy this error right here. And so if you look at it, there's no project. So it's not going to show the project ID. Great job. The next thing is after this, I'm going to create another div right in here. And this div is going to have another div inside this div. And please pause and type all the styles. Okay. And inside this, we're going to just loop over all the tabs that we have. And the tabs that we're going to have are as follows. So I'm just going to scroll up top and after this down here I'm going to say the following. Okay. So I'm going to say tabs u like this and this is another prop we need to create. So I'm going to go ahead and do that as well. So up top here we're going to remove these props and we're going to say label href and icon. Okay. And we're going to render that down in here. Now we need the hash icon. So let's bring that in from lucid icons. And we also need layout template. So let's bring that in as well. Now, this me essentially is the data that we're going to get and store locally. Now, obviously, we don't have that. So, just to show you, I'm just going to remove these for now. And I'm going to render that in just a second. Okay. So, in here, all I'm going to do is say tabs dom. I'm going to return a link element. Forget about the styling. We'll explain that in just a second. And then we're just going to pass in the key and href, the styling, the class name essentially. And down here, we're going to have a span. And this span is going to be the icon. And we're going to have the label. Okay. And these are also going to have some class names. So just pause and type with me. And if I open this, there you go. Okay. Awesome. So you have Oh, my cursor became huge. That was crazy. So now you can see the two sections that we created, two tabs. But obviously it does not have the right links. So we need to update that. And uh we'll do that in just a moment. We're almost done with our navbar. So let's scroll to the bottom now. And after this div, you're going to hit enter and going to create another div in here. And inside this div, we're going to have a span first. And this is to show the user their credits and how much they've consumed. And in here, I'm also going to say to-do something like this, whatever credits, right? And then we're going to have a button. And this button, let's go right here. We're going to import this from UI button like this. And this is going to have the following styles. And it's going to have a icon here called C circle question mark icon. So let's bring that in as well. And then after that we're going to render out the user avatar. So after button you want to hit enter and you want to say UI avatar and the image as well. Let's just quickly import all of this. And now, yeah, we need to show the image in here. But obviously, we do not have the image. But where are we going to get this? We're essentially going to get this from that local state that I was talking to you about. Okay. So, let's go ahead and build that section now. Now, let's move on to understanding how to get that data in here. Remember, I said there was something called me uh email or something like this, right? How do we get this data? Now inside this navigation component this navbar component what we could do is we can make an API call right we can do this um and after we get the data we can store it inside a variable and then we can extract that data and render it into the component but what's the challenge here I mean what's what's the drawback of doing this if you store the user data inside this component can we use it in another location I want you to pause this video and try to If data is stored locally within a component, how can other components get access to them? Okay, welcome back. Hopefully you got the right answer, but if not, no worries. This is exactly what that means. So for another component to get access to data stored inside this component first is it'll have to be a client I'm sorry, a child component in here and you can pass that data as a prop. You can pass that into that component. So you will take the state from here and you would have to pass it down into that component. Now over time this becomes very annoying, okay? Cuz you're going to be prop drilling all of your components and this happens a lot in Nex.js because they're all serverside stuff and sometimes we want data to show up on the first paint. So what developers do is they shove all this data into this um you know into that by doing prop drilling and it's okay sometimes it happens that's just one challenge with Nex.js JS and in in a way it you also win out of it. Okay, but I want to show you a better way to do this and in all my past videos this is the approach that we usually take. Now instead of just storing the state inside this what we do in I mean what we did in our older applications is we used React context API. Now what this is is essentially think about it as creating one location a source of all truth for all data that might be needed by other components as well. It's a global state management tool uh or you can think about it as an API for your application. Okay. So that way all components can access the same data. So let's say you had user profile data you store it in there and any component can access this. Now the benefit is that since the data is accessible in there it's instantaneous to the user. They do not see any loading for the data itself. Okay. But obviously context API is it's not it is production grade but it's more like for a smaller set of components that need to share a limited access to that data. So let's say you had a bigger architecture I mean a bigger application and you had a forms section you had a form uh stepper component inside your app and now you wanted to localize data only within that form state because there's already a lot of data in the global application and so what you would do is you would create these little tiny little pockets of data that's where we use something like react context API okay that way the data doesn't poison the main global state in any way so there's no confusion different teams can work independently, all this kind of fun stuff. Now, this is very technical stuff. I'm trying my best to not explain technical things over and over again because um I mean this is just for my nerdy friends. That's pretty much it, okay? But if you are a SAS engineer, I mean SAS developer who's looking to start a SAS, you should be least bothered about all this stuff, okay? But I'm just helping you understand how this will scale and why I made this decision for you to use whatever I'm going to show you right now. So that is React context API but like I said it's mainly used for localized state management within a subsection. Now there's another tool that essentially helps with all of this right it's called Redux. So Redux is essentially very similar to React context API except it it has a more standardized process as to how it stores data and it's used in most businesses as the global architecture that global state management. So think about it as Redux is for the global app the entire app. So storing data in one single store for the entire app. And then you have this React context API which is smaller subsections that you can create. So in our application we do not need to use React context API because first of all I've done it in all my other videos and I've essentially showed you how to use React context API to create your own Redux from scratch. Okay? So if you want to watch that and if you're a developer, you just want to learn how to use uh React Context API and build your own little store completely from scratch, you can watch my previous videos. I think one video uh which is really good that demonstrates this is Plura. Okay, Plura is the website builder tutorial that I built. That's one of my favorite videos and my audience's favorites as well. So go ahead, take a look at that video. You might learn a ton from there and you can maybe come here and, you know, uh explore some of those and use what you've learned inside this app as well. Okay. But in this app, we're going to be using Redux. So with the help of Redux, we're going to have a global state management for the entire app. Now, with Redux alone, there comes another challenge. Obviously, everything lives in one place. But Redux alone has a lot of boilerplate code. That means you need to write the actions, the types, and if none of these make sense, that's okay. Don't worry about it. But think about it as the little building blocks to building Redux, right? So, think about it as building a house. If you have to build a house, you're going to need all these tiny little sections, right? These tiny little helpers that are going to help you build build the entire house. So, you might have someone who's going to paint the walls. You might have you might need all of these things to build the entire house. Now, when you use Redux alone, you would have to build all of these individual individual teams in order to build that full store. Okay? But there's another tool called toolkit and redux toolkit which I think we have also used in my previous videos is essentially all of those tools that I was talking about right all of those little team members that are going to help you build that house it's already done for you they have done the heavy lifting so you can just leverage the toolkit and reuse their logic inside your application so you don't have to build those teams from scratch okay that's like a kind of just to compare so if you're not a technical person it makes sense for you. Okay, so that's what Redux Toolkit does. And my favorite part is instead of writing 50 lines of code to set up Redux, you probably only need two or five lines of code for the uh for the Redux toolkit. Okay, it's a huge jump and you might not see the older companies use it because they're still stuck with the older uh you know method of using Redux and that's okay. That's fine. All right, we are building our SAS application. We don't care about them. Okay. Now, in our app, we also want all of this to be scalable. And so, that's why I really believe that Redux Toolkit is the best way cuz it's the least amount of code and the maximum scalability for your application's global state management. Okay. And if you need to use React Context API and tiny sections, tinier sections to kind of uh box up all of that data and you know, not poison the main uh the main full global source, you can do that as well. You can watch the other videos and come to this. And so we'll be using Redux Toolkit. Now there's another thing, another concept I want to quickly walk through which is Redux toolkit query. So it's called RTK query. So this is a newer tool that I've not used in my previous videos. And so think about Redux RTK query like a tool inside the Redux toolkit itself. Okay? And its main goal is it's it's designed specifically for talking to servers and API endpoints. Cool, right? So think of it like the messenger between your app and your database. So without RTK query, you would typically need to make a fetch call. So you'd have to make a fetch call here. Let me write down some steps for you. Okay, there you go. So hopefully this makes more sense. So if you're doing just Redux toolkit by itself, you would have to fetch. you'd have to load the state, show loading states, do error handling, caching, updating the UI when the data changes, right? So, all of this stuff, but with Redux Toolkit, it does it uh with the re redux RTK query, it does it automatically. So, there's even more enhancement enhancements available to you in re uh Redux toolkit itself. And so, that's what we're going to be using in this video. Okay. Now, just to help you understand a little bit more, I'm going to spend maybe one more one or two more minutes just to explain the overall structure of Redux uh the RTK and RTK query. First, we need a slice. A slice is essentially a store. That's how or think about it as it's not a store. Sorry, it's like local data. Tiny little slice of your store. Okay, the word says it by itself. And so if you want to create a store, a tiny little slice of your store for the profile management, you would create a slice just like this. And you would give it a name. You would give it, you would also give it its initial state. So what does the initial state look like? And maybe you would give it some helpers to change this state. So to change the state itself to something else. We call those reducers. Okay? So reducers help you change the state that's already being stored inside the store. Now what's a store? The store is kind of like the main guy. It's the whole global stuff, right? So this slice will be stored inside that. So the slice we just created here, our slice will be stored as part of the store. And so if you have more data, right, more little slices, you can add that as much as you need into your store. That's how you create the store and create little slices of data. Now, how do you access this data? The way to access this data is inside your components. All you would have to do is call this hook use app selector or use selector. And I'll show you because we're going to create like a custom version of this because we need TypeScript and type IntelliSense, all that kind of stuff. But essentially, you would use this use app selector and you can access data. Now, now what if you want to change some data? What if you want to dispatch? That's the word we use a technical term. What if you want to dispatch some action to change the data that's inside the store or inside a slice? You would use the use dispatch hook. Okay. And then that's that's pretty much it, right? That's pretty much as to how to access the data and how to how to uh mutate the data. Now, there's one more thing that I was talking about which is the query itself. So, this is essentially that API endpoint that you can create so that Redux does the fetching for you. So in order to do this same thing you would create API. This is literally what you would call it. And inside that you would pass in the path right the reducer path. So where where would that go? And then you also have to pass the the URL. So what URL should it call? Okay. And then you'd set up the endpoints. So what endpoints does that URL have? Does it have a patch? Put pull whatever pull request. I said pull request. too much GitHub guys. So you you get it you get what I'm saying right? So all the mutation functions which are the endpoints itself will be inside that uh specific um create API okay and we'll go across every single thing here but I just wanted to help those who needed to understand this and now you do. Okay. So from now I'm not going to explain this anymore. So, come back to this video, save this video, and maybe if you think this might help you in the future so you can see more of these awesome videos on your feed, consider subscribing so that way it goes to your feed and you get to be the first person to watch it. How cool is that, right? Okay, let's proceed now to install Redux into our application. So, go ahead and open up your terminal and you want to say npm i react redux at 9.2.0. So this is the version I'm using. That way you can be on the same version as this application. Okay, go ahead and hit enter and let that install. Then the next package we're going to need is npmi at reduxjs/toolkit. And you're going to put at again right here. You're going to say 2.8.2 and go ahead and hit enter as well. Now go ahead and shrink your folder structure. Inside source, we're going to create another folder called Redux. And inside this, we're going to create APIs. So, we're going to say API like this. And then in here, I'm going to create another folder called slice like this. And inside this, we're going to need a store.typescript. And we also need a provider.typescript as well. So, go ahead and create all of these. Okay. Awesome. Now, first thing we need in here is our store. So I'm going to say export const store equal and we're going to need some way to create the store. So I'm going to create a function called make store and I'm going to invoke it for now. And this is the function that's going to help us initialize that store. So let's go up top here and I'm going to say export function like this make store. And this function is is going to do the following. So inside this I'm going to return something called configure store and this is what Redux essentially gives us. Okay. And now this configure store needs a reducer. And a reducer is essentially those little functions I was talking about. Right? So think about it as the little individual sections where we put the slices within. Okay. So in order to do this instead of putting them one by one right here what I'm going to do is I'm going to call this root reducer just like this and let's copy this let's go up top and I'm going to say con root reducer equal to another helper that we get from redux called combine reducers. So I'm going to bring this in here and then whatever we need to pass in to be a part of the reducer goes in here. Now obviously we need to import all of this. So what I'm going to do is I'm going to go up top. I'm going to say import XYZ whatever we need from Redux Toolkit. Now the next thing that goes inside our reducers are the slices. So in here I'm going to create an index.typescript file and inside this file I'm going to put all of my slices. So export const slices which is going to be record record uh record whatever uh string reducer and this type needs to change reducer and that reducer comes from redux toolkit and then inside this we can pass all all of our slices. So for now I'm just going to go back here and now we can import this slice just like this. And in here I'm going to pass in all my slices. Okay. So I named this slices. Let's just change this to slice like this. Okay. And that should fix that error. Awesome. Now at the time this store is being initiated, you can also pass in a preloaded state. Okay. So I'm going to call this partial like this. And this needs the root state. And this root state comes from another type above here. So let me go and bring that in as well. So right up here I'm going to say export type root state return type of the root reducer. And now let's bring in that root state in here. So we have type IntelliSense. Awesome. And now we have the reducer being passed in right here as well. So now where do we pass in the preloaded state? So in here you're going to put a comma here and you're essentially going to create a middleware. Now, inside this Redux toolkit, they give you the ability to create middleware functions before you store data, before you load something. So, the one that I need here is obviously to load this pre-loaded state. So, you go ahead and create a uh an arrow function like this. Sorry guys, my apologies. This needs to be inside this function right here. Okay. So, I'm going to say middleware, and this is going to be an arrow function. And this arrow function is going to return the following. So, this gives us access to get default middleware. So, I'm just going to call it get DM so it's easier to type. And then in here, we're going to say getd DM.concat. And we're going to pass in everything that's inside our APIs. Now, the APIs is another thing we need to get as well, and we'll grab that in just a second. So, let's go up here and create those APIs really quick. So, inside this API folder, you're going to create an index.typescript, TypeScript and you're going to say export const API and this is API sorry and this is going to be equal to an empty array. Okay, over time we're going to build our our APIs like billings API or project API and we're going to pass that into this. Now let's go in here and the first thing we need to do is now that we have set up these reducer slices remember I told you we also need those APIs. So, what I'm going to do is I'm going to say bring in APIs from here dot reduce them. And I'm going to grab these helpers real quick. And what I'm going to do here, guys, is I'm going to say instead of name reducer path like this. And this is equal to reducer. Okay, I'll get to the these errors in just a second, but I'm going to say reducer just like this. Now, it's going to throw these errors and these are just TypeScript errors because we haven't created those APIs yet. So, the reducer path does not exist. And so, it's going to throw these errors. Just keep pushing through. The first thing we need to do here is we're going to say reducers map object. So, we're going to reset this uh type cast this to a different uh value here, different type here. So, let's bring this in from our Redux toolkit as well. And then once that's done, you're going to see these errors. Don't worry about it. Let's just proceed from the from down here. Okay. So, inside this conc cat, you're going to say dot dot dot APIs like this do map. You're going to invoke it and you're going to create another another arrow function in here. And this arrow function gives us access to something in here. So, we're going to grab this which is each API. We're going to say API middleware as middleware. And this middleware comes from Redux Toolkit as well. So let's go ahead and import that one too. And let's provide that provide this in here. Now at the end right here also, why do I have these dots? All right, there we go. So at the end here, you want to put a comma for the next one. And you're going to pass in that pre-loaded state that we were talking about. Okay. And after that is done, there's also this other enhancer that you can add to your to your uh Redux toolkit, which is DevTools. So, this is a really nice feature as well when you're especially when you're in developing. That's out of the scope of this project. I don't think we're going to need it too much. Maybe I might use it here and then, but it's just a way for you to visualize your store and see the entire object through a Chrome extension. Okay. So, make sure you install this in order to see the entire state of your application. So, now let's go ahead and complete this error here as well. So, you want to open up your APIs folder. And the first thing we're going to create is a type here, uh, sorry, another folder here. So the folder that I'm going to create inside this API folder is called project. Okay, I'm just going to give you a quick demonstration of what that looks like. And so inside this first, I'm going to say export const project API. And this is equal to create API just like this. Forget all the stuff for now. I'm just going to remove all of this. And let's import this create API. So this comes from our toolkit query /react. So please import it the exact same way. And now in here first we're going to provide that reducer path. So I'm going to say reducer path is project API. So this is how we can create a path. And then we have to also pass in uh something called base query. Okay. Now the base query comes from this. So what I'm going to do here is I'm going to say base query is fetch base query just like this. And we're going to say the base URL is going to be API/ project. Okay, once this is done, the next thing to add is the tag types. And I'm going to call this project like this. And then I have to set the endpoints that I have available. Now the endpoints that I have right now is not this one. I'm just going to remove this. I'm going to create autosave project. Okay, autosave project, not projects. And this is essentially going to be uh this from here we're going to get this data right. So I'm going to do builder domutation and inside this mutation so make sure you invoke it and pass in an object and inside that first uh let me actually create some types here. So I'm going to say type like this and in here I'm going to say autosave autosave project response. Okay. And that's another type we need to create up here. So all I'm going to do is create an interface and I'm going to pass in success message and event ID. Okay. And then down here we're going to pass this. And the second one is going to be autosave project request. And for this one I'm going to have another interface just like this. And that's going to have the following properties. Okay. Cool. Awesome. So please make sure you pause the screen and type because we have a lot to do and I cannot type every single thing. Okay. So down here now we have to create that query. So the query here is going to be URL is nothing for now. We're going to have a method called patch and the body is going to have the data that we're going to get from here. Okay. And this data comes from this. So we're just grabbing it from this callback function and passing it down here. Now let's go back to our index.typescript. TypeScript inside the API and let's pass in this project API in here. That will automatically solve our reducer path error, TypeScript error. So you shouldn't see this anymore. And if you still see this, just please go back and follow through from start to finish so that way you can get this set up for yourself as well. Okay, awesome. Now the next thing I'm going to do is I'm going to go back into our provider and I'm going to create something here. So first thing I need is the app store type. So I'm going to say export type app uh sorry not this one app store which is going to return type of make store. Okay so now you have the type in here. Then next we want to get the app dispatch which is which is going to be app store at dispatch. So we're going to export that type as well. And finally we need the use selector. So this is how we uh send data right. So use selector helps us get data. So first I'm going to say export const use app selector like this and this is going to give us u the following type. So let's just quickly go ahead and pass this in. This comes from react redux. So typed use selector hook. We're going to pass in our root state and we need to import use selector from react redux as well. So let's bring that in too. And then finally we need the use dispatch. So this is how we do use dispatch. We set this equal to an arrow function that returns use dispatch with our apps dispatch. Okay, so now we have our reducer setup, our provider setup. Let's go ahead and use it now. Sorry, guys. Really quick uh fix here. I I meant this is supposed to be the store. So, looks like we put it into the wrong file. So, put it into the into the store.typescript. Sorry if I was confusing you there because we now have to build a provider so we can pass that data in, right? So, sorry about that. So what I'm going to do in here is I'm going to say ts RFC fce redux reducer. Okay, something like this. And now we're going to go ahead and return this provider. And also make sure you change this to tsx. So that solves your error there. And the first thing we're going to do is I'm going to get the store ref. So before I return, I'm going to say con store ref equal use ref. And we're going to import make store. and we're going to pass in our preloaded state. Now, our preload loaded state comes from the Redux reducers props. Okay, so uh the Redux provider. Sorry guys, this is not a reducer. I keep calling it reducer. Really sorry about this. This is the Redux provider. So, I'm going to just rename this to Redux provider. And then this is going to give us two props. So, let's go ahead and grab those. And the data structure of this is going to be children, right? So react.react node and preloaded state is going to be partial of the root state. So the way to type this out is first you want to say children. It's an object, right? And you're going to dstructure that. And that's how we're getting children and pre-loaded state from this prop. And then the data structure of that is going to be children react.react node. And let's import that from React and partial of root state. Okay, just like this. And it looks like I made some errors. Just give me a second. Okay, let's first change this to use client component like this. So that way we know that we're using uh this is the client component for us. And okay, so the root the root state here is not from Redux.js query. It's from our app from uh the type that we created inside of store inside of store. Okay, so I'm going to bring that in as well. And that should solve this issue for us. So let's go ahead and save this so we can tidy it up. And now we have to return the provider. Now the provider comes from React Redux. So let's go ahead and import that. And the store is going to be storef.curren. And we're going to pass in the children elements. Now let's go ahead and copy this. And you want to open up your folder structure. You want to go into layout, the root layout.tsx. And you're going to paste this Redux provider in here. And I'm going to import it. And then we're going to pass in some data into it. We'll pass in just a second. But then I also want the children components and the toaster component inside that as well. Okay. Now, we need to prefetch and preload the state of the profile in here. So the first thing I'm going to do is I'm going to scroll up top here into our root layout. I'm going to say const raw profile. raw profile like this equal await profile query. Okay, we're going to invoke this just like that. And this is going to need to become an async function just like that because we're using a wait in here. And now we have to normalize the profile data. So I'm going to say normalize profile and I'm going to import that from types uh / user. And then I'm going to say raw profile.json. And we're going to we're just going to pass these values into this. So let me just import this from types user as well. Okay, there we go. And now we have the profile data. So now we can preload this user state, the preload state, and we can preload it to that profile. So now all these components will have the user information by default. Okay, awesome stuff. So now let's go back into our navbar component and let's copy uh let's copy this line right here, which essentially helps us get that knee state. Okay. And this uses the use selector, the use app selector that we created. And that gives us state.profile. And this is what we populated just now so that all our reducers share this uh sorry, our Redux provider has this data so that all of the components can access them through the use selector hook. Okay. Awesome. The next thing I'm going to do is I'm going to scroll down here to link and I'm going to replace this with me. Okay. So, make sure you do that as well. And down here, I'm going to say project.name. This should be fine because we're getting the project data from here. Next, go ahead and scroll to the bottom here. We have to add the image. So, let's go ahead and say source equalme. And I think we can pass in an empty string if nothing exists. Okay. Now that we're putting this in here, first we're going to see an error once you refresh the browser. Now I want you to read this and try to guess what is going on. Why am I not seeing the user and why is it saying that user is not found in the pre-loaded state and that you're trying to pass it in in there into the store. So pause this video and try to guess. It shouldn't be too hard and I'm probably sure I'm sure you already guessed it a long time ago, but try to guess what happened here and why can I not pass this user into our store. Okay, welcome back. Hopefully you got the right answer. If not, no worries. This is the answer. So inside our root reducer, we're passing in our slices. Now the way Redux toolkit works under the hood with TypeScript is it tells you all this stuff. That means if you don't have a user, right? If you don't have a user, they throw an error. That means if your slices don't have a user slice or a profile slice, then you're not going to be able to store that value. So everything is is kind of condensed into the single source of truth. And now if you click into these slices, you'll notice that we never created a slice for the profile. We created the API, right, for for project, but we never created this slice. So let's go ahead and do that as well. So inside the slice folder, I'm going to create a profile folder and I'm going to create an index.typescript. And inside this file, we're going to have the create slice. And this essentially has the name, which is profile. And now that should be good hopefully. If not, we'll all right, there we go. So the user here has to be uh user set to null. So this is the state. So you need this. So you need to first create this. Obviously, we're not going to see this right now cuz we need to pass it in. But we're going to create the name as profile. We're going to pass in the initial state as user set to null. So this is what the state looks like. Okay. And this is the type for it. And then down here, the initial state goes in along with the reducer. So here we can set the profile and clear the profile. Okay. And so set profile is going to do the following. It's going to essentially get the state and the action that it needs to perform. And then it's going to uh essentially put state do user equal to action.p paypload. And for clearing the profile you can do this which is set the state do user to null. And then down here we're going to export this set profile and clear profile as slice actions. So if you ever wanted to set the profile when the user logged out, you would have to just call the set profile and set this. Okay, so remove it or clear it. Sorry, not set it. And uh that's how we can use actions. And let's also export this slice.red reducer as well. So now we need to go back into our store.typescript. And inside here we have the slices. So let's click into that. And then in here now we need to pass in that new slice that we just created. So since we're calling it uh profile or I mean profile essentially what we're going to need to do is say profile is equal to profile reducer. Okay. So I'm going to say get the profile like this and we're just going to pass it in directly in here. Okay. Awesome. And now the next thing we need to do is inside our layout file we're calling this user which is incorrect because the reducer that we have just created is profile right and you can tell by looking into the slices index of typescript this is what we this is the key essentially unexpected key. So where did we do that? Well we did that inside the layout file. So let's go ahead and remove this and set it to profile and that should set that for us. Great job. Now, for the bottom section inside our navbar, the first one we're going to need to complete is this section right here. And then we also have the autosave. Now, the autosave is a very complex feature in this app because we need to make sure that while the data is on the screen and the user is editing, the data saves and does not fail to save. This is the most important part in applications like this. Imagine if your your you know your users are designing something in Figma and all of a sudden because the save failed you lost all of that data. We do not want this right. So we will need to build this towards the end because it's a very crucial step in this application and uh so is the create project. So I think for now let's wrap up this section and I will see you in the next one. Next go ahead and open up your folder structure. Open up components and we're going to create another folder in here called buttons. And we're going to move this OOTH into this. And the reason is because we're going to create another button right here called the save create sorry create project button. And uh it just makes more sense to put all these components inside its own button folder. So next I'm going to create one called project like this with an index.tsx. And inside this, let's quickly go ahead and create the create button component. And now I'm going to go back in here into our navbar. And I'm going to bring this back. So just like this. Okay. Looks like it has some sort of states there. Sorry, some sort of uh comment. Let me pull that out. All right, there we go. So you want to have this right down below here. And now let's go ahead and import this create project component. Now it's going to say create project in here because nothing is inside this component. So let's go ahead and let's create the button. So I'm going to say create project equal to button which comes from components UI button. And then this is going to have an on click which essentially creates the project itself. And we're going to get all of this in a second but I want to give you a 10,000 foot overview first, right? And then we're going to have a loading state called is creating. And if it is creating then we're going to show the loader 2 component which is essentially a um it's an icon. And if not we'll just show the plus icon so they can create something and then we'll say create or new project. So the plus will just append on top of this. Okay. So now how do we get access to this use project creation hook. So essentially in here we're going to say const this is going to be equal to create project um sorry use project creation and we're going to dstructure the following values and we're going to provide those in here. Now obviously we need to create this hook and since this is a hook we have to change this to use client. And now the next thing I'm going to do is I'm going to copy this name and I'm going to open up my folder structure inside hooks and I'm going to create use- project.typescript. Okay. And inside this I'm going to say export const use project creation just like this. And now inside this first things first let's change this to use client. Okay. And then down here we can now proceed. So before I also complete this, I'll go back to my project component and import the com uh import the hook. Now this is a pattern you'll see me do often, which is create the thing in here, then go into the component, type in the basic structure, and then import. And so I want you to do that. Okay. So some of you mentioned last time that going back and forth was confusing. It's not that I'm going back and forth. It's just that I'm trying to resolve these errors as fast as possible for you so that you can see something render. Okay, that's what I'm trying to accomplish here. And so that's why I went ahead and just imported this as fast as possible. Okay, so go ahead and import that from this component as well. And now we'll proceed. Next, what are the things that it needs from here? The first thing it needs is this is creating state. Okay, and it also needs this can create function. So, in order to get that data, I'm going to need to store this somewhere, right? So, the first thing I need is we're going to bring in our store because we're going to need to store all that data in there and maybe access that as well. So, first thing I need is dispatch and this comes from use app dispatch from our store and let's invoke that really quick. Then the next one we need is a user data. So, I'm going to say use selector like this and we're going to grab state.profile information. Then, we're going to need the projects data. So I'm going to say projects like this. But obviously uh let's just make sure our project is also created. So inside the slice folder, you're going to create projects.index.typescript. And inside this, we're going to create that slice. Now before we move forward, I just want to say something. So if you haven't purchased the codebase from the description down below, I'd highly recommend doing it right now if you're going to do it anyway because you're going to need a lot of things to copy paste from there. Okay? And even if you don't want to grab the codebase, that's totally that's totally fine because I'm going to show you on the screen what that looks like. You just have to pause and type. Okay? But I'd highly recommend you grab the codebase so you can just follow through, copy paste with me and kind of build it together so you know how the codebase works over just figuring out how to write const and all these kind of weird syntax related stuff. Okay? So go ahead, click the link in the description and grab the codebase. Now, in the uh in the YouTube kit, some of the files or some of the boilerplate code that is not part of intellectual property or I just thought, hey, you know, it's it's a pain to get you to type everything, uh I would have put it as part of that. Okay? So, you can just click on it and download it completely for free. So, even if you just want to watch this video just to learn how to code, um I have put all the assets for free in the description down below. Some of them that I'm using and you can just click on them and download it. Okay. So, first thing I'm going to do in here is we need to create that project slice. So, I'm going to say const project slice equal create slice just like this. Next, let's go up top and I'm going to import create slice right here. And now I can populate this. So, the first thing I need is the projects and the initial state. And now the initial state is going to be another variable up top here that's going to look like this. Projects total is loading. error last fetched is creating and create error. Please please pause and type this along with me. Okay. Then the other thing I'm going to put in here is the project state itself. So this is another type, right? So the initial state uses this state. So what does that state look like? Well, this is what the state looks like and these are the default values of those states. Now there's another one called project summary. So for this it's essentially an array with the following. So ID, name, project number, the thumbnail, last modified, it's just basic information and that goes into each of these projects. Okay. So now down here we have now that we have passed this in the next one is a reducers. So for the reducer, the first one I'm going to need is fetch project start. Okay. So you can grab the is loading and error states from here this way. The next one I'm going to need is fetch project success. So this is going to say the following. It's going to take the state and the action and it's just going to return this data. So you see how helpful these uh these helper functions are or reducers essentially. You can get some state and you can also mutate some state as well directly from here. Right? So the next thing I need is another fetch to get the project failure. Okay? So I'm going to say fetch projects fail failure and I'm going to pass in this data right here. Then now we need to create the actions for the create project actions. Okay, that goes down in here. So the first one is create project start and the next one is create project success. So I'm going to say create project start gives us the following true right here. And then create project success is going to give us the following right here. Okay, so state is creating and state dot this is actually incorrect. So down here I'm going to say error set to null. Okay, the next one uh and for this guys for this we don't really need the action. So we can just remove it from here. The next one is create project failure. So this is going to need the action because we're we're going to need to pass in the uh create project failure action uh payload inside this. So we can store that there. So I'm going to pass that in there as well. Now for the next one, I'm going to say add project. So add project. And this is going to be another action just like this. A function just like this. And inside this function first, I'm going to need the state and the action. So I'm going to grab that really quick. And then inside this I'm going to say state.ro projects dot unshift and if you don't know what this is you might need to learn a little bit more JavaScript okay it's kind of I think it's like push right u it basically adds uh it adds to the beginning right so this one adds to the beginning of the list which is which becomes the most recent one first that's what it's doing okay you can also add it right at the top but this is just another function to do it to help you do that then I'm going to say state.total total plus+ you can do plus equal 1 this is fine too and then u what seems to be the issue here okay and then after this add project the next one is update project so I'm going to say update project and this is going to be a function that looks like this but first we need the state and then we need the action payload so let's grab those two as well make sure you put the same type and please pause and type with me okay and then the next one is in here we're going to say const index. So, we're going to find the index of the project where the project ID is equal to the action.payload ID. And then if we don't find it, well, then we're just going to say state.pro at that index is equal to state everything that's in state.pro.index and we're going to put everything that's inside action.payload. Okay, awesome. Then to remove a project for that I'm going to create one right here that helps us filter the array for that project ID. Next to clear all projects I'm going to say the following right here. And then to clear all errors I'm going to say this right here. Clear errors state error and and create uh state.create error set it to null. Now we need to export all of these actions and the reducer just like how we did for the profile. So I'm going to say fetch project start just pass in all of these from the actions and I'm going to say project slice.red reducer. So now let's go back to our use projects.typescript and at the bottom what I'm going to do is I'm going to return an object like this and let's remove this actually. And inside this first I'm going to pass in a function called create project. But before that let me first do is creating. So is creating is going to be the project state that we got from here dot is creating. Okay. Then the project itself is going to be like this. So projects equal project state dot projects. Then we need the project total which is also inside the same state. And then we need can create which is the opposite if we don't have any user ID and that we're also getting from the app selector up here. But we now need the create projects hook. So what seems to be the issue here cannot read is creating. All right. So the reason why that was happening is project state was not created. Right? And so um the reason is because inside our so you don't have to pass this in here but inside our index file we need to pass in the projects that we just created. And so once you pass that in that should solve that error. Okay. So now in here the next thing we need to do is we also have to create that create project function because we have to return it from here. So now that we have solved these bugs, let's go ahead and say cons create project equal to a function like this. And this is going to be an async function. And inside here, essentially what we're going to do first is we're going to check if there's no user ID, then throw a toast. And let's import toast from sonar so we can show that. And then we need the create project start, which comes from our reducers that we created in here. So let's bring that in as well. And so now we're going to dispatch saying create project. And so the first thing here is we're going to create a try catch block. So try catch like this. And the first thing is we need to generate a thumbnail. So this is going to use a helper function that I created. So let's go ahead and grab that. So on top of this file, I'm also going to put this inside the YouTube kit from the description down below. So you guys can also download this for free uh this generate gradient thumbnail uh function because it's just a bunch of stuff that I do not want you to just sit and type. Okay, so it just has some uh sort of design, some gradients that it just creates and we'll see what that looks like in a second. Okay, so we're just going to create this and we're going to pass that into the generate thumbnail function. So once that's done, we're going to create the project directly inside convex. Okay, so let's go ahead and do that as well. So after this I'm going to say const result equal await fetch mutation which I'm going to import and uh the fetch mutation comes from convex / nex.js. So let's bring that in. And then we need this API. Okay, this API comes from the convex generated API. So I'm going to say convex generated API like this. And that should solve that issue. Then we have to get the create project. Okay. Okay, so it's throwing an error here. That's because we don't have this created already. So you have to create that function. So let's go ahead and do that. So open up convex and you're going to search for project right in here and you're going to create a mutation. So so far we have created a query. Now we're going to create the create project mutation. So down in here I'm going to say export const create project like this equal to a mutation and I'm going to import mutation from generated server. We're going to invoke this. And the first thing we need to pass in is these arguments. Okay. And I see it's throwing errors. And even this page might throw an error. So, okay, it's not throwing an error. Awesome. So, first we're going to pass in the arguments, which is the following. And this V essentially comes from convex values. So, let's go ahead and import convex values as well. Awesome. And now, okay, it looks like we already have it. So, we don't have to do that once more. And then after you do the arguments, now we have to create the handler. So I'm going to say handler is equal to an arrow function like this. And this arrow function is going to do the following. So first I'm just going to console a message so I can just look at it, you know, in the back and make sure everything is working fine. Then I'm going to create a new project number for basically to autoname the project. Okay. So I'm going to say const project number equal get project number and this is going to be an async function. So I'm just going to scroll to the bottom and I'm going to say project number like this. Get next project number is going to be is going to have the following data in here. So please pause and type with me. And in here all I'm going to do is first create the project number the project counter for this user. So I'm going to see project counters with the index. So I'm going to search for that user and get dot first. If there's no counter, then we're going to insert into this database. So insert into project counters and we're going to pass in the user ID and we're going to set the next one to be two where we're going to return one in here. Okay. Then down here we're going to say project number is counter.extro number and we're going to increment the counter for the next time. So I'm going to say await db.atch. We're going to pass in the counter ID and we're going to say next project number is project plus uh number plus one. Okay, this is just some technical stuff. You might even not need this, but uh this is just what we thought made more sense at that moment. So, you can just go ahead and do this with me and then it's all going to make sense towards the end. Okay. Now, now that we have the number, we're supposed to create the project name. So, I'm going to say project name is name or project project number just like this. Now, the next thing is let's go ahead and insert into the database. So what I'm going to do here is get the convex DB and I'm going to say project ID. So I'm going to get this as well is await ctx.db.insert and that comes from here. Okay. And that is the generic mutation ctx. I don't even know what what this means really. It's just part of syntax. So I'm just following syntax online. Okay. So we're going to say projects and then in here we're going to pass in all the data that it needs. And then after that we're going to return this data as well. So down here I'm going to say return project project name and obviously you can also print a message here if you like. So project created. Okay, nice. And I see an error here. That's because of any. So that should be okay. All right. Awesome. Now if you go back to your use projects hook, this should no longer throw that error because this function exists. If you click on this, it's going to take you to this mutation. Okay, nice. Now it's asking to also import these types. So let's go ahead and grab ID from data model. So I'm going to scroll up top and I'm going to bring in sorry not this one guys. So I've just brought in the ID. So that fulfills that one. And then now we need the name here. So this name is going to come from this create function. So I'm going to say name which is going to be string. And the next thing we need is we're going to pass in the sketch data. Now, this is essentially all the shapes, the tools, the frames, all that stuff that is going to be on the uh on the project, okay? It's kind of like default data that we need to create. So, don't worry too much about this. And I'll also give this to you for free inside the description, okay? When you get uh when you just grab the um the YouTube kit. So, you'll find the shapes inside that. So, let's go ahead and create that uh new slice now. So, first let's get the state. So shape state U selector which is state.shapes. And now let's go ahead and open up the folders for it. So inside your slice folder, you're going to create another folder in here. And you're going to call this shapes just like this. And inside that an index.typescript. And please scroll to the description and just grab this uh thing. You're going to get it inside the YouTube kit for free. Uh I mean obviously if you bought the codebase, you're good to go, right? But if you choose not to build a codebase uh watching I mean if you choose not to get it and you just want to build it then you can follow through with this. Now obviously I do not expect you to type all of this but this is basically just some helper functions and some shape related data. So for text here's what we need right for generated UI here's what we need. So just types for a line shape for an arrow shape free shape all of these things are just shapes inside the app. Okay. And so I created some types and we did all of this uh for you so that you don't have to do it. So I highly recommend buying the codebase. Saves you some time and you get all of this with no bugs, all that kind of stuff. Right now before I don't want to I don't want to just skip this part. Right? So I'm just going to go down here and just show you what the create slice looks like. So it's shapes initial state and the initial state is going to be the following right here. Okay? So, you're going to have the tool, the shapes, selected frame counter. Okay. And uh for the shape adapter, we're going to have uh a couple things in here as well. So, this is going to use this function here that essentially creates this entity adapter. Okay? You don't have to worry about all this stuff. Just do what whatever you see inside the inside the YouTube kit. Just copy paste it. Okay? So, that's essentially what this is. the initial state and the reducers are just set tool, add a frame, add uh you know add a rectangle, add ellipse tool, that kind of stuff. Okay, so just some helpers and uh it uses the shape adapter and it passes in those uh values. Okay, so for example, if we wanted to add add one of something, then we can add one of the specific shape. Okay, so make arrow, make free, make uh free draw, make text, that kind of stuff. And uh this is also another function that we created up here that returns like an object here. Okay, so this gets added to that store. That's essentially what's happening here. And then towards the end we have more like delete, clear, select, and then we have load project. And then we're we're obviously loading the project with all of the stuff. And we're returning all of this through this reducer. So now let's go back in here and let's pass in our shapes. And let's import the shapes as well. And this is our slices index.typescript. And now we have that part sorted out. Now this next part which is the viewport is another state. It's another another slice in here. But I just want to point this out that um big shout out to the team. This took us a lot of time to figure out because what most people do online is they just use a third-party package for something that's, you know, something that's a very big feature. For example, a canvas board, right? These are very complicated features because you you have the zoom out logic, zoom in logic, all that kind of fun stuff, right? And so creating all of this takes a very long time. And just to give you a heads up, this is this is a canvas you can use for anything you like. You can use it for an for a website builder. You can use it for a Figma clone, whatever. If you if you like to clone applications, uh you can use it for an automation u you know, free flowing canvas. This took us forever. So, uh I'd really appreciate it if you did if you did subscribe, okay? That way you can get more free value just like this. The whole reason why we're creating this type of content is so that you get it. And obviously, I'm not going to charge you for this. You can just go in here into the YouTube kit in the description and you will find this viewport um the viewport reducer in here. Okay? So, you can see how we're we're adding things. We're doing the wheel zoom. We're doing wheel panning. We're doing pan left, pan start, pan move, all this kind of stuff. And you can learn from that. Okay? So, what I'm going to do is I'm going to say viewport and I'm going to say index.typescript. And in here, obviously, I'm going to paste it. You're also going to get it. So, you can scroll to the description and grab that from the YouTube kit. Okay. And just to show you what this does right here. Same thing. We have a bunch of reducers like set translate. So, if we're creating a shape on the page, how do we position that on a specific XYaxis? Axis axis. I don't even know how to say it. Okay. And then, um, how do you scale? So when the user is zooming and when they start zooming, so the wheel zoom and if they try to pan, so if they're trying to click and move, all of that stuff is set right here. Okay? So please please take some time and read through this if you'd like to understand, you know, more about the code. Uh but I'm I'm happy that I'm able to just give this out to you cuz we spent a lot of time. So I'm happy you guys are getting this. You're so lucky. Okay. And we're going to need this viewport for one of the tools which is for creating a point. So the way the uh the drawing tool works is that we use this point. Okay, it's a free draw tool. So we're going to use this point and that's why we needed to import that. So let's go ahead and let's quickly import this. Okay, there we go. And that should solve that error for us. Great job. Now don't forget we have to go into our index slice and we have to import the viewport as well. Okay. And now if you go back to your use project hook, that should solve all of your bugs that you were facing in here. Okay. So now after this section right here, after we have created the fet fetch mutation, we have to take this result and we have to pass it into our dispatch. So I'm going to say dispatch and this is not this one. It is add project and this one comes from the slice project. So make sure you import that. Okay, just like this. And inside this, we're going to pass in an object. And this object is going to need the following properties. So I'm going to pass these in. And I'm just going to pull out the values that came from result and assign them. So project ID, name, number, the thumbnail that we just generated, and everything else goes directly in here. So our local state is also updated instantly. Okay. Next thing we need is dispatch create project success. So it saves the success states. All right. Awesome. And then finally, I'm going to use a toast. I'm going to say success right here. Typically in a production application, we don't use toasts. Um we use I mean sometimes we do, sometimes we don't. But this is mainly for you. Okay. The user should know everything is successful. Only if there's an error, we show a toast. Okay. So when something is successful, we always don't show a toast. But for you as a developer or as a SAS, you know, you're building your own SAS, you want to know what's happening. You can use this to debug. Now, inside the error, I'm going to return the create project failure, which is in here. Remember, we created that, right? So, let's create this. And I'm just going to pass in fail to create project. And I'm going to show a toast for that one as well. And now, the final thing that we need is create project. So, let's go ahead and pass that in as well. Now, if you go back to your projects index.tsx, which is in here. So, components project index.tsx, that should solve this bug for you. So, if you click on this, it should create a project. Let's see. Well, let's give it a shot, right? Okay. Moment of truth. Let's click on create. It showed a quick loading spinner and it instantly said project created. So, in our database, we should have that. And we can also see the description uh see the console messages and you should probably have it. Okay, let's give this a I mean let's try to render out the projects and then we'll see if it's there. If it's not there, we'll figure out how to fix that bug. Okay, so instead of just you know hoping for the best, I went ahead and took a look at the projects table inside the database. And as you can see, a new project has been entered. It's called project one, and it has all of the sketch data that we need and uh including everything else. So awesome. Our create project was successful. Great job so far. So now that we're done with the create button, let's move on to the next section. Now the next most important step in building your SAS is to keep track of the version history of your app. Now this is important if you need to revert back to a work to a working version because of a breaking change that someone made in the future, right? And so always always do this no matter what, especially if you guys are using AI. Okay? There's a lot of y'all using AI and just pushing to main without knowing what's going on. And most of the time there are bugs, okay? AI can't know everything about your app. And so there are going to be bugs. And so you need to catch all of this. Okay? And one of the ways to do that first is to I mean the the first I guess first line of defense is to create different branches. Now because we haven't created this repository already and pushed our initial uh setup, it's okay to push domain because that's where we're going to start from, right? because so far we have only done setup so nothing to worry about but from the next feature onwards we're going to focus on keeping track of all this stuff. Okay, so go ahead and copy the first command once you create a repository inside your GitHub. It's going to give you all the stuff, right? So, copy each line, paste it into your terminal, and hit enter. So, one by one, you want to do that. Okay, so go ahead, pause this video, do this, and then come back. Okay, welcome back. Awesome. Hopefully, you did all of that stuff and now your main branch is up and running. And inside this icon right here, you should find all of your changes. Okay. Now, I personally don't like to use this right here. Uh sometimes it just doesn't make too I mean it's overly complicated cuz u you now have to learn this UI and all that stuff. So, what I like to do is just use a terminal. So, I like to do git add get commit. So, get add will add all of your changes. Get commit will commit your changes. And I'm just going to say init branch or main. You want to do get push. And now this is going to push to your main branch. Okay. So if you go back into your main branch, just refresh, you should see your codebase in here now. Now we can move on to the next stages, which is to essentially create a new branch and a branch out of that and proceed forward in our code. So now we're going to be working on our dashboard page. And so the first thing I suggest you do is create another branch. So, inside your terminal, you want to say get checkout-b in double quotes, you want to put kebabs case, I think that's what it's called. Uh, dashboard section or dash dashboard feature. Now, I'm not following any kind of crazy uh, you know, industry grade naming practice. It does not matter. You're not in a big company. You're probably building this by yourself or with a very small team. So, it's okay. But go ahead and create this new branch. And down here, if everything is successful, it should send you into this new branch here. Okay. So that's how to create a new branch using GitHub. Now just to show you how to create a PR, we're essentially go down. We're going to go down here into line 25 and I'm just going to add something. Okay, so I'm just going to say add credits logic like this. You don't have to do this as well. And now if you go into your file in here, you should see the change created. And now since we're on a different branch, I'm going to show you how to do this. So you want to do get add. Now this is how I do it. A lot of you guys have different ways of doing it. This is my favorite way because it's very I don't have to remember too much, right? I like that. So, get add and then you want to do get check uh get commit changed the navbar. Okay. And then you're going to run get push, but that's going to give you another error. That's because you don't have an upstream setup for this branch. And I like doing it this way because it gives me the command so I can just copy and hit enter. Okay, so make sure you create the upstream and then you do get push. And that should push this uh this branch essentially. I think you don't even need to do it. I think this is going to do it for you. Now go to your GitHub again. And then you want to go into the new new pull request. So you're going to see it. Um it's not a pull request. It's essentially new changes pushed to this branch right from your codebase. It's going to show you this. Click on compare and pull uh create pull request and then click on create pull request. And the second you have done uh the second you complete that, it's going to show you this message here and it's going to say merge pull request. Now, here's another really cool feature that I have inside my GitHub. This awesome AI code reviewer is called Code Rabbit, which you can also get for free if you use the link in the description down below. So, go ahead and click on that and install Code Rabbit into your GitHub. Now, I've already done it. I'm just going to quickly show you what Code Rabbit did for us and how it helps us in our development cycle. So the first thing is Code Rabbit creates a summary of your pull request. Now this is good if you have somebody else who needs to review it on behalf of you. Well, technically you don't need anyone now, right? You don't need a code reviewer cuz rabbit does everything for you. So I work in small teams, right? And so my developers would like to know what's if they would like to know what's inside my pull request. They need to contact me and I need to walk them through every single thing. Now with the help of this tool right here, it doesn't look, you know, like it did its best because we only just pushed a tiny little to-do commit. But in the future, um, imagine if you create a pull request with 50 files that were touched, right? Code Rabbit will will essentially summarize all of that into a 10,000 foot overview and break down the architecture of what's going on inside that specific pull request. This is huge because your team does not need to contact you anymore. So, this is directly going to save me a ton of time. So, go ahead and set it up. You can click the link in the description. It's completely free to use for 14 days. Set it up and then you can you can test it for yourself. Right now, the other cool part is Code Rabbit will also create a flow diagram. Okay. Right now, we don't need a flow diagram because it's not needed in this case. But when we have multiple components communicating, when we build when we build our Redux slices and when we integrate all of that into this with convex, it's going to show us the flow of our code through every single component and file. And it's going to show that uh directly to us in an image right here. And I will show you in the future pull requests um and just kind of walk you through that as well. Okay. Now, here's what I love about Code Rabbit. Code rabbit actually caught a few of our bugs that that we were going to face if we just push this to production. And this is why I highly recommend you do not push directly to main. Okay, use Code Rabbit and let Code Rabbit do the AI reviewer stuff and then it's going to tell you if there is a bug. At the least, it's at least going to warn you about a bug around that same area. And so that's exactly what happened here. So inside our code, we had dashboard slash without theme.name. And as a result, if you clicked on this link, that would throw an error. Now, I missed this and you might have missed it as well. And so, if you did, obviously, you know, code rabbit would have caught that error if you created a pull request. Now, one really nice feature here is even though this was outside of the diff, right? This wasn't part of our files that were changed in the sense we did not change this line of code, it still caught this bug. And it also caught another bug that I missed and I had to change it as well and I'm going to show you in just a second. So you might have seen this as well. So inside your O page in your sign-in route, this button right here was before this. It had this address. Okay, it had this directory and my code wasn't updated. My my TypeScript files weren't updated. And sometimes this happens. You need to essentially shut down and restart, right? Or you just need to refresh the section. but I couldn't catch it here. And so if you open up this page, that would throw an error. So I saw that in code rabbit and I was like, "Oh, it actually caught a real bug that I could have potentially faced." I mean, it caught two real bugs right now. So I went into the codebase and I changed it. So this is all you have to do, guys. So go into buttons, go into Google right here, and uh make sure you update the UI button folder from here. And the other thing you want to do is inside your sign-in route, you also want to update the location of the Google button itself because we moved this into the button folder. Okay, so go ahead, use the link in the description. This uh code rabbit is going to be really promising to uh essentially, you know, give you some valuable feedback inside in in your uh pull request. And you don't have to do anything. It's free to use right now. So, click the link in the description so you can grab that free account. And inside your Visual Studio Code, go to in go to the extensions tab and you want to install the code rabbit plug-in because I'm going to show you how you can also use code rabbit to do the changes directly in here. Okay? So, you can review the changes inside your codebase. And yes, we'll look at that um in one of the the later lessons, not in this this specific module, but you can install this and keep it ready so that when we have to do that um you're already good to go. So go back to your pull request, scroll all the way to the bottom right here. You're going to see a button called merge. So make sure you fix the changes if you miss something or if it caught a bug, fix those changes and then click on merge and that should merge to main. So this is the process that you should follow to keep a version history of your SAS application. All right, awesome. Now let's proceed forward into the dashboard page. And with that being said, the sponsor of today's video is Code Rabbit. So thank you so much to Code Rabbit for sponsoring this video and making it possible for you to watch this course completely for free. So don't forget to use the link in the description so you can start your free account. And one more thing that I want to point out is this feature, this plugin right here, if you download it into your IDE, it is absolutely free. You get this for as long as you want for free, right? So, I really believe that Code Rabbit has done a an awesome job here and we need to support them. So, please use the link in the description. Um, and that way you can create your free account. So, go ahead and open up this tab right here, and it should have the same icon in most of your IDE, and make sure you don't have any files in here. If you have a file in here, just take a look at it. Now, I know that it's this change, so I'm just going to undo this change. And you can also discard it from here. And then I'm going to open up the terminal, and I'm going to say get checkout-b checkout main. And then I'm going to do get pull to get all of my changes from my main branch. And you can see this right here as well. And now what I'm going to do is I'm just going to update this. So this has to be add components. So let's go ahead and change that. And I'm also going to do the same inside the oath page for the button and inside the navbar. Okay. So if you pushed your change into your branch, you're good to go. But I did not. I was just waiting right here to essentially show you how you can do it if you if you chose to skip the PR uh section. And so all you have to do is do it directly from here. I do not recommend this. Please do not do this. Okay. always create a PR, but I'm just going to go ahead and do it right now because I know what I'm doing. So, just give me a second. Okay, so all you have to do is get add. So, add all of your changes. Get add space period. Get commit. Just put a message and then get push. Okay. And you don't have to get pull anymore, but just to show you that everything is up to date. I just showed it uh did it right here. And if you are using code rabbit, it's going to show a little popup, right? And that's how you can trigger those uh reviews inside the IDE itself. And I'm going to show you more in the next PR. Okay. So now let's go ahead and say get checkout. And all I said was get checkout-b double quotes dashboard, but this time I just put feed right next to this like feature. And then hit enter. It's going to take you into that branch. Now go ahead and open up your folder structure and we're going to click on source approtected dashboard page.tsx. And just make sure. Okay, we're also doing this redirect thing here. So, what I'm going to do is I'm just going to shrink this. Okay. So, I'm actually uh this is fine. Let's just keep this like this. Go into session and go into page.tsx. And now in this page, first thing we're going to do is we're going to need to get two uh different points of data. So, we need the project info, all of the projects cuz we have to load all the projects and we need the profile information. So, things are going to speed up from here. Please, please pay close attention. I'm going to try my best to show you every single thing. uh make sure you grab the code base so you can follow through without any errors or just continue to watch, pause and type. All right, I'm showing you every single thing on this page as well. So the first thing we're going to need is we're going to create this new query. So first I'm going to change this to async so I can invoke that. And now let's go ahead and create that query. So we've already done this inside our convex folder. So go into query convex right in here. And inside this we're going to say export const project query is going to be an async function. So I'm just going to change this to async like this. And inside this I'm going to remove whatever it has in here. So first let's called uh let's call the profile query. So I'm going to say raw profile equal await profile query what we already created above. And then we need to get the profile info. So we need to normalize the data. So I'm going to say normalize profile and we're going to pass in this the following right here. And then after that we're going to check if there is no profile ID. So no profile id then return no projects. Okay and return no file. Next down here if that fails I mean if that's good to go we're going to say projects equal await preload query and we're going to put this new uh function in here called get user projects. Okay. And essentially down here we're al we also need to pass in uh I think this is the uh the search index right? So we're going to search by the user's ID. Okay. And we have to also pass in this token. So let's go ahead and create this query as well. So in your folder structure, go up to convex and you have to uh click on the projects.typescript and then scroll all the way to the bottom and in here you're going to say export const an arrow function like this. Okay, not an arrow function query like this. And for the arguments, we're actually going to change this stuff. So let's just change it right now. So for arguments, we're going to say user ID vid users and the limit as well. And then we're going to need a handler. So for the handler, I'm going to create an async arrow function that gives us access to all of this data. So let's capture that in here. First, we're going to get all of the projects. So from here, we're going to say all projects db.query for projects within with this index. And we're going to order by descending. Okay. And then after that, we're going to limit it. So I'm just going to pass this in here. So limit to 20 just like this. And then I'm going to return this data back. So I'm going to say return like this and we're going to return the following data. So when you call this endpoint or when you call this function, you're going to get this data back. So I see an error here. Okay, that's just uh the any type. So we're good to go. So let's go back real quick. And now that should solve this error and your convex is going to automatically update. Okay, so once this is done after preloading this query, we have to return the project data and the profile data. So let's go ahead and do that. And now inside this page.tsx I'm going to quickly import this project query in here. Okay. Now first if there's no profile information we're going to show like an authentication required page. You can page you can also redirect the user. I'm just going to show this in here. Okay. So authentication required something like this. But obviously we have the profile. Uh and the other thing you want to do down here is you're going to essentially render out a project list component. Now I'm going to show you another cool pattern that you can use in your codebase. So remember how I said you can use the React context API to create little pockets of data, right? So you can do that too and that that means that none of the main components are going to get access to that, right? But um in this in this specific scenario, we want to push a state and we want to push a state upward into the global provider. And the other thing is we want to have the initial data pass in from the server. So how do we do this process? So I'm going to show you uh how we can do that in here. So the first thing is I'm going to create a provider. Okay. So since this is projects, I'm going to shrink everything. Go into source components and I'm going to say projects like this. We're going to create a list in here. And I'm going to create a provider.tsx. Okay. And I'm just going to quickly return projects provider just like this. Now this is going to get two props. The children and the initial projects. So you can use this to set that data. Okay, I just wanted to show you how to do that. So before we complete this provider, let's go back and let's render this provider in here. So what I'm going to do is I'm going to say provider like this. Okay, projects provider. And let's quickly import this component. And let's go back into this component again. And now in here, we're going to need to dstructure those props. So I'm going to grab those. And inside this, the first thing I'm going to do is I'm going to get our dispatch function. So we can push the state up to the store. Okay. So I'm going to say use app dispatch just like this. And inside the return uh actually in before this, we're going to create a use effect. And the use effect is going to help us do this. Okay. So I'm going to say use effect like this. And then we're going to say initial projects.val JSON. If this exists, then we're going to get the project data. We're going to dispatch an action and we're going to pass in the fetch projects success. Okay, so we're going to pass this in and we're going to pass the project data along with the total length. Then down here, we need to return the children item, right? Cuz this is a provider. So let's go ahead and return the children items from here. Now, uh that's pretty much it. So let's go back. And now let's import this. But we also have to pass in the children items in here. So the children items are going to be a div in here and it's going to be this special component that we have to create called the project list component. So go ahead and open up your folder structure. Go back to the same projects folder inside components. And in here I'm going to create an index.tsx file and let's return a fragment real quick. Uh this is not a fragment, sorry. This is a u a snippet. Okay. And inside this, we're going to remove all props. And the first thing we're going to do is we're going to change this to a client component just like this. And I see an issue here. It's because uh this is supposed to be a client component as well. So let's go back to that provider and up top let's change this to use client and let's refresh the browser. Okay. And it needs that component. So now let's go back to our project list component and let's import that component. All right. I hope you're doing this with me. And if you're getting lost, just play it on maybe the slower speed. But I would suggest just watch a big section together, then stop and try it on your own. That's the best way to do this. Okay, so let's go back into the project list. And the first thing we need to do is down here. We're going to need to remove this stuff. Okay, so remove project list. And in here, I'm going to create class name. And I'm going to say space y of four of eight actually. Okay. And then inside this, I'm going to have a div. And this div is going to have the following class name. And then inside this div, we're going to have an H1 tag called your projects. And then a paragraph tag right here. And it looks like I forgot to add some padding here. So I'm just going to add this in here. Okay. So just put padding x4. And let's go back into this list component. Now after the title, we're going to need to loop over all of the projects that we're going to get. and we have to uh check if its length is equal to zero or not. And if not, we're going to render out all of their projects. So up here, the first thing we're going to do is we're going to import one of our hooks that we created. So let's go up top and I'm going to say use project creation and we're going to get the projects and can create. Okay. And then down here, first of all, if the user cannot create a project, I'm just going to say, "Please sign in to view your projects." Okay, obviously you might want to redirect, but I'm just showing you what that looks like. And then down in here, now that we're rendering all the stuff, let's go ahead and render out our projects. So, after this div, guys, right here, so we have one div here, one div here. Hit enter. And then in here, we're going to do the following. So, first you're going to create a curly bracket. And inside that you're going to say projects.length equal to zero. The reason why we're doing this is we want to check if we have anything. If we have anything we will essentially render something down here. But if we don't have something then we're going to say no projects. Okay. So that's how we're going to render this section here. So to give you an example right now it's going to say asd. Okay. Because remember we already created a project when the user logged in. That's what this this magical hook does from the navbar. Okay. So, what we're going to do now is for this section, I'm going to remove this and I'm going to create another div in here. And I'm going to give it the following class names. But in here now, I'm going to map over all of the projects and I'm going to render out this right here. So, go ahead and grab the project info from here. We're going to create a link element from next link. And let's render this out. And in this we're going to give it the key prop. Okay. And for the href we're going to say dashboard/user. And this user is going to need to come from up above. So we have to grab that user as well. So let's go up top here and we're going to say const user equal app selector. Let's import that as well. And down here now we can render out user's name/canvas project ID. So if you click on this project card it's going to essentially take you into the canvas. Okay. And then inside this link component, I'm actually I'm also going to give it some class names. So I'm going to say class name group cursor pointer. And then next we're going to have a div here. And this div is going to have space y of three. We're going to have a div inside that. And that div is going to have aspect uh 4x3. Please just pause and type all of this. I don't want to read over it. And then in here we're going to check if the user has a thumbnail for this uh for this project. And if that does exist, we're going to return a image like this. From next image, we're going to show that gradient stuff, right? We're going to have an alt and we also need to have a class name. So the class name that I'm going to add is as follows. Okay, so please go ahead and put this class name as well. It's great. It looks super nice. I love it. And then uh down here, we're going to have another div. Now this div is going to have the following class names as well. And it's going to have a plus inside that. Okay. Next, after this div, we're going to create another div. And this is going to have space of Y. And then we're going to create an H3 in here. And this H3 is going to have the project's name. So the project title essentially. And then after that, after the H3, we're going to have a paragraph with the following class name as well. And inside this, we're going to say format distance to now. And this is using uh a package called date. I think it's date. Let me let me import this in a second. Okay, I'll just import it right now. It's called date FNS. There we go. Date-f FNS. Okay, it comes with SHTN, so you don't really have to do anything. And then in here, I'm going to say add suffix. We're going to say true. And we're going to close this. Okay. And so now you have these beautiful gradient cards that show your project. Awesome. So now, let me show you this awesome functionality that we just created in the application. If you click on new project, notice how fast it is. Boom. instantly, right? So, the user feels like there's no feedback. There's no loading feedback. It feels instantaneous. So, I think I've done this in all my projects. It's called um optim optimistic UI, right? If you don't know what that is, just look it up. It's a really fancy term for being optimistic about the outputs of your actions and then showing the expected output before the error takes place. So, just show the output first and then if an error takes place, kind of like undo all that stuff. You'll probably need to do all that, but I'm just showing you um how this stuff works. So, one more update I want to make to our folder structure is we have this session right here. I want to create a layout or a route group to to kind of like uh share the layout between all of these elements. So, what I'm going to do is I'm going to inside this I'm going to create another folder. Going to call this workspace like this. And then um inside this I'm going to copy this stuff. So, first copy your page.tsx. tsx. Oops, sorry about that. Or you you don't even need to copy it. Just grab the page, put it inside the workspace, and do the same for the layout. Okay? And it should ask you if it needs to update imports, all that kind of stuff. Go ahead and change those if you need to. Now, inside this workspace folder or route group, the first thing we're going to create is a uh is the style guide. Style-guide, just like this. And inside that, we're going to create a page.tsx. And we're also going to have another layout.tsx. Now, let's go ahead and return these components here so it doesn't throw an error. Okay, just like that. Awesome. And then the other page you need to create is the canvas page. So, I'm going to say canvas like this. And inside that, we need a page.tsx as well. And we're also going to create another layout.tsx. And just quickly go ahead and return a uh React snippet in here so it doesn't scream at you. There we go. This is a layout. Awesome. And now inside this component, so right now I'm inside the project canvas. And that's probably what would have happened if you clicked on any one of those cards, right? So let's go back real quick and see if we can see that. Okay. So, if I click on a card, it's going to take me into canvas. Let's click on style guide. And now, let's shrink this page. So, to give you an idea of what we're aiming to build, it's going to look something similar to this. Maybe not exactly like this, but our goal is we need to have these drop downs right here. I'm sorry, these tabs right here. And uh we're going to have some style guides and maybe some font, whatever. And the most important part is the mood board. Okay, so let's go ahead and get started with the style guide section. Now, go ahead and open up your folder structure. You want to click on layouts.t tsx. And inside this component, we're going to do a couple things here. So, the first thing I'm going to do is I'm going to grab the children and I'm going to pass the children down here. Then, I'm going to create some tabs here. And you can just pause the screen and type. So, this shouldn't be too much. And we're going to have the icon type uh the value and the label for these uh for these icons, okay? For these different tabs. And at the end, make sure you add this as const. Okay? So now we can copy this and we can use it down in here. So first let's change this to uh we don't need to make this uh async actually. Okay. Yeah, we're good. So down here go ahead and remove this div and we're going to return the tabs. The reason why we're returning the tabs in here is the very next page which is a style guide is going to have those tabs, right? And so it makes sense to put the tab provider up here itself because we're going to have one tab in here. Now you you can do this. This is fine. U but if you have any tabs in within this that could cause some sort of discrepancy. I I hope not. I don't think this should be a problem. We'll come to know eventually as we keep coding. Okay, for now just keep uh keep pushing through. We got to get this up as fast as possible. So, we're going to pass in the following props, which is a default value and the class name. And then after that, I'm going to create a div right here. And inside this div, I'm going to give it the following class name as well. And you go ahead, pause the screen and type this as well. And then inside this, we're going to create another div. And this div is going to have another div inside that. Okay? And that's going to have the following class names. And this is going to have a div that separates the style and the style guide and just some paragraph. Okay, for now I'm just going to put lower or maybe we can change this to manage your style guide for your project. There you go. Love AI. Then after this, you want to hit uh enter after this div. And now we're going to create a component here called tabs list. Okay. So go ahead and bring this in from the components UI tabs. Okay. And then this is going to have another class name. So, please go ahead, pause the screen, and type out this class name right here. Okay? And it's going to look like this. Right now, it's moving over to the side. And here, it's going to be right in the center. And then, inside the tabs list, we're going to loop over those tabs that we just created up top. And I'm going to say tabs do map over them. And for each of them, I'm going to first create a con. So, open this curly bracket, create an icon, and then we're going to say tabs trigger like this. And that's going to have the key value and the class name. Okay, so there you go. Very simple tab menu. Looks very similar to this as well. And in the pro version, guys, if you purchase the codebase from the description, I'm going to update that to uh kind of change the designs a little bit, the colors a little bit. So, as you can see here, these are like premium styles, right? We have shadows, all that kind of cool stuff. And uh in this to make it simpler for the video, for those who are watching, we didn't include all of that. But regardless, it's everything the same features. Nothing is different. It's the exact same thing. You probably don't even need that, right? Doesn't doesn't make that too big of a difference. But uh just want to give you a heads up. So when you purchase the codebase from the description down below, not only are you going to get all of the code, you're going to get all the bonuses that are limited time only. Okay? So go ahead and grab that codebase. So you can also get the updated designs that uh we will push through. Just give us some time. We're going to change that. It's going to take us some time. And then we're going to change that and so you can grab those as well. Okay, awesome. So, uh down here we're going to essentially say tabs.m map and uh after this we're going to render out a trigger, right? And this trigger is going to have the following class name and inside that the icon, the label, the value. That's how we get this. And uh all the way at the bottom now, we also have to return the children items. So down here at the very last div, you're going to say div container MX auto and you're going to return the children item. So now you should see the page render in here. Okay. So now let's go into the page.tsx and this page.tsx is going to have the following. So in here I'm going to hit enter and I'm going to say tabs content. Also make sure you import it from our components folder. Okay? Not from the uh not from the in not from our radics folder. All right? That's going to mess up everything. So make sure you import it from the correct folder. And then next you want to put the value and the class name in here. And the next thing we're going to do in here is we're essentially going to get the style guide. Okay, we need to g we need to grab all of um all of this data from here. So let's go ahead and hit enter. So first we need to get the project ID. So let's grab that from the props. And this is going to give us the search params. So we need to accept those props. So we can grab that. So let's go in here and let's accept that right in here. Okay. Next, we need to essentially create a query that's going to get the existing style guide for us. So, I'm going to say existing style guide like this. And now we have to pass this in. So, let's go ahead and create that. So, open up your folder structure and you want to scroll down to convex folder. And inside this, click on your query.config. And at the bottom, you're going to say the following. Export const style guide just like this. And that's going to have an async function needs the project ID. And then down here, you're going to say preload query. And you're going to pass in this new um this new query right here. Okay. And you're going to pass in the ID projects and the token in here as well. So now let's go ahead and create that. So open up your folder structure, go up into convex, go into projects. You want to shrink this. And at the bottom, you're going to say the following. Export const get project style guide, which is a query. And that's going to have the following arguments. And we're going to have a handler right here. Okay. And this is going to help us first get the authenticated uh user ID. If not, throw an error. All that kind of stuff. And we're also going to check the ownership. Okay. Now, we're going to return the parse data with the style guide or we're going to return null. Now, if you go back, this should not throw any more errors for you. And also, just a quick tip, right? If you click into a file, if you close that file, it takes you to the previous file. So, that's how I know how to go back really quick. Okay. So now let's go back one more step and that's going to take us into this this page. So let's bring in that style guide query and this style guide query is essentially going to give us the existing style guide. So now we have to um grab that from this. I'm going to say guide is equal to existing style guidestyle guide like this and we're going to say value as JSON as unknown or as style guide props. Okay or type sorry. Now, in order to create this, we need to have one of our APIs. So, let's go into our folder, Redux folder API. And in here, we're going to create style dash guide. Okay. And inside that, we need an index.tsx. We need an index.typescript. And then in here, I'm going to say export const interface like just like this. Okay. And this is going to have the style guide with a theme, description, and color settings and typography settings as well. All right. And then up here, first thing we need is the typography setting type. So I'm going to say it's going to be of this specific type title and the styles for the typography. Now the typography style itself is going to be as follows. So the specific name, form, family, font size, all that kind of fun stuff. Okay. And finally, we need the color section. So for color section, what I'm going to do here is I'm going to say primary, secondary, accent colors, all this kind of stuff. Just pause the screen and type this. And that's going to give us the color section. And that goes in here. Okay. So color section, uh, that goes in here. And for the swatches, we're going to have another interface. This is just name, the hex color, and the description. So this is how we can create a style guide. We need all of this to create a style guide for something. Okay. Awesome. And now let's go back to our component in here and let's import this style guide from our Redux folder. Okay, awesome. And now we're going to get the color guide. So we're going to extract it from here. We're going to grab the color sections. And then we also need the typography guide. So let's go ahead and grab that as well. And then I'm going to say const existing mood boards is equal to await. And this is another query we need to create. So, let's go ahead and do this as well. So, open up your folder structure. You want to go into convex at the bottom here. And inside your query.config file right here. We're going to say moodboard image query just like this. And uh in here, we're going to say preload the query. We're going to get this in just a second, but then uh we're going to pass this in here. And then finally, we're going to say projects. And we're going to return the images from here. Now, to create this, go back to your convex folder. We're going to create mood board with the same spelling. Please don't make any spelling errors. Okay. Typescript like this. And that should solve the first error here. Well, once we obviously return something. So, let's go back in here. And then the first thing we're going to do is create export const get mood boards query is going to be a query like this. I'm just going to import this. And let's just uh remove this stuff. Okay. And oh, actually, AI did a pretty good job. So let's import V from convex values and let's get the arguments. Then we need the handler. So the handler is going to be an async function and that's going to first do this. It's going to get the authenticated user. So we're going to get the authenticated user right here. Then we're going to get the project and verify the ownership. So we're going to say get project if project exist and user is the project user ID and the user ID match do do XYZ. Okay. If they don't match, then return the sorry. And then if they do match, then we're going to say storage ids equal project mood board images or an empty array. Then we got to generate URLs for each of these images. So the good thing with convex is convex allows us to store these images inside their storage service, right? So that comes for free as well. So what I'm going to do here is I'm going to import uh the storage ids here or actually uh sorry guys I need to import this get user uh get o user id. So go ahead and import that and then at the bottom here we're going to get the storage ids which comes from here. So we're going to map over them and for each of those we're going to try the following. So we're going to await ctx.sto storage get the URL for the specific storage ID. Okay. And then we're going to return this. So, we're going to return this right here. And uh now we're going to have this specific ID for the URL for these for this image. And uh just to make it make this clear, this is a promise.all. Okay. So, this is technically um okay, the image is never I mean the value is never read, but it's going to be an array of these images. That's what this is. Okay. So, now down here, finally, we got to return this and we got to filter out any of the failed URLs. So filter like this for images null. Okay. Now let's go back and that should solve this error here. And now let's go back to our application itself. I mean the page I mean. And then here let's import this mood board image query. Now let's get the guided images from this just like this. Awesome. So guide image and we're going to grab this. And now we need a type here. Now, this type is going to come from one of actually from another file. So, let's go ahead and create that as well. So, for the mood board image type, you're going to go into your hooks folder, and we're going to create another hook file in here called use styles, which I'm not sure if we're going to need right now, but um what we're going to do in here is just export this interface mood board image. Okay. And now we can go in here and we can import this. Later on, we're going to update that file, so we'll get back to that later. But uh now we have the guide images. Now inside the tab content or the tabs content, we're going to check for the guide. And if the guide exists, we're going to return uh we're going to return something. And if it doesn't exist, we're going to return something else. So how do how do we do that? Well, I'm going to say if no guide, so if no guide like this or guide images.length, if this does not exist, then here instead of this, I'm going to return another div with a much better design. Okay. So, go ahead and do the same thing with me, please. Okay. Awesome. Pause the screen and type. And this is going to be another component called theme content just like this. So, let's go ahead and create this component as well. And also the color guides are being passed into this. So, that means if we do have some sort of a style guide for this project, we'll return that into this theme content component. Okay. And so, this theme content component is going to be inside another folder. So let's go ahead and create that. So open up your components folder and inside this you want to create style and inside that you want to create theme and inside that index.typescript or index.tsx. And then in here all we're going to do is we're going to say theme content just like this. Export const theme content. This is going to get the color guide that it needs. And this is of type any. And this returns a div just like this. Okay. And inside that we're going to return another div. And inside this we're going to return a component called color theme. So let's go ahead and create the color theme component. So all the way up top we're just going to say const color theme. This takes in the title, the swatches and the class name. And this is going to have those props as well. Type prop. So let's go ahead and bring that in. And it's essentially the same thing. Title swatches class name. Okay. And for swatches, all we need is the the name hex color and the description. Now, inside the return statement, we're just going to return a div here with the CN function. So, let's import that. And then we need the following class name. And then down here, we're going to pass in an H3. Okay. And then after this header section, we're going to pass in the color swatch. So, the color swatch is going to need another component. um or actually the yeah the color swatch is going to be another component too. So let's go ahead and close this folder. Okay, right here. And inside the style folder, you want to create swatch like this and index.tsx. And inside here, we're going to return color swatch like this, which and it needs CN function and the types. So I'm going to bring those in too. And now we're just going to return a color swatch for that. Okay, so it looks very similar to something like this. Now go back one page, import the color swatch, pass in the props, and down here I'm going to say if swatch swatch description exist, return that description, too. Okay, awesome. Now, let's go back a page. And now let's import this theme content. Okay, and now we have no colors generated. Obviously, we'll get to that in just a second. All right. Now, I just used AI to create some mock data so I can show you what that looks like. And there you go. Okay. So, we have all of our colors in here. I totally create like a pastel type design and it did it for me. So, I can just show you the mock data and show you what that looks like. You can do this as well. Just open up whatever AI terminal you're using. Uh I mean AI code editor that you're using. I'm using cursor. You can use whatever you like. And you can just put that in there. Now the next section that we need to create after this tab content is the tab content for typography. So down here go ahead and say tabs content and the most important part is the value. Okay, so that's how we can trigger this one to load. So you want to say typography right here and then you're going to say style guide typography inside this. So this is another component that we need to create. So go ahead and click into this. I think it's like maybe we could just go into tab content. Okay, it's kind of like a hack, right? And then inside that inside the style, you want to create typography like this and inside that an index.tsx. And let's go ahead and return that component just like this. Now, this one is going to take in some props, which is the typography guide. And for simplicity sake, we're just going to use any. And then in here, we're going to dstructure this. And then inside this code, the first thing is I'm going to remove this. And I'm going to render out a React fragment. And let's go back to the previous page. And let's import this typography guide. Now, another cool hack is you can do commandshiftt to go forward a page. Okay, so that's how I go back and forth. So now if you click typography technically it is rendering the typography page but uh colors it's rendering colors and then typography as well. So the next thing is inside this we're going to need to create typography like this. So if typography guide.length then we're going to check if it's zero and if not if it's zero we're going to return this saying no typography no typography generated and if uh this is not true. So if this is false, the false condition is going to look like this. Okay. So in here, first thing is we're going to return a div. And this div is going to have typography guides.m map inside this. Okay. And inside this, we're going to need to return a div first. And this div is going to need to have uh it's going to need to have the key. So make sure you pass in the key in here. And it looks like it's not creating my ending tag. Okay, there we go. And inside this, we're going to need to create the header section. So, I'm going to say div header H3 with the following class names. And I'm going to put text large. Okay. So, um I can't pass in any sort of, you know, mock data right now. I'm going to need to first create it or else AI is going to bug out. But based on this, you can have an idea. I we're not going to create all of this stuff. It's not needed right now. is just MVP, but uh you can obviously, you know, render out different fonts, different color themes, all that kind of stuff. But uh we'll be building, we'll be just rendering out the text here, right? So then after that, uh down in here, we're going to hit enter after this uh title, we're going to create a div. Okay? And this div is going to have an ending div like this. And then inside this, we're going to check for the sections. So we're going to say sections.m map which come from each typography guide. And for each of those sections we're going to return a div here. So I'm going to say div like this. Okay. And inside that we're going to pass in the style index. And we're going to also need to pass in some class names. So I'm going to remove uh I'm going to hit enter here. I'm going to say class name. And I'm going to pass in the following. Next I'm going to create another div inside this. We don't need the style name right now. I'm just going to say div like this. Um, looks like bunch of tags created itself. I do not want this. So, just going to actually this should be fine. So, we have a div. We have an H4 inside it. But I want to change the H4 style to the following. So, please follow with me. And then we we do not need the paragraph thing like this. So, I'm going to say style.escription description if it exists. Then render the uh paragraph like this. And then after that down here, we're going to need to create another div. Okay. So, I'm going to say this is a quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. Okay. And then after that, we're going to create another div down here. So, hit enter right here. We're going to create another div. We're going to show the font size, weight, all that kind of stuff. So, it's it's different in the sense that it's not just like this, but um you know, it's at least it sort of applies the same way, but we're just going to show the font style. Okay. If you're a SAS developer or SAS entrepreneur and you're looking to start S2C as a real SAS company, then all I'm asking for is just 30 seconds of your time. I do have something to pitch and once I'm done, if you think it's a fair deal, awesome. I'll show you how to get in before we run out of spots. But if you just want to carry on with the video and you just want to continue, then I really don't mind. I wish you the best and I hope to see you in the future when we launch this publicly. But I will let you know that there are some benefits with joining now. And so just give me 30 seconds of your time and then you can decide if this is for you or not. So this is our limited time founders beta program for S2C. We know the struggle, right? You've just purchased the codebase. You're ready to go. You wanted to start this as your real SAS company, but now you're hit with the reality of needing to maintain the code base over time, updating it with newer features, fixing all of the bugs, and then also some technical debt because if you don't know how to code, you're going to create hell for your customers. And so, we know about this problem, right? And so, that's why we decided for a limited time, we're going to get a dedicated development team to continuously upgrade S2C for you. So, if this already sounds exciting and you want to give me the next few seconds to hear more about this, then here's what this program is all about. So, first of all, this is a beta program, which means that it is only available for people who have purchased the codebase. So, you can't join this program from outside. You can't purchase it. You can't you physically can't enter uh un unless you have joined right now and you have purchased the codebase in this specific time frame. And also the most important thing is we only have 100 spots because we want to work with a smaller number of people cuz this is a beta program. And most importantly, we want to get valuable feedback, right? And that's why we're going to give you all of these benefits that I'm going to explain in just a second. And as a result, we also see if I mean, we also see if we could we enjoy doing this in the long term cuz it is it's a lot of time and energy and we want to make sure that this is fun for both you and I. If you were to hire us or hire a development team to do this for you, I'm sure it's a no-brainer. you would have to spend thousands of dollars uh because you'd have to hire these people. And so that's exactly why we created all of uh all of the features inside this program. The first one is there's going to be monthly feature releases, okay, for S2C. There's also going to be instant bug fixes. That means you can show up in the community. Uh you're going to get access to a little community. You can go in there and you can say, "Hey parent, we faced this bug. Any ideas if we can put this into this this month's fixes?" Right? and we're going to assign that uh to like a priority and we're going to push that at the end of the month. Then there's also performance optimizations. In the future, you might want to optimize some of your features. We can do that as well, right? And also security updates. You might want to make your application stronger and protect yourself and that's exactly why we created uh this founders beta program. Next, priority support. You might have some questions regarding the code or you might want to speak to us regarding a new feature that you want you might want to add into the application. this is the perfect opportunity to ask because you're going to be speaking to the creators of S2C. And my most favorite part is the feature voting system. So, inside this community, you'll be able to create uh new feature requests, and our team's going to go in there, see which feature was voted the most. We're going to put it into a backlog based on priority, and we're going to push that out for you. So you essentially are going to get all of the benefits and uh you know off of having a real development team and also have a direct say in the product's future. Now what is the irresistible offer? First of all, this is a risk-free 30-day money back guarantee. There's there's no risk at all. So whatever offer you that I'm going to show you, if you don't like it, feel free to just reach out to us and we'll give you your money back, okay? In your first 30 days. So, the irresistible offer is if you join the first 100 members, you will get a lockin price at our lowest price this program is ever going to be, which is $47 per month. Okay? And it will never change. Even if we increase this to $200, $300 per month, it's going to be 47 for you. Okay? This is a founder uh founder member lockin. Now, please keep this in mind. This is a beta program. Okay? We're testing this out and uh we hope to provide massive value and we know we're going to but we want to make sure that we can actually handle all of these requests. So, okay parent, I love this. How do I get access to this? So, when you purchase the codebase, you'll be redirected to another page or you'll find a link somewhere that uh that says, "Hey, grab the S2C uh founders beta program." So, you grab the codebase and then you can also have the option to enter the first uh 100 uh to grab your spot from the, you know, the first 100. And I'm so sorry if you see this page and you see that we're out of spots. We'll eventually open up spots. We just need some time. Price might change obviously, but um we just want to make sure that we can work with a small team, get valuable uh valuable feedback and make sure the program is good for any other future code bases that we want to add into this program as well. So you'll either see a link where you can click and uh you know directly purchase online and that's going to give you a community access called prodigiesuniversity.webroies.com. That's just a subdomain. That's not Prodigy's University, but that's just how he named it. Or it might be different. Okay, you'll find it. You'll you'll receive an email or once you purchase the codebase, this is the landing page. You can scroll down here and claim your spot from here as well. Okay, so I hope this was of immense value. We're trying our best to to give you give back to the community as much as possible and help you save tens and hundreds and thousands of dollars as well. Okay, so if you guys find this valuable, go ahead, click the button and join and I'll see you in the other side. All right, guys. So, there was just a small malfunction on my end with my recording and so I just lost about 10 minutes of recording and so I'm just going to walk you through what I did. Okay, don't worry, we didn't do anything crazy. First thing I wanted to show you is in the mock style guide which you can obviously get from the uh from the codebase if you already have it or I'll also provide it for free inside the YouTube kit in the description. Okay, so that mock style guide also has the typography settings and this is what it looks like. Now, I did make some changes to the design itself. So, I'd like for you to take that up uh take that up as a challenge. So, try to see what did I change here. First thing is I put it into this tool tip. So, all the text here, I put it into this tool tip up top here. And I also changed the design. So, instead of having cards with background muted, I just removed that to have this more minimal appearance. So, hopefully you can take that up as a challenge and try to build that out yourself. Okay. So once that's done, you want to duplicate the same thing down below and you want to change it to mood board here and you're going to call a new component called mood board and you're going to pass in the guided images, the guide images that we have up top here. Okay, so you're going to pass that in right there. And also let me make sure I remove this mock style guide as well. Okay, awesome. So now we're using real value uh the real values and obviously we don't have any data right now. So go ahead and create this component like this and then you're going to copy this name. You're going to open up your folder structure. And inside your folder structure, you want to go into styles, which is inside your components folder. And inside that, you want to create another folder called mood board index.tsx. And inside this component, you're going to create this component right here. And you're going to uh return just a regular component. Okay. Now, this mood board is going to look like this. Okay. And it's very simple to build. It's just a div has a border. So you can pause the screen and type this out for yourself. And this component is going to need some helpers. Okay. So that means when someone drags and drop an image, we want to mount it. We want to show it like this. And so these images are going to need to have a randomized, you know, rotation. It's going to need to be kind of like displaced a little bit. So it kind of looks like someone scattered images across a like a blueprint, right? That's what we're trying to go for. And so go ahead and build this out first. This is going to create this effect here. And then up here, we're going to create this new uh hook here called use mood board. And inside this, we're going to pass in the guide images, okay, that the user is trying to use. And then in here, we're also going to say images. So these are the helpers that we're going to create now. Okay, so copy this name. And then once you're done with that, open up your folder structure and you're going to go to hooks and inside use styles at the bottom, you're going to create this hook. Okay, you're going to say export const mood styles just like this. Now, if you go back, there's one more prop we need here. The prop is of type mood board images. So, don't forget about that. And inside this component is the same thing, the mood board image, which is going to be inside this already, right? So, we're going to call this an array of those. Then, the next thing is in here, we're going to also get those guide images. And we're going to do a bunch of stuff. Just bear with I know it looks like a lot of code, but I promise you it's nothing too complicated. Okay, let me shrink this so it looks easier to kind of digest. There we go. So, the first thing is we have a state to essentially keep track of the dragging state, right? So, remember I told you the whole purpose of this co this hook here is to handle all of those drag and drop, deleting the image, adding the image, saving the image, all that kind of stuff. So, it's like a helper. So, first one, we need a state to keep track of the dragging state. So we're storing that in here. Then we're going to get the project ID from the params. So let's grab that as well. Then we're going to use use form because we want to store some default value, some default images. And uh we can also kind of like type cast, get errors, watch, all that kind of stuff, right? So next thing we need to do is extract watch, set value, and get value from form. So let's go ahead and do that as well. We're going to set this images here to watch for the images. So if anytime we want to know what we have stored, we can take a look at it directly in here. Okay. And this use form is using this new type called style form data which is basically images which is of mood board image which is an array. So it's the same type as our guide images. Okay. Then down here we're going to need some helper mutations. And these helper mutations are going to help us from the database side. Save, remove, generate a new uploaded URL, all that kind of fun stuff. So go ahead and create the helper function here called generate upload URL. And I'm going to say use mutation API.board.generate URL, which you will not have. So it's going to throw an error. So please pause and type all of this. Okay. And then same thing, uh you can create this if you want as well. No problem. Go ahead and create remove mood board image. Then this is also another use mutation which is mood board. Moodboard image. Now obviously we don't have this. You're going to see an error. So open up your folder structure. You want to go into convex into mood board.typescript and you're going to find the generate upload URL. It's very straightforward actually. It's not too complicated. Right? So it is a mutation and what it does is it writes to the database. Right? What is it doing? So it's a mutation that essentially actually it's not a mutation. It is a mutation but I think uh in here it doesn't actually create anything yet. It just generates. So I think that's why it's considered a mutation. So it's fine for now. Just do it this way which is set the handler to an async function which gets the user's ID. No user throw authentication error. Once we have that we're going to generate the upload URL. This is a an API that that the storage already has. Then we're going to store that in here. That's it. Done. Okay. and your Convex is going to upload update automatically. Super cool stuff. Okay, it's like magic. Next, for the remove mood board image, we're going to do the following. So, in here, we're going to say remove mood board image just like this. And this is going to be uh this is going to have args, the arguments set to the follow following uh object. And then in here, we're going to have the handler, which is an async function. So, this is kind of where I left off. So, let's go ahead and complete this function. Okay. So, hopefully you're still with me. If you have any questions, guys, just reach I mean, if you have any questions, just reach out in the Discord. There's a ton of Discord members, community members are just helping each other out. I'm sure they're going to give you a helping hand. Okay, but um if you just pause, type with me, and pay attention, you shouldn't have any problems. Okay, so inside this handler, the first thing we need to do is get the authenticated user ID. If no user, we're going to throw authentication error. Okay, then we're going to grab from the database this project ID. Okay, we're going to go into db.get and grab this project. If there's no project, we're going to throw error here saying not authorized. Uh, sorry, project not found. Let's change that. Let's change this as well. Then if the project user ID is not equal to user ID, we're going to say access denied. Okay. Then next, we're going to get the current mood board images. So I'm going to say current images is project.mmoodboard images or set it to an array. Okay. And we're going to remove the storage ID from them. So in here I'm going to say up updated image current images.filter and we're going to remove that. Okay. For wherever it's not where whichever is not equal to this will be filtered from the final results. Finally we got to update the project in the database. So I'm going to say await ctxdb.patch patch the project ID with the mood board images and last modified. Okay, next finally down here we're going to have a try catch and this try catch is going to delete it from the database. So we're going to say ctx storage uh it's going to delete it from the storage. Okay, so we're going to do storage ID like this and we're going to just delete it with the help of this API here and that's it. If there's an error, throw a console error. So you see programming is very linear like web development at least. It's just a it's a repetitive process. You just need to know the APIs. And now because you have AI, you pretty much don't need to code. Okay? And quite frankly speaking, like I I don't code my SAS applications anymore, right? Like all of my real SAS companies or even my products, my website, all of that stuff. By the way, we have a new revamp revamp of my website. The one that we have right now is just a temporary one, but u soon we're going to have a revamp with the dashboard, all that kind of cool stuff for you guys. All right. And uh that is all built using AI. I don't I don't use any I don't write any code anymore. It's crazy how far AI has come. And it is it is really good. You can build stuff using AI without writing a single line of code. Okay. So um yeah man don't don't ever feel like if you don't know something like if you don't know what this means I promise you you will still be successful in the field of web development as long as you learn how to focus on the most important parts okay which is how to start the SAS how to launch it how to get customers and uh you know enjoy the process build it using AI so you still are part of the development but don't get too much into it where you're only coding okay that's all I'd like to say now the final stage right here is we have to return this data. So after this blue bracket, I'm going to say return success true image count updated images.length. Okay, nice. Now we can go back and now we're going to have that remove mood board uh created as well. Great job. Now going back to your use styles component in here. We have this use effect that obviously you don't have. So go ahead and type out this use effect and you're going to pass in the guided images from the from the props or from the parameters and then set value and get values in here as dependencies. Okay. Now please follow through with me line by line. Essentially what we're doing here is we're going to load all of the existing images from the server and if we have any client images as well, we're going to merge that into this array. Okay? And that way we can create like this real time instant uh view of the images. So what we're going to do here is we're going to say if guided images and the length is greater than zero then we're going to get all the server images and we're going to say set uh get value. So the current images of whatever is inside that array, right? Whatever is inside the client side. And then we're going to check if this is zero. If it's zero, that means there's only server images. So we're just going to store the server images. And so this right here, this example of use form and the uh the react hook forms is a real use case of building it from scratch. Okay. So if you're wondering how to build a completely custom experience with use form hook, this is a great example. So um by subscribing to this channel, you are going to get more free value just like this. You're going to get more resources just like this. So not only can you subscribe and receive it in the future, but you can also save this video if you want. So that way you can come back to this. Okay? And I highly recommend you do that because there's not a lot of videos online that teach about the custom way to use use form hook under the hood. Okay? Just save it. Come back to this in the future whenever you need it. And uh promise you it's going to be a great resource. Okay? It's evergreen content. So at the bottom here, if this is equal to zero, like I said, we'll set the server images as the value. So that's how you set using use form hook uh manually. Okay. Next, we're going to say if this is not true, then we're going to merge all of them to the current images that we have. Okay, merge server images with the client images. Okay? And so it replaces any of the uh any of the uploaded ones, basically. Next, down here, right here, we're going to replace any uploaded client images with their server counterparts. That's what we're trying to do here. Okay. So, for each of these, we're going to grab the server image. We're going to say conclient index. We're going to find that specific client index uh that server image. So where client image equals server image, we're going to find that so we can replace it. Now, if we haven't found it, then we're going to clean we're going to clean up the old blob. Okay, if you don't know what a blob is, just look it up. It's like a file. Okay, it's for for it's for images and for files. Okay, so we're going to clear up the old URL if it exists. And all we have to do is we're going to say at that index. So merged images at that index.prepstarts preview that starts with blog. If it does, then we're going to say URL revoke object URL. Okay, we're going to clean it up and we're going to pass in that preview link. That's how it this this is going to help us uh do that. Okay, and so once that's done down here, we're going to replace them with the server images now. So, we're going to say merged images at that specific replace that specific image that we just did, right? So merged image images at that index is going to be equal to the server version now. So all we did is replace the uploaded client versions with their server versions. That's what we did. Okay. So this way um what we can do is instantly give the user feedback. And I love this. I do this all the time in my image upload features inside any of my SAS applications. Okay. So um also on my portal I'm building this feature for you know staff or internal staff where when we upload an image the image shows instantly right I like that I hate it when it has to load and then it uploads to the server and then it comes back and it's waste of time right first show the image and then upload it if you want and this is how that's done first store it as a blob and then you can replace it as a server version and then replace the client version with the server version that's it Okay, awesome. So down here we're going to create some helpers. The first helper we're going to create is the add image helper. So go ahead and say const add add image which takes in a file of type file. And then in here we're going to say if the image length is greater than five, we're going to prevent the user from creating a new image. Okay. And if not, we're going to create a new like test data mock data image, right? with default data and we're going to say ID is going to be this format file. The preview URL is going to be create object URL for that specific file. And then we're going to say uploaded and uploading false and is from server false as well. And finally down here we're going to merge that. So we're going to say updated images equal to whatever is inside image. What is this? Well, this images right here comes from right here. Watch, right? So if in your use form uh I guess use form form okay if a form in your application uses use form and you want to see the values of that form right now in this very instant you in instance you can use this watch function you can watch for those values but be careful this is not very performant. Okay so if you place some sort of a use effect on top of this and do things on top of this it's going to rerender your front end like crazy. So be careful with this watch function. And that's why I didn't do anything else here except for look at this image. Okay. So down here I'm going to put everything that's in there plus our new image and I'm going to set the value to this new updated images. That's it. And I'm just going to show a toast message. So that's the uh that's the set that's the add new image helper. Next, let's go ahead and create the remove image helper as well. So, this is going to be a server uh sorry, an async function that needs the uh image ID that we want to remove. And there's two things we're going to need to do, right? First, we have to remove it from the server. Second, we're also going to need to remove it locally, right? Two things that we need to do. Now, you can do this these in reverse order, but then you have to focus on optimistic experience. That means if something fails from the server, you have to revert it back. You have to do all that stuff. Okay? But, um we're just going to make it as simple as possible. And the first thing we're going to do need to do is to find the ID. So find the ID of the image from the images that we're trying to remove. If you don't find it, well, something's wrong. You can't remove the image. So we're going to skip over that. Now, if it's a server image with a storage ID, then we're going to delete it from the database. So check to make sure it's from the server, check to make sure you can remove it. So image to remove has a storage ID and obviously it needs a project ID. Then we're going to create try catch and remember we created this helper right okay this helper up here we're going to use that helper we're going to pass in the projects with the project sorry the project ID and the storage ID so it's going to find it and delete it that's it okay and in the catch we're going to say console error toast error in return straightforward now down here we're going to have another function that's essentially going to help us update these images okay So I'm going to say const uh that's going to help us essentially create a track of the updated images. So updated images equal to image.filter for where that specific image ID is equal to the image ID that we just removed. Right? We're going to clean up the preview for that from local as well and we're going to return false. Okay. Um so all we're going to do is if image is from not from the server and image.preview starts with a blob. So if the user tried to delete it before that, right, we can uh before it's uploaded, we can remove that here as well. And uh then we're just going to say return false, else return true. So everything else exists. And then we're just going to set our local state and set the toast. That's pretty much it. Okay, awesome. Now we're going to create a handle drag. So this is an event handler that I've used in so many of my applications. And if you want to learn this in even more depth, you can watch Plura, which is one of my favorite courses. And in that course, I show you how to build a full website builder completely from scratch. That means there's no third party library. We show you how the drag and drop functionality works um in a website builder. Okay, if you want to learn, that's a great opportunity. So inside this handle drag first we're doing event prevent default and stop propagation because it always circles up bubbles up right okay that's too technical but if you don't know what event bubbling is maybe you can look into it later and then all we're going to say here is if the type is drag enter or if it's drag over then we're going to set active to true. If it's drag leave then we're going to set drag active to false. That's all the handler does. Okay. And I'll show you later where we're going to use this and how we're going to use this. The point is we need these handlers. So, let's go ahead and build this out. And the next one is the handle drop. So, this is when we drop something, there's going to be another event, right? Also, this E right here is the event of event type drag event. Okay. Same for the drag uh handle drop as well, which is really weird. It should be a drop event, but whatever. Um, so this is a drag event and we're going to stop propagation prevent default and set drag active at faults by default. So what we're going to do in here is we're going to say array from from these files, right? Uh, e transfer data transfer files. We're going to find those files and then we're going to filter wherever the file.type starts with image. And uh this is essentially I think the reason why we're doing this is to keep track of uh is to know the type of the file that's being entered, right? So if you drop a folder, it's it shouldn't work. That's that's what we're trying to do. Okay. So then down here, if the image files length is equal to zero, that means we're going to tell them, oh, there we go. So only drop a file image image file. Okay. And then finally for each of these images, we're going to add the we are going to add that image. Okay, that image that was dropped. So image files. We're going to find the file and we're going to make sure it's less than five and we're going to add that. That's pretty much it. Now the next handler we're going to need is handle file input. This is where the use I mean this is just a handler for internal like the internal use and all we're doing is just resetting the input value. So you can see files, we're grabbing the file and for each of them um we're saying add file. We're passing that file in here and then we're removing the target value. So once it's once the action is done, we're essentially resetting it. That's what we're trying to do. Now comes a use effect that's very crucial in this whole process to work together. Okay. So let's go ahead and create a use effect like this. And inside this use effect, let's just keep a clean empty dependency array. And inside this first thing we're going to do is we're going to create a helper function. Okay. And this helper function is called so const upload is equal to an async function. Oh, what was that? Okay, there we go. So I'm going to say async function like this. And we're going to invoke this if the images.length. So we don't have to invoke it right here. We're just going to say if images.length length is greater than zero then we're going to upload pending images. Now what is this? So essentially this use effect is a background use effect and it helps upload the images as soon as they are added. So this whole thing works together because of that. Remember we had the real time removing the blob and doing all that kind of crazy stuff that happens in here. Okay. So let's hit enter. And the first thing is we need all of our current images. So, I'm going to grab that from this uh real quick. And then I'm going to use a for loop here, which is very traditional, but this is just how I'm going to be doing it right now. Okay. So, u let me make sure I'm not have I don't have any typos here. Okay. So, for let I equals zero. I less than current images.length i ++. And inside this, I'm going to say const image equal to current images at i. And then after this I'm gonna say so we're finding that image essentially. And then in here I'm gonna say if we don't have the image or something is wrong then we have to mark it as uploading. Okay. So what I'm going to do here is uh sorry guys if we if we haven't uploaded the image and it's not uploading currently and it doesn't have an error that's when we're going to do this process. So we can mark it as uploading and start the process. So we're going to mark put this. So the current images are going to be put into this updated image using a spread operator. And then we're going to grab the updated images at that specific index and we're going to set as image everything that's inside that. But we're going to set uploading to true. Okay, this is called immutable state. If you don't know all this stuff, that probably means you're newer to web development and that's totally fine. You don't have to worry about it. Just know that if it's not a use state, you cannot change um I mean in in React in X.js, it's it's not like an object, okay? Everything has to be set this way, which means you have to reset the state to a new state. So if data is equal to a bunch of stuff in here, like you have name set to whatever, right? So you have let's do this once more. Cons data equal to and you have name age you have these things right now inside react if you want to keep everything before this and you want to update just one value one value then you can't just you're not supposed to say data age 30 we don't do this typically you're not supposed to instead what you need to do is reset this okay so we're going to say everything that's inside inside the data but we're going to set the name to a new state. Okay, something like this. So, const new data is equal to this. So, this is how you're supposed to set states inside of React. Okay, never do it independently. Okay, never never change it directly in here. You have to duplicate it. Okay, so I don't want to get too technical, but that's essentially how that's essentially what we're doing in here. So, setting that specific property to true. Now, we need to set our local images to the updated image. Okay. Then we're going to create a try catch. So try catch like this. And inside the try block we're going to create the upload image helper. So in here I'm going to say upload image. And it looks like I made a small error here guys. Just give me one second. So on top here we have this const called upload images. Right. So this is a helper function that we created. Okay. Okay, so I totally got confused. I thought this was upload image and I was just a little confused. So all you have to do is scroll all the way up top. Okay, right below this. And what we're going to do in here is we're going to say const upload image is equal to and this is going to be an async arrow function just like this. And I'm going to remove whatever it created in here. And this is going to need a file. Okay, so I'm going to go in here. I'm going to say file of type file. And inside this inside this arrow function also I'm going to set a state uh a type here a return type and this is the type this is going to need. Okay. So first thing is we're going to get the upload URL. So I'm going to use this helper function and get the uploaded URL. After getting an uploaded URL I'm going to upload a file to convex storage. So I'm going to do fetch upload URL right in here. post method head content type file type and then I'm going to say body file just like this and once this is done if the result is not okay we're going to throw an error and if it is okay then what we're going to do here is we're going to grab the storage ID from the result.json JSON and if we got all of this right that means we also have the project details. So I'm going to say if the project ID exists and this comes from up here from the from the params then what we're going to do is we're going to use this get uh this add mood board image helper function and we haven't created that one. So, we're going to go up here. We're going to say hand add, sorry, add mood board uh mood board image is use mutation like this. And we're going to say API.board.add moodboard image. So, copy this name so it's easier to create this function. And you're going to go back, click into that, the one on top so it takes you into your convex file. I'm expecting you guys would know these shortcuts right now, right? And then we're going to scroll down here and we're going to say export const add add mood board image and we're going to pass in the following arguments. So I'm going to re redo this just to make sure I have no spelling errors. Okay, like that. And then a handler right here which is an async error function. And this is going to first get the authenticated user. If not throw an error then we're get the we're going to get the project to make sure that we and verify the user's ownership and then we're going to essentially check if the project ID the user ID is this it belongs to that user if not we're going to throw an error there too and if the current mood board images um essentially we're going to try to get the current mood board images from this project so mood board images like this and if we are at the limit so we have less le than u we have greater than five they're trying to upload more we're going to throw an error and we're going to get the new storage ID like this okay so uh we're going to say up uh sorry the new storage new updated images like this so current images storage ID we're going to pass that into it so we're passing the new storage ID into this updated images array so that way we can keep track of it okay then down here we're going to say oh wait patch DB like this project ID we're going to up upload the new updated images and the last modified date. Okay, so that way we can grab these are basically like ids your string of ids, right? So we can grab it later. Then we're going to return all of that data and we're going to return an image count. So let's go back now and that should full uh that should solve that TypeScript error. Okay. So now at the bottom here after we have we have associated with that project if we have the project ID down here and we have added the moodboard image now it's time to return something from here. So I'm going to return storage ID. Okay. Uh you don't need this URL. That's fine. Now after this if this throws an error we have to have a catch statement right. So this is supposed to be inside a try catch and I don't think we put that inside a try catch. So let's go ahead and do so. So, I'm going to say try catch like this, we're going to copy all the stuff and we're going to drag it and put it right in here. Awesome. And at the bottom, if this catch fails, right, if it if it in if it's invoked, we're just going to throw that error. Okay, you can console it if you'd like as well. Just like that. So, now scroll back down to our upload image function down here because we have successfully implemented this. And now we have the storage ID. So now we have to mark that image as uploaded and uh this is the im this u the image will essentially be refreshed from the server uh because of the query. Okay, so I'm going to say final images get value and we're going to pass in the image in here. Okay, so it's going to give us all of the final images and now let's go ahead and mark it. So actually first we're going to find them. So we're going to find that specific new image and then we're going to say if we cannot find it. Then we're going to set the final images to that final image to that index as a new array. Okay. And now we're going to set it as true. I hope this is making sense here. Okay. And so we're going to set it now to true. And if not, that means it's already from the server. So we just have to set uh the value. So all I'm going to do uh here is I'm going to say set value. So after this if statement sorry inside this if block after this we're now going to set it. Okay then after this we're going to have a catch here. So if this error was invoked then we're going to console the error and we're going to mark that specific image as error while uploading. Okay. So how do we do that? First we get the values of get all the images. Then we find the index of the image. Then we check to make sure that we actually found it. Okay. So if we did not find the index. So in I'm sorry if we did find the index and index is not equal to -1 then we're going to say error images at error index which is going to be this new object and we're just going to set upload failed. Okay. So that means we found the image. And then in here we're going to set the value of the images to the new error images. And then finally at the bottom after this blue bracket we're going to say if images.length. Oh actually we already did this. So this is how we're invoking this. Now for the most important part the dependency array. So the dependency array is going to be images set value get and upload image. Okay. Awesome. Um I see something in here. What is this? Okay. Hm. move it inside the use effect. So what we could do, it's a function. We don't actually need upload image in here, right? It's not needed. So uh upload image does not need to be as part of it. I think it's it was I just pass it in there because of the dependency thing right here. And if you don't, you know, don't ever do that. Sorry, guys. So yeah, only pass in what you need. We technically don't even need the get values, all this kind of stuff. But because I had it in my code, I don't want to have any bugs while developing while developing. I'm going to pass it in for now. Okay. Now, we're going to essentially have another use effect. And this use effect is just a quick unmounter. Okay. That essentially cleans up all of the preview URLs. So, when you're using this new strategy here, okay, which I just taught you, you have to clean them up. So, we're going to say use effect return images for each of them. And we're going to revoke their object URLs. Okay, this does not need this. This is fine because this will invoke once it's unmounted anyways. And then finally, we have to return all of this. So, let's go ahead at the bottom and say return. That was a lot, right? That was a lot. I understand. It's just part of the game. Come on, guys. You're going to you're going to have a final payoff. Okay, we got to get that bread. Let's do it. So, let's go back now. Let's go back to our component. And now we can import this. And now we're going to get all of these helpers. And I see something in here. Let's quickly refresh and see if it still throws that error. No more error. Moodboard. Okay, I see an error. I see an infinity loop or of some sort. So, let me go ahead and fix that. Just give me a second, guys. Okay, so I just dug around AI a little bit to see what was going on. And uh turns out that nothing was actually going on. So that means if I remove this and just set it to a div like this then I'm not sure is it working now or not working. Okay, so it's it's working. Okay, give me a second guys. Okay, what a strange error. Okay, so this is not an error really, but you see this right here, right? This is absolute. And because it's absolute, it's just placing a layer on top of this. I thought it was an infinity uh loop or something. Thank god it wasn't. So, at first I was so confused because nothing's here and there's nothing here and I was like, what is wrong with this? But that just makes sense. It's absolute. This is relative. So, that means this was supposed to be inside this. Okay. And AI is awesome. Thank you so much. I love you, AI. So, now let's go ahead and uncomment all of this. And let's bring back the mood board. Okay. And so now if you refresh now you can switch back and forth. Okay. So all the event handlers are not being mounted onto the elements obviously. So that's something we have to create as well. So just for now I'm going to remove this and just build this at uh together. I mean actually we don't need to. Let's keep this as is. We'll just go piece by piece. Okay. So the first thing I need to change is the class name. So I'm going to set the class name to the CN function. And if it is drag active then I'm going to essentially show a border. If not, I'll just keep it as regular. So, this is essentially what it looks like, right? So, if you drag something into it, it's going to show uh this border color. Okay, awesome. And then after that, inside this, we're going to need to mount our drag events. So, this is all from scratch, right? So, we did not use any third party drag and drop library. We built this completely from scratch. So, please subscribe that uh please smash that subscribe button. It just, you know, motivates us to do more things just like this. Okay. Um, so, uh, we're basically going to set up all of this. We're going to set up the drag, uh, the drag enter, drag, leave, over, and on drop. Okay. So, these are the handlers that we need. And so, when you drag and drop something in here, it's essentially going to guess what? Well, it's going to activate these. Okay. And these come from this hook right here. So, next inside this div, like I said, we're going to have this little style right here. Doesn't really do anything. I think it's just like a little gradient. Um, has some design there. That's pretty much it. Okay. I'll see what what I try to create here. I kind of forgot. I'm not going to lie. It's been a it's been a this project has been a while in the making, right? And then the next thing is we're going to loop over all of the images. And if the images exist, we're going to return something in here. Okay. So, first I'm going to remove this and I'm going to return a React fragment just like this. And inside this React fragment, I'm going to say the following. So I'm going to create a div. And this div is going to have the following style name. So please go ahead, pause and type this out. Okay. And then inside this div, I'm going to create another div just like this. And this is going to have relative. And inside this, we're going to loop over the image. And we're going to randomize them and rotate offset X and Y on those cards. Okay. So, first thing we want to do is we're going to say images do map inside this. Okay. Uh why did this do it right here? Images.m map like this. And we're going to render something. Okay. This is fine. I can work with this. So, let's remove this. And now inside images.map, we're going to remove this return because we're going to do some custom logic in here. And looks like I made another typo somewhere here. I think it's right here. Um, is it right there? I think it is right there. Let's try to return something. Awesome. Cool. So, let's remove this. And we don't need to return a statement. Awesome. So, now inside this bracket, what we're going to do is we're going to say con seed equal image. ID. So, please just follow this uh follow step by step with me. Okay. So, first we're going to say the following. So, image.m map uh sorry, con seed is equal to this right here. And then after that, just to kind of shut this up cuz it's yelling at me, I'm going to return something here. And we'll get back to this in a second. Okay, don't worry about this right now. Or let's just put a div. Okay, a div just like this. And let's remove this. So now it's not going to yell. Now after this down here, we're going to essentially create random number one, random number two, and three. Okay, for for each of these cards. And then after that, we're going to create the rotating offsets. So, I'm going to put some comments in here so you can pause and read how they work. And they just create offset uh and rotations for these images. And then in here now, we're going to return the image board. Okay. So, I'm just going to create this. Go ahead and do this with me. So, create this component and pass these in. And now, we need the index. So, the index comes from, let's see, right here. So we have this. We also need the index. So let's grab that. And that becomes the key, the image, and all the other props that we need to pass in. Okay. So pause the screen and type this out with me. Now the next thing I'm going to do is I'm going to copy this. Open up my folder structure. And inside mood board, I'm going to create images. images.board.tsx. And let's return a component with that new name. And this is going to need those props, right? So, let's go ahead and and pass those props in here, too. Just like this. And let's dstructure all of those props from here. Nice. Now, inside this component, the first thing we're going to need to do is we're going to say div like this. And now, we have to pass in the key. So, I'm going to say key and class name while we're at it and say absolute and group. Okay. Obviously, you're not going to see anything right now, but uh it's going to look very similar to this. Okay. And then after that we're going to pass in those styles. So this is these this style prop is how we can customize that. We can hardcode those um you know the the transformation that the margin left all that kind of stuff right the offset. And once that's done it's going to uh it's going to put it on this tab on this card. You want to hit enter. Remove this. We're going to create another div with the following class name. And this is going to have the following styles obviously. So please pause and type. And inside that we're going to create an image from next image. Okay. And that's going to put the image preview. And we're also going to have some alt text on top of that. We're going to say fill. And then we're going to have another component here called upload status. It's kind of like a check icon. Okay. So let's go up top and let's build this. I'm going to scroll up here. Okay. above this and I'm going to say const upload status is equal to a function right so it's a function essentially it's a component and this has the image prop which is going to have uploading uploaded and error okay boolean boolean and string and now this is going to return the following so I'm going to say if it's uploading we're going to return a loader and this has animate spin on it and with the following style so please pause and type and then if it's uploaded, a check mark. And if it's an error, an alert circle. So for each of these images, we're going to render that out so we can see a status for them based on if they're uploaded or not. Then down here, we're going to have a simple button. Maybe you might want to change this to a regular button, but it already has some styles, so I'm not going to mess with it. And we're going to import the X uh icon from Lucid React. So we can delete that as well. And that will use the remove image helper which comes in from the prop. Okay. So one thing you can do in here is you can you can invoke the um you can invoke the the use I think what is that called use mood board hook in here and you can grab that. I'm just going to pass it in here. Okay. Going back to our component now we can import the image board component. And obviously we're not going to see anything and that's okay. But um let's keep I mean let's keep I mean maybe let's not move forward. Let's see if we can drag something on this and just see what happens. Okay. So let's go ahead and give this a shot. I'm going to drag an image on top of this. And there you go. It shows me this plus icon. And if I drop it, it instantly drops it onto the board and it also renders that. Now it's not going to show right here. That's because I have this. Oh, so I have an error. What's my error? Okay, let's see what the error is. So it says image. Okay, this is not an error. This is just the uh the host name that we need to connect. So let's go ahead and do that. So inside your next config.typescript, you want to just set it to the following. So images remote patterns, and you're going to put https convex.cloud. Let's refresh this and see if that solves our problem now. And there we go. Now it loads our image. And because I'm scrolling, I think it loses track. Interesting. What seems to be the issue? Okay. Ah, I know why. So, the version that we the version we created is on mobile devices and it hides on a bigger device. So, that means if I drag one more card, it's going to place it with a slightly different styling and stack it on top of it. There you go. Looks awesome, right? Damn, that looks so cool. So, on bigger devices, obviously, you're not going to find it there. Okay, that's pretty much what's going on. So, we're still on track. We're doing great. And if you've come so far, I'm so proud of you. This is you're I mean, you're almost there to build your I mean, you're almost at the finish line of building your own SAS, right? Super exciting. So, let's uh complete the next one, which is on desktop. So, if I refresh this, I want to make sure my data actually exists in mood board. Nice. It actually exists. Now, this unmounting is just as a performance thing in Brave. If you were on your uh if you were in Google Chrome, you probably wouldn't see it flash like mine. Okay. Now, typically because it's unmounting and remounting, you're going to see that anyway, but Brave just has a ton of uh security things in place. So, that's why you're going to see security and performance things in place. Okay. So, the next one is I'm going to go ahead and create the second version. So, this is going to be in another div, but this is going to be hidden on mobile devices and it's going to show on desktop devices. Okay. Now, in here, I'm going to say relative width full max U and the following here. I think here I have a smaller width. Okay, I don't think I have a width in here. Okay, we don't have that. So, make sure you add this. Okay, and then we're pretty much going to do the same thing. We're just going to change a couple things here. So, I'm going to paste this and let's go over this together. So, it's the same thing as above. So, duplicate this, copy, and paste it here. But the values for number two and number three are pretty much the same, I think. Okay, pause the screen and just type this. Okay, type this out to make sure you have the same thing. And then, uh, I've put all the notes here so you can read how the offset works and all that kind of fun stuff. But it's the same thing, just it's a desktop version. That's it. So, if I expand this, you see it shows up this way. Okay? And you can bring it closer. You can do whatever you want. And that's why I put the notes here. So, if you grab the codebase, you can go in and tweak it to whatever you like to make it look better. Okay, awesome. Now, at the bottom here, at the end of this, I'm going to hit enter. And there should be a React fragment somewhere somewhere here. Okay, right there. So, if there is no length, uh I'm sorry, if there is nothing in here. So, after this react fragment, guys, you're going to hit Hm. Give me a second. Okay. So, what you want to do is you see this, right? You want to put all of this into this React fragment. So, shrink this. Lift it up. Put it in there. That's it. Let's make sure it's actually there. Okay. Nice. There we go. Okay. Awesome. And down in here after this section, you're going to find the React fragment down here. You're going to hit enter after this curly bracket, and you're going to say if images.length is equal to zero. So, there's nothing in there. then we're going to do the following. So I'm going to say if there's if the length is zero, then we're going to create a div. And inside this div, I'm going to create another div in here that's going to have an upload button. Okay, so if I didn't have anything in here, then it's going to essentially show drag and drop an image, whatever, give some information to the user, and I'm going to have a button in here. And you can use this handle upload click. Okay? And this is a handler that's going to use the file input.curren.click. and I'll show you how to get that. Um, so in order to do that, first you're going to need a ref. So let's go ahead and grab that ref. So I'm going to say file input ref equal to use ref from react. And inside this, all I'm going to do is I'm going to say file input ref.click current.click. Okay, that's pretty much it. And uh the other thing is let's scroll back down. Okay. And so now I can choose files from my uh from my you know uh from my device and I can upload them as well. And then the next one is if the images.length is greater than zero. So after this hit enter if it's greater than zero and you can add more. Okay you can show that button in here as well. Uses the same hand click. If you click on it boom it's going to show you um you know your thing that you can upload. Okay. Um I totally forgot. So, we have the ref. It is going to show, but you need to mount that ref onto an input element so that you can click that element, right? I totally totally forgot about that. My bad. So, after this, you're going to hit enter. And now, we're going to create a simple hidden input field. Okay. This is the trick. You want to create a hidden input field. So, you can do that. Oh, that's really cool. I didn't know Mac does all this kind of stuff. Damn. Okay. I love Mac, man. I'm never going back. Okay. All right. Never mind. So after this div, you want to hit enter. And now we're going to create a generate style guide button. Okay. But for simplicity sake, I'm just going to call this button right here. And inside this button, we're going to say generate. So let me see if that Okay, that expands. Oh, that's way too much. So let's just say class with fit. Will this do it? Okay, it kind of does. It not really does it, but it's okay. It's fine. does the job. So, I'm going to say create generate styles with AI. That's a huge button. Okay. Generate with AI. I think I think that's better. And we're going to we're need to get get to this again. So, put a comment here to do add AI generation. Okay. So many cool things in this project. I'm so excited for you. So, the next thing down here is if the images are greater than five, then we're going to show this error message. Okay. And that's it. We're done with setting up our mood board. And uh we can now proceed to the next section. All right. Now, go ahead and open up your terminal. And you're going to say get add get commit-m. You're just going to call this dashboard plus mood board and style sheet. Something like this. Okay. Then hit enter. And then you want to do get push. It It's also asking us if you'd like to start a review. We're going to click on yes here and let that run in the background. And in the meantime, we're going to say get push. It's going to give us the upstream. Let's paste that. And that should push all of our code. Okay. So, let's just give this a second and let's see if code rabbit caught any bugs inside our application. So, like I mentioned in the previous section, code rabbit gives this feature completely for free. That means you can run uh checks and you can essentially compare your uh you can do a review directly inside your IDE. Check this out. I'm looking at their pricing and um as you can see it's $0 and you can review inside the IDE, right? And right now they're giving us the maximum plan, which is the pro plan for free for 14 days, but regardless, you still have this. Now, I would obviously get what I need, right? And I probably only need it for myself. I'm not I don't think I'm going to need a team for this, but um this is going to save me a lot of time because when I'm coding, I do not like to go in there. I mean when I'm building a SAS I do not like to go in there and you know do the coding part of stuff right I need the team who is the expert at the coding to essentially handle that. So I probably get a plan that is around here but uh if you have a bigger team or if you need more features right you can probably get this one too no problem. But uh regardless great great product by Code Rabbit. Awesome job. And in the meantime, I'm also going to go into my pull request, sorry, into my codebase inside GitHub, and I'm going to see what happens if I also try to create this pull request from here, just to see if Code Rabbit does it both ways. So, let's go ahead and create that PR. And let's just give it a second. Whoa, I just found this. This is super cool. So, you can you can run unit tests. Okay, this is nice. I did not know about this feature, but essentially I think you can create PRs with unit tests. Damn, that's that's awesome. Okay, that's a pretty nice feature. So I guess if you like to test your application, which you should um if especially if it's your own SAS, right, you definitely have to write unit tests now, you can do that directly in here. So you don't have to type it out. Okay, so typically what we do in real production grade SAS applications is we have a CI/CD and this CI/CD is going to run all of these tests when it's pushed, right? So you can figure out a way to actually connect this, right? And you can um also obviously move tickets as well. I came to know that Code Rabbit can uh can be combined with your linear dashboard if you're using linear for ticketing or Jira, all that kind of stuff, right? So maybe you could move that once the tests pass and uh once the tests are created. So I I think this is another awesome feature. So great stuff here. So in the last section I showed you what to do inside GitHub. So now let's look at what it looks uh what it what the user experience is like when doing this directly inside the IDE. Okay. So essentially it compares the previous changes to the base PR, right? And uh the current changes to the base PR. I think that's actually the main branch and it puts those comments uh comments directly in here. So all the pages that were changed um it's going to look through them and it's going to put this in here. So you see here it's telling you replace any type with this type and so it's reading every single thing. Okay. And I think you can just accept it directly from here just like that and you're good to go and the changes are applied. And obviously you need to import it all of that but just for uh simplicity sake I'm going to remove it right now. But this is how you can uh review all your changes directly in here. And I think it caught one more one more bug. I found that just a second ago. Give me a second. Let me find that. Okay, I think this is the one. So um when you are parsing JSON, if there is something that is not that that is poisoned or it's corrupted of some sort. Um and this can happen. So if the JSON that was saved is malformed in some way, that's going to fail because of this check. And so all it's telling us to do is wrap this in a try catch. And I I mean I know this, but I know this only when I do it, if that makes any sense. Right. So what I mean is when I'm doing JSON.parse, I see an error and then I wrap it inside this try catch. And I think from from now on, maybe in my future projects, I'm going to make sure I actually do this too. So always make sure you wrap your JSON.parse inside this try catch block. Okay. Now another awesome feature here is if you don't like to go line by line and obviously first review them okay just look at the changes don't don't apply all of them but just look at them read across them and if you think it actually makes sense and this can help you then you can go up here and you can fix all the changes with AI directly okay this is another awesome feature that code rabbit offers so this is how to handle your PRs locally inside the uh IDE itself and inside the branch inside the PR I think you guys you guys already know how to handle that. Okay, so for now all I'm going to do is go ahead and merge this pull request and you can go ahead and implement the changes if you like. They're mainly TypeScript errors and then maybe that try catch block. Okay, so let's go ahead and confirm this merge and there you go. Awesome. Now this is merged into main. Let's go ahead and grab those changes as well. So go ahead and open up your terminal. It might actually focus into the comments tab. That's fine. Just click on terminal right here. And then you want to say get checkout main. And then we're going to do get pull and hit enter. And there we go. Awesome. Now let's proceed to the next section. So in this section we're going to be focusing on this canvas. So this is built completely from scratch. So for some of you coding nerds who want to know how to do something like this, I think this is a great opportunity to learn. Okay. So like I said, save this video so you can come back to it later if you need to or if you have the time right now. spend that time and learn how this feature is built so you can put it into your own applications. Okay, so this is a fully scrollable, fully pannable free uh I guess you can call it like a like a canvas board, right? And so you can scroll, you can zoom, you can pan in, you can move elements around, some elements you can't move and so you can also place elements on this and pin it onto this board and that happens automatically obviously just like in Figma. So, the way I just pinned this in here, right, it's going to lock it into the, you know, it's going to lock this frame into this panable screen, right? Same way, all our frames, all our screens, everything pans and sticks in right in here. And, uh, we're going to learn how to build this from scratch. So, uh, there's a ton of stuff that goes into this. So, I'm let's I mean, let's just jump straight right into it. Yeah. So, the first thing I see is this page right here. And that probably means that we have our canvas page. So if you go right here, you have a layout page like this. But you might see the word layout. Okay? And that's probably because you have layout like this. So change that to the children. So accept children props. Render the children down in here. And then you're all set. Okay. Now, this component needs a couple styles. So let's go ahead and change this. So I'm going to say uh height full and height uh sorry with full height screen. And then this is going to need a toolbar. Okay. So let's go ahead and paste the toolbar. And the toolbar is what shows up at the bottom. Okay. Okay, it's going to look similar to that. And now let's go ahead and open up our so copy this name. Open up your folder structure. We're going to go into components folder and inside this we're going to create canvas. Okay. And inside that you want to create toolbar and inside that an index.tsx. Let's go ahead and return a React snippet. And now we can create this component in here. So this doesn't need any props. Let's go ahead and remove these as well. And inside this component, first we're going to provide some styles for this div. So I'm going to have the following class names. And then inside this, we're going to have first the history pill. So that's essentially this section. Okay, the back button and forward button. And then we're also going to have the uh the zoom bar. So you can zoom into the canvas like I said, right? And then we're going to have the toolbar shape. So whatever tools you have, you can add into this. And the architecture is built in such a way that you can expand on top of this in the future. Okay. So you can put drop downs, you can put put more I guess pre-built frames, whatever you whatever you like, right? So let's go ahead and do that. First, let's build the history pool. So I'm going to call this history pool just like this. And you're going to copy this name. You're going to open up your folder structure. And inside toolbar, you're going to say history as a folder and index.tsx. and let's return another snippet just like this. Now let's go back one step. Let's import the history pill. Let's go back another step and let's import the toolbar. Okay, so now if you refresh the page. Okay, it's taking a moment. All right, there we go. And we can see the history pill at the bottom. I'm just going to move this to the right side so we can see clearly. Okay, nice. Now let's go back into toolbar inside history pill and let's continue. So this component is going to be a use client component. So let's put that as well. And let's remove the props. And this div now is going to have the following styles. So go ahead, please pause and type this out. And then next we're going to have another div inside this. I'm going to say div like this. And this is going to have a couple styles as well. So go ahead and say styles just like this. Okay. And uh now inside this guys, I'm going to provide area hidden. Okay, just like this. You don't have to set it to true, but just provide that in here. It's for the screen reader essentially. And we're just hiding that. Okay, and then after this, we're going to uh we're going to create a span inside this and we're going to say undo 2, which is uh an icon. Okay, undo two. And then we're going to say screen 18 and class name opacity just like this. Now, if you realize, we kept seeing this weird flash on the screen, right? It kept flashing white and that's because the main HTML page does not have a background. Okay, so go in here into your HTML and I hope this fixes it. Okay, that does fix it. So go ahead and just put class background uh bg background. I thought typically tail I mean Tailwind would do that by default. I don't know why it's not doing that, but that should solve that problem. Okay, so that's root layout.tsx. That would essentially solve that bug for you. And uh now let's continue from the history page. So after this undo button, now we got to do the redo button. So this is just syntactical sugar. We're not really doing anything crazy here. Uh I just I'm just putting it in here so you can come back in the future and then update this stuff. And uh if you want to know how to do those states and all that kind of stuff, I have created another video called Plura. And in Plura, we had an redo and undo functionality. Uh redo and I think redo and undo. That's that's incorrect, right? Oh, maybe it is correct. Okay, undo and redo. And in that I show you how to build it completely from scratch. So essentially how to keep track of the history stack. That way we can remove the history based on the button that's being clicked. And we also set up shortcuts, all that kind of fun stuff. So that might be a more in-depth video if you want to learn that feature. Okay. So now we have created this section right here. There you go. You can see it at the bottom. So now let's go ahead and shrink this page. And let's go back to our history. Uh let's go back to our index page for the toolbar. And now we're going to create the toolbar shapes component. Okay. Actually before that guys, let's just do the zoombar component like this. And we're going to use camel case here. And let's copy this name. So copy it just like that. Open up your folder structure. And you want to go into the toolbar here. And you want to say zoom. And inside that also I want to show you something. So if you click on this folder and you say zoom and you say slash and then you put index.tsx, tsx you can essentially create a folder and a folder within it. Okay, so this is if you if you need this and I think you can also directly create a file within it as well. I just don't know what's the right format but I just want to show you some quick quicker ways to code. Okay, so now let's go ahead and return a snippet and we can uh go back here remove the props and let's also import this component so it stops throwing errors. Okay, there we go. And now inside this component, the first thing we're going to do is we're going to set some styles on this div. Okay, so go ahead, pause the screen and do just what I just pasted. Paste these class names as well. And then in here, we're going to have another div. Okay, and this div is going to have a button within it. So let's go ahead and provide that button component. And this button component comes from Shatzen. So let's import that. We're also going to have a zoom out icon. And kind of looks like this. Now, this is going to require the handle zoom out uh function. Okay? And so, we're going to create that handler. So, up here, I'm going to say handle zoom out equal new scale. And this is going to need the viewport. Now, how do we get the viewport? So, first we'll need viewport here to get the scale that it's currently at. And we're going to do some crazy math, okay? Don't have to worry about this. But, um after that, we're also going to pass in the minimum scale amount. So, how much can we scale essentially? And then we're going to dispatch an action to the store so we can update that data. Okay, we're going to set the scale to whatever the new scale is supposed to be. That's for zoom out. Okay, so now what we need to do is we need to create a hook. So let's go up here and I'm also going to put a to-do just in case so I don't miss this. I'm just going to say to-do add zoom in zoom out. And then up here we're going to create that hook. That hook is called use infinity canvas. Okay. Now this does have a lot of stuff in it. Just please please bear with me. Okay. U let's go ahead copy this name and we're going to open up our folder structure and we're going to scroll down to hooks and inside this we're going to say use-canvas.typescript. Okay. And then inside this we're going to say export const just like this. It's equal to an arrow function. And this is going to need to uh first have the dispatch. So let's go ahead and grab dispatch. And I'm going to import these as well from uh React Redux and app dispatch from Redux store. And the next thing we need is the viewport. So in order to do this, so this is the state. This viewport comes from the main state which is the uh a redux store. So we need to create that. So let's go ahead and make sure we have that section completed inside. And I believe we do, but let's just take a quick look. Okay, looks like we've already created that. So we're good to go. So now inside this I'm going to just say viewport equal to use app selector from movie store and we're going to grab the viewport value. Okay. Now we need to also grab the the shapes the entity shape uh the state um which is which we're going to call entity state and we're going to grab all the shapes. So we're going to say entity entity state dot use app selector s.shapes dot dotshapes. Okay. And this is going to throw an error. So, let's go back real quick and let's just import this use canvas hook. And in here, I'm just going to comment this out. Okay, there we go. It's going to throw that error. That's fine, but uh we're going to solve that in just a second. So, in this use infinity canvas, we're essentially writing the brain, the entire architecture of the infinity canvas. Okay, so this is everything. So, I hope you're paying attention because first of all, there's going to be a lot of code in this use infinity canvas hook because it's the main hook for the entire uh for the entire canvas itself, right? So, we're going to cover a bunch of helper functions, a bunch of states, a bunch of refs, a bunch of uh you know, so many things in this component and it may not make sense right now, but you got to understand that each and every section inside this is just a helper for other components. Okay, so for example, we had this viewport. It's needed for something else in here obviously, but we might have another function down the line, maybe calculate distance, something like that. And it's going to be a heavy mathematical calculation that's going to help us uh, you know, calculate the distance between a point on the canvas and the end point on the canvas. So, we can create a shape there. You get what I'm saying? And this also helps us do other helpful uh tasks like create a preview before attaching the shape onto the canvas. So all this kind of stuff, all this that we're writing right now is going to be a little overwhelming, okay? And I'm giving giving you a little heads up right now, okay? So just follow through with me and I'm going to try my best to explain each and every step as we go. It's not going to connect because these are individual components, individual helpers within this use infinity canvas. Okay? And because we're building it from start to finish, like I said, it might look like we're building something out of nowhere, but that's because we're not I mean, it's better to just do it right now so we can later build the components and directly use this hook. Okay, let's just get it out the way. All right, so grab your cup of coffee, sit down with me cuz we're going to complete this all the way through. And if you purchase the codebase, the codebase is going to come with all of the code comments, okay? especially for the I'm talking about the use infinity canvas. Everything else is pretty straightforward so far, right? So, this use infinity canvas is going to have all the code comments that you need. So, please grab the codebase. I promise you it's going to be the best investment you make because it's going to save you so much time. And if you need you can read through the uh codebase as well to understand how the architecture is built. So, you can expand on this as much as you want. Okay. Most u you know most applications like this would just leverage a third party library but it's really heavy right it's it's heavy and there's a lot of code you have to do tree shaking all that kind of uh webpack stuff in order to improve the performance but this is just one function our team has spent so much time to build just one function that does everything a third party library would do so if you want to build an excali draw clone this is all you need you don't need anything else right you just have to remove the cool AI feature uh website development part and just keep it. That's it. You're done. That ex that's excali draw by itself. Okay, so let's move on. So the first thing is why are we creating this entity state? So um well in our redux we're essentially storing all of these shapes, right? We're storing these shapes but we need to normalize it. I mean it's already normalized inside and stored. So like how we do in the database. And so now we need to convert this state into an array so we can render it onto the screen. Okay, that's what we're doing here. So let's go ahead and do that. So I'm going to say shape list. It's going to be a shape array. And this is going to need to be imported from our Redux store. Then I'm going to say entity state ids. We're going to map over that. And we're going to filter them for all the shapes where the ids exist. So we're just getting all the booleans. Okay, successful booleans. Next, we're going to grab the current tool. So, this is essentially the tools that u uh the tool that the current user that the user is currently using. And so, let's hit enter here. And I'm going to say current tool equal app selector.shapes.tool. Okay. And then next I'm going to check what have they selected. So, what uh what shape have they selected? So, this is another value where we can store that. So, selected shapes is use selector.shapes dot select. So, we're just creating variables right now and states right now to store these values in here. Okay, that's all we're trying to do. Next, we're going to keep a state to also keep track of a sidebar that's going to be inside the viewport. So, let's go ahead and put that as well. And then, we're going to need to uh loop over all of our um shape entities that are in here. And we're going to extract that and also store it inside this shape entities right here. Okay. Then we're going to need another helper function called ha called has selected text. And this is going to um essentially check if any selected shape is a textbased shape. Okay. And uh this is used to essentially automatically open any text editing sidebar or the text editing components that we need. So what we're going to do very straightforward, we're just going to say has selected text. Oh, so I created this. Okay, this is fine. We don't need this right now. We'll build that as we go. So has selected text is object.keys selected shapes dossum where the shapes dot shape entities at the ID. We're trying to get that shape at that specific ID and we're trying to return if we're going to return true um if this is the type is text for that shape. Okay. So that that way we know they have selected something that's a text. Now we're going to use a use effect that's going to check if they have selected a shape. uh if they've selected a text and the sidebar is not open. This way we can open the sidebar. So I'm going to say use effect. If they selected a text and the sidebar is not open already, open the sidebar. If not, close the sidebar. Okay, very straightforward. And the dependency array is this and the sidebar open. Okay, cool. The next thing, this is basically section two and inside the codebase, I've written uh every single uh comment for this use infinity canvas. Okay, so it should make even more sense there. But um essentially in this part, it's the memory that we're going to store for the hook itself. Okay, so these are all refs. So these are refs that essentially store some state. They store refs of the elements like the canvas, the u you know the free drawing points, all that stuff on the canvas. And they don't rerender the screen. That's the most performant part of this section. Okay, so imagine if someone was drawing something on the screen like an Excali draw, but that took forever to I mean there's so many points, right? And if we used a use effect, a use state to store those, it's going to rerender the screen over and over again, which is going to burn out obviously cuz that's going to rerender like 100 200 times from here to here because there's 100 points in between that, probably even more. Okay, so that's why we're using this ref. And then I'm going to show you how we're going to force update that. So, um, not all the time. I mean, for some of them, we're going to need the updates anyway. That's the trade-off, but for some, we don't, right? So, let's say user clicked on the screen, uh, to move the screen length or something like that, right? So, we want that to only update once. That means we want to forcibly update that and that's why we're creating a ref. So, the first one is the canvas ref. So, this way we can get a reference to the canvas. Very straightforward. Then we're going to create touch map ref. Okay, this is essentially going to be uh a new type. We're going to grab this in just a second. And it's going to need the ID and the point. Okay, so let's go ahead and bring this in. And this point comes from our viewport. And then in here, all we're going to do is we're just keeping uh we're using this ref to to attach it onto the DOM elements. So that way we can map any of the touches on the screen. Okay. And we also have multi-touch support as well. Okay. So if they touch multiple parts, we can do that too. So zoom in, you know, that kind of stuff, right? Um, okay. So spec specifically for mobile devices, I think that's where this will come in handy. Next, we're going to need to store the draft shape ref. Now, this is important. The way this works is this is the shape that's being drawn before it's finalized. Okay, that's why it's called draft shape ref. So that means when we draw a shape on the screen, we're first putting it into preview mode. So this is the preview shape that follows your mouse while you're drawing. Okay? While you're sketching and then later we'll mount that once it's successful. That's essentially what the step is. And this is going to need some types. So let's go up here. I'm going to say these are the types. We have frame, rectangle, ellipse, arrow, line. Okay, forget about these. These are just starting and ending points. Okay. So, that's essentially what the starter uh the the the draft shape ref means. Next, we're going to have another ref here. I mean, we're going to have so many refs here, but just bear with me. This one is the free points ref. And so, this is to essentially connect the points, store the points for freehand drawing. Okay? So, we're going to have a pencil tool inside a design. And uh you could I think you've already seen that. I've already showed it to you. Something like this. And that way we can use that to draw on the screen. And so we need to keep track of those points. Okay? So it stores all of the mouse and uh the touch points for a smoother freehand line. Now, we're going to use points on the screen, but you can update that in the future and make it look nicer. In fact, I liked it when it when it had the dot dot dot effect when you're first sketching. Um and then it converts to a line. Okay, awesome. The next one is spaced press. So space pressed. So this is a state that essentially checks the keyboard shortcuts. So if the user clicks spacebar, this is where we're going to remember if the keys u are pressed and this will not create a rerender. So this essentially u so these is pressed this section right here. It um remembers if the keys are pressed without causing any kind of rerender. Okay, I hope that's making sense. And then the next one is drawing ref. We have um just to keep track of the drawing shape, right? The moving shape. So user if they're moving something, then we'll keep track of that. And move start ref as well. Okay. So where did where did the movement start from? That's what we're doing there. Now this next part is kind of like a checkpoint. Okay. So what we're doing in here is we're going to create something called initial shape positions ref. So this remembers where where the shapes were before they moved. Okay. So before the starting point initial positions and this is crucial so that way we can create a smooth shape movement from point A to point B. Okay. So that way we we basically need to know the starting point. So what I'm going to do is I'm going to say initial shape position refs just like this. Please please pause and type this with me. Okay. Next down here is erasing ref just to see if we're erasing something from the screen. So we're going to bring that in. And the erased shape ref as well. So let's bring that in as well to store those values. Next we're going to have resizing ref. So if they're resizing, we're going to store that in here. So dimensional changes, right? Uh dimensions dimensional dimension. Okay, never mind. And then here we're going to have resizing data ref. So this is the shape ID, some corners, the initial bound bounding rectangle. If you don't know what this is, this is basically some JavaScript stuff to get the uh get the viewport, get the borders of some sort of an element, that kind of stuff. Okay, so we're going to get that and starting point. Then now we're going to store some animated frame refs. Okay, so this is basically going to help us control a smoother animation for all of these changes. And these are like 60 fps animations. Okay. 60 fps animation loops and uh it's smoother for drawing and panning stuff like that. So, first last freehand ref, then we're going to have freehand ref. Just keep just paste these for now. Uh later on we'll use that. And this probably wouldn't make too much sense anyways, but um we're just creating a smoother way to connect all of these together. Okay. So, so far we're just creating stuff. We're not using it soon, but pretty soon we're going to because now is the utility section. So this is uh the third section in this part and these are like helper function helper functions that make the code cleaner and help us like use all of these values. Okay so the first helper function is you notice these refs here some of them need to update right some might need to update because when refs change the UI will not update and so how do we trigger that? Well there is a way where we can manually trigger this using a force state update. So, we're going to call call u state and let's import this. We're going to just say zero in here. We just need to update this to a different number for it to rerender the screen. That's it. And we're going to create a request render helper function that's going to set the value here to n plus1 or zero. So, that will essentially trigger a rerender. Cool, right? Okay. What's next? So, the next one is a coordinate conversion uh helper function. And this helps us convert the screen coordinates to the canvas's coordinates. So wherever the screen is, how is that connected to our canvas? So if our canvas is tiny, then how are we going to connect those two dots? And uh because when the when the canvas is zoomed in, we need to know where to essentially place that, right? If this doesn't make sense, it's fine. Let's just keep going through. Uh you probably need to see it, right? But we can't see it right now cuz we're building all of these functions right now. So I'm going to say local point from client is client x number client y number and this is going to do the following. Okay, first we're going to get the current rectangle. And in order to do that we need the current canvases ref. And then we're going to say if nothing is there right so there's no canvas return x uh client x and y. Okay, we're going to pass these values later. And then if not if not we're just going to grab the rectangles the border all that kind of stuff of the canvas ref and we're going to return that. So now we know the relationship between the canvas the viewport and the canvas itself. Then the next thing is um sometimes some of the text that are already being clicked on right the text inputs or text uh canvas elements um we need to remove the focus from these elements. Okay. So this way we can prevent we can use like keyboard shortcuts and stuff like that in the future. So all we have to do is blur active text input. So we're going to say get the active element that's in the document and it's if it's a text if it's an input then we're going to fire the on blur. So it just clicks out of it. That's essentially what we're doing. Now we're going to create a type here. So just go ahead pause the screen and type this to create uh this client xy type. And then we're going to create a helper function that's going to help us invoke the local point from the client. And we're going to need to pass in these values. So I'm going to say get local point from from this point which is we're going to pass in with client xy right in here. And we're going to pass in uh this is going to return us a type of a point. So now we know this is going to return us some ids, right? And uh in here we're going to say local point. We're going to invoke that. We're going to pass this in here. Now the next one is uh so this section essentially the one that we're going to do right now is for uh it's called shape hit testing. Okay. If this doesn't make sense it's okay. Just please keep pushing through. It's all going to make sense towards the end. Okay. Um I'm also seeing this saying you're importing this that needs use effect. This is a client component. Um and this is in use user canvas. Did I name it incorrectly? Oh, okay. Let's change this to use canvas, guys. Sorry about that. There we go. And user off. Let's change that, too. There we go. Okay. Um hopefully it doesn't throw any errors. Okay. Let's go back in here now. Let's scroll to the bottom. So, in this hit text uh hit testing section. First, we're going to like figure out um which shape was a user using or the user clicked on. And uh it's usually called collision detection. They do this in games as well, right? So that's what we're trying to do. And uh so first thing is we need to get the shape at that point. So find which shape is under the mouse. That's the most important part. And so we're going to check the shapes in reverse order, top to bottom. And um we're going to just check the topmost one, the topmost shape so we can get that. Okay. So here's what we're going to do. So I'm going to say get shapes at at the point. Okay. And we're going to create a for loop in here. So this is going to need another type. We're going to create this in just a second, but um let's go ahead and and uh create this shape type. So, this shape type, we're going to scroll up top and or actually let's go into our shapes. Looks like I mix misspelled this one as well. This is shapes like this. And let's update the imports. And in here, we're going to need to get the shape. Let's see if we already created this. Okay, we did create it. And it is exported. And it is not letting me import it. Awesome. All right. So, it did let me import it. I was just tripping. I'm sorry about that. Okay. So, it was imported, but it was just throwing this error. I thought it wasn't. Um, I can just read this and see it's because this is returning undefined. Nothing is created in here yet. Okay. So, what we're going to do is we're going to iterate in rever in reverse order like I said, and we're going to check the top shapes first. That's what we're doing in here. And, uh, this is going to need another helper function inside this. So, let's go ahead and comment this out for now. Okay. And at the bottom here, we're going to hit enter and we're going to create that helper function. Okay, so this is going to be a switch statement. And so we're going to check here is the point in the shape. We're going to put this in here. So is point in shape. We're going to put the point and the world point here. And it's going to put it into that switch statement right here. And it's going to check if that point is inside that specific shape. Okay. And uh all right, that's it. So let's jump in here. And also each type each shape type will also have its own type of logic, right? It'll have its own type of hit testing logic. So first thing I'm going to say is is point shape and this is going to be equal to not this function actually yes it's going to be equal to this function and this needs a point first which is going to be of type point and shape which is of type shape and this is going to return a boolean. Now in here I'm going to create a switch statement. Okay, just like this and the switch is for the type. So the first types I'm going to check for which go together are the frame rectangle ellipse and uh generate UI. Okay. And then if this is true down here we're going to return we're going to remove this remove this here as well. We're going to say return these specific points. So please just pause and type this with me. And then um and essentially what we're doing here is for rectangular shaped objects right uh I think this this is also technically considered as a shape a rectangular shape right but uh we're basically just sending those bounding rectangle points that's what we're doing okay and then we're just going to check if it's within those bounds that's pretty much what we're doing so if point x is within the shapex right that means it's within okay Next for free draw. So for free draw we're going to do the same thing. We're going to check if the point is near any line segment. Okay. Now obviously this is more complex um because of it's a freehand shape and they're made out of numerous points right multiple points and so it is going to be a little more complex. So first let's create the case for that. Okay, we're going to call this free draw. And then we're going to say threshold five and four each of these where the shape shape.points.length. So based on the total number of the length of points we have minus one, we're going to do I ++ and then we're just going to find the distance. Okay, that's how we can check if the point is near any line segment. This is just some mathematical stuff. Don't worry too much about it. Okay. So go ahead and copy this word right here. And I'm going to scroll down here after this function. So after this point in shape function which is after the blue bracket right in here. And I'm going to I'm going to essentially create this. So const this is equal to an object like this. Looks like I made some kind of an error here guys. What seems to be the error? Okay. Looks like I accidentally deleted another bracket. So just put the curly bracket as well and then that should solve your your error. Okay. So now let's scroll down here after this blue bracket right here. And then I'm going to say const this is equal to an arrow function. And this arrow function is going to take in the following points parameters. So it's going to need the point line start and line end. So we can find out if it's next to that. And now all this function is going to do is we're going to calculate the distance from this point to that line. Okay. And uh this is the hit testing whatever I guess that's the terminology the hit testing for lines and free shapes. Okay. So yes this is another mathematical function. So things may not make any sense uh because it's just math. Okay. I hate math but this is just what it is. Okay. All right. So now down here I'm going to say this has to return a number. And next I'm going to create points A, B, C, and D. Okay. So in here we're going to create those points and we're going to pass in line start minus the point X line Y start minus point Y and so on so forth. Line end whatever whatever. Okay. And now we're going to create dog uh sorry dot. So how do we figure out the dot which is essentially a * c plus b * d. That's the formula. Okay. So I'm going to say dot and we also have to uh create uh calculate the length of the sequence. So I'm going to say c * c and d * d. Okay. And then after that down here we're going to just we're going to say pram is equal to -1. And if the length right if this length sequence length is not equal to zero then we're just going to do another mathematical calculation and assign that to this pam right here. Okay then we're going to create two more variables let xx and y and then in here we're going to say if pam less than zero then we're going to assign xx to the following y to the following. If it's greater than one then we're going to assign this else we're going to assign it to this value. Okay, awesome. Then finally at the bottom here we're going to say const xxx and dy sorry dx and dy is going to be the following points. Okay, so go ahead and provide this as well. And then after that we're going to return math.square of the following. Okay, I know it's a lot of math. You probably didn't sign up for this but it's all going to pay off. Okay. So now let's go back up here and that should solve this bug right up here. Okay. So now let's continue. So after this section we're essentially saying find the distance to line to line segment going to return true here. But if not we have to return false. Okay. So we have to do that as well. Then we have to do for arrow and line. Right? So let's create those two cases as well. So arrow and line down here. And then for an arrow line assign uh for error and a line essentially we're just going to check if the point is near this line. Okay. And we can use that threshold. So we're going to create a threshold just like what we did in here. So we uh we essentially use a threshold to make the line easier to click on. Okay. So we're just going to create a slightly more think about it as like padding kind of like that. Okay. So I'm going to say const threshold equal to five and then we're going to create a for loop. So I'm going to say for loop like this. Also, it looks like threshold was created inside the same. Okay, so this we're not going to call this threshold, guys. We actually have to give this a different name. So, uh let's call that line threshold. Okay, so I'm going to say const line threshold. We're going to set that equal to 8. And then we're going to do the following. So, I'm going to say distance to line just like this. Distance to line. We're going to pass in the point. We're going distance to line segment. We're just calling this again. And we're passing in all the properties that it needs. So point x y and the end line as well. Okay. Nice. And then after this we're going to hit enter. And now we're going to create the case for text. And for text um essentially we're going to use like an approximate number, right? An approximate bounding client. I think that's what it's called. And it's going to create a little box that which is the approximate around that text with a minimal clickable area. So maybe a small uh maybe 20 30 pixels, right? 20 pixels wide. And so uh text shapes and uh text shapes need special handling because they can be really small. So that's why we're creating this um this room for it. Okay. So what we're going to do is we're going to create around 100 pixels worth of text width. So in here I'm going to say text width is math domax and we're going to say shape.ext.length times shape.font size into 0.6. So the longer the font size the bigger this this uh this thing gets. Okay. The big I guess the bigger the font size. Now let's create the text height. So I'm going to set the text height to the following. And then I'm going to create some padding. So I'm going to accommodate for the So in the design we're going to do px and py, right? We're going to do some padding in there or maybe p just regular padding and so we got to accommodate for that. So padding equal to 8. So we can remove that from here. Uh we can add that into this and then we're going to return the following data. So I'm going to say return these based on this condition. Okay, very similar to this but in here we're returning something else. Okay, for the text specifically. Now let's remove this. There we go. And by default we're going to return false. That's pretty much it for this. Okay, if that was too confusing, I am so sorry. This is a very ambitious project. I hope this gives you some valuable knowledge. Okay, this is how to build a website builder from scratch. Okay, you guys wanted it so I did it. Okay, now the next section is uh animation. So I think uh we already had something related to animation. Oh, not yet. So we added this thing called get uh get shape at point. So we have to create that, right? So what we're going to do is we're going to go ahead and uncomment this. So we can now use the point in shape and uh it needs to return something, right? That's why we're seeing this error. So if this um if this point and shape so if the shape is inside the world point, then we're going to return that shape. If not, down here after the purple bracket, we're going to return null. Okay? And this shouldn't scream at you anymore. Great job. Next, in this section, after this part, we're essentially going to set some performance optimizations and some animations to essentially create a smoother pan. Okay, so the first thing we're going to do is I'm going to create the schedule pan move. And so this helps us um smoothly pan with a request animation frame. Okay, it's another like a API, window API. I don't know if you've heard about it, but uh this way you can smoothly pan it. Okay. And this prevents the panning from becoming choppy because it's trying to use the browser's animation loop. Okay. So, don't worry about it. I know it sounds too crazy, but it's just a way to improve performance. So, the first thing we're going to do is I'm going to say const pan like this. Okay. I keep forgetting you guys are actual developers. Okay, never mind. So I probably don't have to keep saying that again and again again which is I feel bad that I mean I don't want it to be too technical cuz you might have thought it's a very very easy project. It is easy right? It's a simple project but uh there are some complexities and this is the only complexity. Okay we have something similar to this but we'll be fine. Okay that's why I'm just mentioning that. So next let's go ahead and create that pan mover uh that request automation frame. So first we're going to check if the pan uh the pan ref right has something stored and if it doesn't have something stored we're going to return null. Now if it does have something store then stored then we're going to say panref.curren is going to be equal to window. Let me make sure we also have use client for this. I think it would make actually it's already running inside a client component because it's a hook. So, I don't think we need to do all that stuff. So, let's just go down here. And there we go. So, we're going to say window.reestan animation frame. And we have to we don't have to pass in anything in here. We're just going to create an arrow function, a callback function. And inside this callback function, I'm going to set the current to null. And I'm going to set the next path, so the next value to the following. Okay. Point ref.curren to that new ref, new area. And then we're going to say if there is something in here. So if there is next then we're going to dispatch and we're going to fire the pan move function. Now where do we get this from? This comes from our redux store. So let's go ahead and grab that. Let's import it. Awesome. And if you want to know where we created it, we created this inside the use sorry inside the uh inside the slice for the viewport slice. Okay. Now after this section uh that's pretty much it. So this is going to help us move the browser. Okay, move the canvas. Now the next one is freehand ticking. So this is essentially as we're freehand drawing, right? Uh we want to control the frame rate of the dots and you know the the refreshes and stuff like that. And this way it it prevents from like a really laggy experience. Okay. Now, there's more enhanced, I guess, um, an enhanced approach to this. It would have just taken forever and it's going to be more math. I don't want to bore you, right? This is still good enough. And so, this might cause a little bit of tiny little dot dotted guides or dotted lines, right? But that's that's okay. I'm sure you can go in there and ask AI to tweak it for you. Okay. So, first thing we're going to do in here is I'm going to say const freehand tick is equal to the following. It's kind of like game development if you guys have done that before. So, um first we're going to say now is performance dot now. Okay. And this is again window API so you don't have to worry too much about it. And now in here we're going to say if now like this minus the last freehand frame ref current is less than an interval millisecond number which we're going to create in just a second. But I'm just saying if it is less than that then we're going to do something in here. Okay. So let's scroll up top and I'm going to just create this in here. Usually I put that in inside a constant file but um it should be okay. So down here if that is true then we're going to check if the free draw point ref.length is greater than zero. If it is greater than zero that means they actually wanted to change something. So then we're going to force render. Okay. So we're going to say request render and we're going to invoke that. And that's where that's why we needed to create that. Okay. And then finally, we're going to say last freehand.curren equal now. So we're going to set it to that new value. So let's go ahead and set that. Awesome. And then after this down here, we're going to check if the drawing ref so the drawing refist. And if it does exist, then we're going to fire off um the animation. Okay, which is request animation frame. So I'm going to say drawing ref.curren. If this exists, then freehand ref.curren equal to window dot request animation frame and we're going to pass that in here. Okay, hope that's making sense. So, it's kind of like a little loop. Okay. Um All right. So, now let's proceed forward to the next section. Now, we're going to create the wheel events. And the wheel events are essentially zooming uh into our canvas. So let's go and say let's go ahead and say on wheel equal to an arrow function like this. And this is going to need an event here which is of type wheel event. Okay. And then down here we're going to say e.prevent default prevent default. And then we're going to set the origin screen. Okay. So let's go ahead and do that as well. So I'm going to say origin screen is the local point from client. And then we're going to pass in the uh client uh values. Okay. Then after that we're going to say if the user clicked on control or if they clicked on command then we're going to dispatch the zoom wheel zoom as well. Okay. So we're going to say zoom wheel zoom which comes from our redux. If you remember we created this right inside our slice. So we're going to bring that in and let's go back. All right. And then down here, we're going to say else. We want to first pan the canvas. So I'm going to do the following. So pan the canvas as follows. And then we're going to say dispatch wheel pan. And we're going to pass in the following values. I thought I just imported this. Okay, there we go. Oh, that was wheel zoom. Sorry about that. And that's it for that section. So this helper can be used for panning. Okay. Can be used for essentially uh handling mouse uh mouse movements. The next one is on point down. So this is basically a pointer event. Okay. And it's mainly for when they have clicked obviously on the canvas and this is where we essentially decide which action is needed to be taken. Okay. Based on the current tool. So first I'm going to say const on point down equal to an arrow function like this. And this is also going to return. So this event right this one right here is of type react.pointer event handler HTML div element. Okay. And also guys I'm going to change this to use client because it kept throwing that error. And let's go back down here. And um like I said, this is this is just going to help us decide what action to take, right? And so first, we're not going to prevent default. So don't prevent default if you're going to click on a button or an interactive event. Okay? We're not going to do that. And uh down here, we're going to say target. So target is equal to E.target as HTML event. And this E comes from here. Okay. And then we're going to check first if it is a button or not. So const is button equal to if the tag name. So the target.tag name is button close or closest button. Class list has these as well or closest has this as well. Okay. If it's one of these, it's a button. All right. So that's why we're capturing this. Essentially, this feature here, this section right here is going to um it basically prevents the canvas interactions from getting uh interfered with all of the other UI buttons. Okay, so that's why we're not firing the uh the e E.prevent default here. Okay, so now after this, you're going to hit enter. And now we're going to say if it's not a button, then we're going to do E.prevent default. Okay, and if not, we're just going to render out a console screen. uh sorry console message saying uh not preventing default clicked on an interactive element and we're going to pass in the target. Okay, just so we know and then finally we're going to return from here. Then the next one is we're going to create the local point. So after this hit enter capture the local point and capture the world point. So I'm going to say screen to world like this. And this screen to world is another helper function which we uh created inside our slice viewport slice. Right? So let's go ahead and grab that. We're going to put that in here. And then down inside this one, we're going to essentially say single pointer reaction uh sing the single I mean this section is for single pointer interactions. So I'm going to say if the touch map current size is less than or equal to one, that means it's a single pointer single click essentially. Then we're going to say can I think this is not single click this is single pointer. I think there are two different things guys. Sorry about that. So canvas ref.curren of setpoint capture and we're going to pass in that pointer ID. Next in here we're going to say if is pan button is true. So I mean we're going to essentially create this variable to check later. So is pan button is e do.button equal to 1 or e.button equal to two. And then we're going to say pan by shift which is uh we're going to check for another variable called is space pressed right and we're going to check if it has something stored inside that ref. If it has something stored um sorry guys right here if it has something stored inside that ref uh and if not we're going to assign e.button equal to equal to zero. So true or false. Okay. Awesome. We're almost there. Okay. Okay, we're almost there. We're almost at the finish line. The next thing is we're going to check if it's a pan button or pan shift. And then down here, we're going to just set the current mode. So if spacebar, if space is pressed and it this exists, right? Then we're going to say shift panning. And that means that we're also on the pan button, right? So we're going to do shift panning or we're just going to say panning in here. Okay, we're going to store this uh mode for uh our store inside here so we can use it later. Then the next one is down here. So if E.Button equal to zero. And if that's the case, it means the current tool is a select tool. So I'm going to say if the current tool is select, then we're going to do selection movement logic. Okay? And uh this is a very complex part. So it is not going to make sense for you and maybe for me too. It's fine. Okay? You just keep pushing through. So the first one is we're going to say get shape at the point of this world. So that way we can find where they're trying to hit, right? Where they're trying to click. And then after that inside this. So inside this select um sorry after this guys right here if hit shape is true. So if this is true then in here I'm going to say const is already selected equal to selected shapes and we're going to pass in that shape ID and then after that down here we're going to say if already selected is not true then we're going to check if shift key was not clicked then we're going to clear selection and you have to import that from our slices. to go ahead and import that from shapes. And then you're going to have select shape in here. So let's import that one as well. And we're just dispatching that to the store so we know which one's being selected. Okay. Then after this blue bracket, you want to hit enter. And you want to say is moving.curren ref. And we're going to set that to true. And the moving start ref is going to be set to the world ref. Okay. Awesome. Now, this next section here is pretty much just for improvements, right? Animation improvements, uh, and performance improvements. So what I'm going to do here is I'm going to say initial shape position ref.c current equal to an empty object and uh this way we can I mean technically it is for making sure we understand where we currently stand so where we're starting from so we can create a smoother smoother movement. Okay. So like I said it's just performance stuff. And so first what what I'm going to do here is I'm going to say object.keys like this. Okay. ID for each. So through all of these selected shapes and if you don't know what objects keys are, you can look up JavaScript stuff so you'll understand a little bit more about keys values all this kind of stuff, right? And so what we're doing is we're just pulling out from these selected shapes. We're just pulling out a specific type of value and we're storing it in a different way. And I'm going to show you how we're going to do that. So first thing is we're going to say shape entity state entities at this ID. We're going to grab that shape from there. And then I'm going to say if the shape exists, then we're going to do the following. So if the shape exists, we're going to check if it's one of these. Okay? And if it is one of those, then we're going to set the initial shape positions ref to that to that specific one. So position ref.curren at that specific ID is going to be the following right here. Okay. And if else if so if this is not one of these. So at the green bracket uh sorry at the blue bracket you're going to say else if like this shape.ype equal free draw then initial shape position ref.t current at that ID is equal to the new points. Then if this is not true again then else if in this condition if it's an arrow or a line then we're going to set its position to this. So start and end like this. Okay. And then the final else right down here. Else if if it is of type X, then we're going to say the following. All right. Now, after this section right here, going to find 1 2 3 4. This bracket with a circle bracket. Hit enter. And you're going to say if the hitshape type is frame, rectangle, ellipse or the generate generated UI then in that case what we're going to do is um so I think this was basically to include only the selected shape and uh if it was not selected before. So I'm going to go ahead and pass this one in here. And then after that else if if it is of type free draw. So down here hit enter and just paste this. Okay. So else if if it is free draw then we're going to do the following. Then after that if it is arrow or line then we're going to do this right here. Okay. And then finally we have one more. So at this blue bracket going to hit enter and paste that there. If it is of type text we're going to do that. Okay. then we have an else tag. So if this wasn't the case, which was right here, if it is not the hit shift, right? So sorry, it's not the uh hit shape, then down here, we're going to say, so you clicked on clicked on an empty space. So what we're going to do is just activate the blur for the text if it exists, if it was already activated, and then we're going to dispatch clear selections. Okay? So you see how we're individually controlling every single action, right? Imagine how hard this would have been to code it all out. Okay? So it does take a lot of time and effort. So I would really really appreciate it if you did subscri subscribe because you're going to get more value like this. Okay? Maybe you may not understand this, but you got the code. You got the secret sauce. And so you can take the secret sauce and learn from it. Okay? And you can improve on it. Whatever you need to do to make it even better, that's up to you. I'm just here to deliver whatever I can. Okay. So now for the eraser tool. Now if the current tool that is selected is of type eraser, first we're going to set the current. So this one current ref. So is current ref. We're going to set this to true. Then after that we're going to set the erased shapes ref.curren. And uh we're going to just clear it directly from here. Dot clear like this. And then after that we're going to say hit shape. Hit shape equal get shape at point. And we're going to pass in the world so we can grab it. And then I'm going to say if we found that uh point then we're going to dispatch by saying remove that shape at that at that specific ID. Okay, that's how erasing works here. And then we're going to say erase shape.curren.add and we're going to pass this in here. Okay. Then else down here we're going to say the following. So I'm just going to set all of the uh we're just going to erase not really erase. I mean we clicked on nothing, right? There was no hit shape. So that means whatever was being clicked in here, whatever element we just clicked on with the eraser wasn't really an element. So there wasn't shape, there wasn't a shape at that point in the world. Okay. And so what we did is essentially just fire the on blur for the input because that probably means that we clicked on like an empty spot. Okay. Then we're going to check if it is of text uh type text. So at the bottom here going to hit enter. And then you're going to say if the current tool was text then this section right here is essentially for creating. Okay. So all we have to do is fire the dispatch. So in here I'm just going to say dispatch. We're going to import the add text from Redux shapes like that. And we're also going to sorry we're also going to set the selected tool to the select tool. Okay. So this essentially uh creates the text at the clicked location. right here. And we're auto switching to that specific tool as well. So, whatever tool we need. Okay, there we go. Now, down here, we're going to have an else statement. And inside this, I'm going to say is drawing.curren set it to true. Essentially, now we're going to start drawing a new shape. So, if it is not of a type of text, if it's not type of eraser, that means that we're trying to insert something, right? So, what are we trying to insert? Well, we got to create all the handlers, all the if statements for those as well. So, first we're going to figure out. So, we're going to say is uh drawing ref.curren is true. That means we're drawing into this. And then now we're going to set the following. So, I'm going to say if the current to if the current tool is frame, rectangle, ellipse, arrow, or line, then inside this first, let's just print a message. By the way, we're almost at the end. Okay, we're almost at the end. And then we're going to set the draft shape ref. This way we can have a preview of the shape that we're drawing before we mount. Okay. And u so we're going to create that by saying draftshaper ref.curren and we're going to pass in this object. Then at the bottom we're going to request a rerender just like this. Okay. Then finally, we're going to say else if right here, if it was of type freedraw, then freedraw point ref.curren. And we're going to set the world down in here. Okay. And then we're going to say last freehand frame.curren equal to performance.now. And then we're just going to set that request animation. Okay. And we're going to render uh request a render here as well. Awesome. Great job. We are I mean we're pretty much almost done or actually maybe not. We still have a couple more. Just hang in there. Okay. It's it's a lot. I understand. Just just hang in there. So this entire function that we were creating is the on point down. Okay. So let's scroll down here and make sure this is the on point down. Going to shrink this. And now we're going to create the next one which is onpoint move. And this is also going to be a little big. We have a lot of stuff going on in here. And then we have another function for finalizing uh the drawings, right? So convert the draft shapes that we had that we're creating right here inside this onpoint down. Converting those draft shapes into finalized shapes. So that's another function. And then we also have onpointer up on key down. These are tinier helper helper functions. Okay, so just bear with me guys. I know there's a lot of code. We got to get this out the way. All right, we're almost there. We're almost at the finish line. So go ahead and say onpoint move like this. And this is going to be set to the following. Okay, so react.pointer event handler. And we're going to pass in HTML div element. And we're going to grab the event. So the first thing we're going to do is I'm going to say con local. So I've already explained everything up here. I'm not going to explain everything in detail cuz it's pretty much the same thing, but I think you understand what's going on here as well. Right here we're essentially creating the onpointer move. So the handle uh mouse touch movements. Okay. And this is where we're essentially, like I said, where we update the shapes in real time as the user drags them over. Okay. So let's go ahead and now grab the world. So I'm going to say world screen to world and we're going to plug that in and we're going to check if the viewport mode is panning or shift panning and accordingly we're going to set that uh state in here. Then finally we're going to get the eraser drag to delete. So in here I'm saying if eraser.curren and current tool is equal to the eraser then we're going to get that point in the world. Okay. And if we found that shape and it's not erased, right? Then we're going to dispatch remove that shape so we can remove it uh remove it away. Okay. So this is how the eraser drag to delete works. Okay. So drag eraser onto it and we can remove. That's what's happening here. Next is the shape movement. So right here I'm going to say if the is moving current and move start ref.curren then the current tool is select. We're going to get some delta x and y. And then down in here we're going to do uh a pretty a pretty big operation here. This is essentially we're going to loop over all of the initial shape position refs and uh for each of them um we're essentially going to move all of them together. So I mean I'm sure it already says here we're selecting. So the current tool was a select tool. So we selected a bunch of stuff and so we have to move all of this together right along that axis along that those points. So that's what we're going to be doing in here. Okay, pretty cool stuff. So hit enter and the first thing I'm going to say is object.keys keys like this. Let me just complete this as well. And inside this first thing is I'm going to get the initial position and I'm going to say initial pointer ref current ID do ID. So we're grabbing that one and then we're going to get the shape entity uh ID as well. We're going to get the shape and then we're going to say if we have the shape and we have the initial position only then we're going to do the following. So we're going to check for that shape. If the shape is type of frame, rectangle, ellipse, the basic shapes that we have, the rectangle types, then we're going to check the type of the initial position to make sure it's of type number. Okay? And if that's true, so both the X and Y positions are numbers, then we're going to dispatch saying update the shape and we're going to pass in the ID and its new position. Next, down here after this single bracket, light blue bracket, dark blue bracket, I'm going to hit enter. And now now I'm going to check if it is of type free draw. Okay, so I'm going to say free draw just like this. And then inside this function, I'm sorry, inside this if block, we're going to essentially say for the freehand, we want to move all the points by the deltas. Okay, so I'm going to say initial position initial position.points points and then if the initial positions exist then inside this we're going to get the those new points so we can update the shape to move to that. Okay, these are for freehand tools. So new points initial shapes map and we're going to grab something. We're just going to grab X and Y and then we're going to store that in here and then we're going to dispatch this action as well to the store. So we can update our store and we're going to update the shape by saying ID patch points set it to new uh new points like this. Okay. Then down here we're going to have this dark blue bracket. We're going to say the following. We're going to say else if it's an arrow or a line pretty much the same thing. Okay. We want to make sure the start of XY and end XY positions are both numbers. Here for um these we just check the whole thing X and Y positions as numbers. Right? But these are lines. So we're going to say the following just like this. And if this is true, we're going to dispatch an action and update the shape with whatever we need. Okay. All right. Now, let's go ahead and shrink. Actually, we still have uh just a few more lines of code for this one. So, right down here where you see this purple bracket, so right below this purple, hit enter. You're going to say uh for the drawing element you're going to say if is drawing.curren is the drawing shape. So the the draft shape exists. So we have a draft shape. Then we're going to say the draft shape.curren.curren world equal to this world. And then we're going to request a rerender. Okay. And else if right here else if uh what's going on here? Let me remove this. So, else if the current tool is free, then free draw positions ref.curren and we're going to push that uh new position into it. All right. And that brings us to the end of the onpoint move. Okay. Not the entire hook. It's huge. I told you I wasn't lying. Okay. So, in here, what we're going to do now is in this section, we're going to essentially finalize all of these drawings. So, we're going to convert those draft shapes that we created into real shapes. Okay? And this is where we commit to the drawing and then we're going to add it into Redux. Okay, hope that's making sense. So let's go ahead and create that down here. So this is called const finalize drawing is equal to an arrow function. And this is going to return void. So nothing in here. And inside this arrow function body first we're going to check if is drawing ref.curren is uh not true, we're going to return. And then if the drawing and then then we're going to set the drawing ref.curren to false then we're going to check the freehand. So freehand.curren if this exists then we're going to say cancel animation frame and we're going to say freehand uh ref.curren. Okay. And that's uh we're also going to set this one back to nothing cuz we're committing to everything. Okay. Then down here we're going to set a draft equal to the draft shape.curren. And then we're going to check for the draft. Okay, we're going to check into the draft and understand uh what it is. Is it a frame? Is it a line? Or is it a free draw? Okay, so let's go ahead and first say if we have a draft, there's something inside the draft shape. Then we're going to create x uh y width and height. Okay, so two the positions width and height. And this is the mathematical formula. So just pause the screen and type this. And then down here, we're going to say if width is greater than one or height is greater than one, then we're going to do the following. So I'm going to say if it is of type frame, then I'm just going to say adding frame and we're going to dispatch that to the store. Else if it is of type rectangle, same thing. We're going to add it, but we're going to add the rectangle to the store with these properties. So let's go ahead and import that one as well. Then if it is of type ellipse, we're going to do the following. We're going to add those. Then if it is of type arrow right here, we're going to do the following. So we're going to dispatch add arrow start and the end. And we also have to do line, which is pretty much the same. So you could combine this if you'd like, but I think it's better to put it on a different line because we're using a different action, right? Sorry about that. Don't don't combine it. Okay. You can do an if inside it, but just do it this way. And then after that, um, finally at the bottom here, you're going to hit enter. And you're going to say draft shape ref.curren. And you're going to set that to null because we just committed to the design. And then we're going to have one moreish uh else if okay. All right. Elus. So um, if this is current tool is free. So right here we checked for this one. Uh okay. So this is if we found a drafted image then we're doing this. Okay. So in here if the current tool is of type free draw we have to refresh that one as well. Right. And we have to add the freedraw shape as well and commit. So we're going to say first points are equal to the free draw shape uh referred points ref.curren. So, we grab all those points and then we have to dispatch to the store to add all of the free uh draw shapes. Okay, all of those uh the free draw shapes and all of their points. So, I'm going to say if it's greater than one, add it. So, add free draw shapes and pass in those points. So, that sends this to the store. And now, obviously, we need to reset this current. We need to reset it to an empty array. So, I'm going to say current equal to an empty array. And finally, let's request that rerender at the bottom right here. Great job. You're coming so far. We're almost there. The next one, the next couple ones are pretty short. So, let's go ahead and complete those. All right. So, now let's go ahead and create the next one, which is on pointer up. So, after this blue curly bracket, I'm going to say the following in here. And inside this, first I'm going to store the canvas ref.curren uh release point capture. We're going to store that. And then down inside this I'm going to say if the viewport do mode is panning or if it's shift panning then I'm going to pan end. And this comes from our viewport slices. So let's grab that. And then in here we're going to say if moving ref.curren and if that's true we're going to set the moving ref current to false moving start ref current uh to null and initial shape position refs.curren to an empty object. And then finally, we're going to finalize um the erasing part. So down here, I'm going to say if erasing.curren, then set it to false, and we're going to clear uh that shape ref that it was trying to delete. Okay. And finally, we're going to invoke this function, which is the final drawing right up here. Okay. So, let's go back down here. Awesome. Now we're going to hit enter and now we're going to do the onpointer cancel. So this is very straightforward. This is the smallest function in this entire page. But essentially we're just going to say onpointer up and we're going to call this function here. Okay. Then the next one is for keyboard events. So for key down event right here I'm going to say if it is shift or shift right then we're going to prevent default and then we're going to handle tool enable. Okay. And this is from our uh let's what's wrong with this? We need to invoke it. Okay, there we go. So, we're essentially saying spacebar uh what is this? Keep the same ref name for consistency. Okay, so I think uh this is space pressed. We're just setting it to true because this was clicked, I'm assuming. Hm. I wonder what I did here. Okay. Um for now, just put this in here. We'll figure it out. Okay. We'll figure out the key down events later. Uh, but this is how you dispatch. Uh, and we're going to store this. So, handle tool enable. And we're going to turn this on because they clicked on shift left and uh or or the shift right. Okay. Now, we're going to need to do the key up. So, right here, key up is if it is shift left, shift right, then we're going to do the following. So, I'm going to prevent default here, and we're going to disable this tool. So, I think every time you do this, well, we're we're still going to need to fire this off, right? So, I think we'll do that in this section. I think that's what's going to happen down here. And this is where we're going to set up those event listeners and cleanup functions. Okay? And this is where we attach them. We attach those event listeners. And um we're going to do that through a use effect. So, I'm going to say use effect like this. And it looks like there's a ton of errors in here. I want to shrink this. Remove it. Just like that. Awesome. So the first event listener, first two event listeners are the key up and key down. So we're going to put put that in here. So every time we click those, I also have this. Let's remove that. So every time we click those, it's going to fire this one. Okay. Every time we uh fire this event by putting the key down, shift or shift right, it's going to fire this. Okay. And say for key up as well. Let me just look up just to be sure. So key up event. Okay, so when you leave the key, I think that's what it's called, right? So key up event is a type of keyboard event that occurs when a user releases a key. Okay, so when you release it, so let's say you hold shift, that's a key down. Key up is when you leave shift. Okay, sorry if I was confusing you there. Even I was a little lost. I was like, why did I put key up? Okay, then down here, we're going to return and clean up these functions. And in here, freehand ref.curren current we're going to say cancel animation frame and for panning also cancel animation frame. Okay. Okay. Now is another big function. Um so but I promise you this will be the last biggest function. Okay. And uh that's pretty much it. After this we're we're done. Okay. So this is essentially for handling resizing the shapes from the canvas. So, if you select something and you try to scale it up or you're trying to draw a square, rectangle, and you're trying to increase the, you know, height, whatever, this is what that use effect is going to help us accomplish. So, I'm going to say use effect like this. We're going to remove everything from here and we're going to do it from scratch. Also, uh for the dependency in here, guys, just leave this empty. Okay? Don't put anything in here cuz we only want the event listeners to mount once. That's pretty much it. So, that's why it's empty, even though it tells you to do that. Okay? You could even put a exhaustive dependency in here. You might need to do this during build. Okay, so let's go ahead and finish this section too. So inside this first I'm going to say use um sorry guys before we do this I don't want to forget I'm going to pass in the dependencies now itself okay because it's a really big function. So dispatch the entities the viewport scale and translate we need these. So, and based on that, we're going to change everything in here. Okay? So, make sure you pass those in. So, first we're going to create a handle resize start. So, handle resize start is going to do the following. Okay? So, please pause the screen and top uh and type on top. And then after that, we're going to have a handle resize move. So, let's go ahead and grab that as well. So, just like this. And inside this we're going to say if nothing is there inside uh inside resizing ref.curren and data ref.curren then we're going to essentially grab the resizable data and we're going to dstructure it. Okay. So resizable data resize data ref.curren. We're going to grab the shape ID the corner and the initial bounds. Okay. And then uh we're also going to extract the client x and client y from e.det details from the event. Okay. right here. And then we're going to convert all of our client coordinates to the world coordinates. Okay. So I'm going to say canvas ref.curren and I'm going to say if no canvas uh then we're going to return. But if everything is good then we're going to get that. So we're going to get the uh bounding client rectangle. So I'm going to say okay there we go. So canvas getting bounding client rect rectangle and then I think is it rectangle? I think that's what it is. Yes, cuz it's like a box, right? Box model. Then we're going to get local x and local y. And then we're going to like I said uh we're going to convert these client coordinates to world coordinates. So we're going to say world screen to world and we're going to pass in those coordinates. Then now we're going to calculate the new uh the new bonds the new uh bounds based on the corners okay that are being dragged. So in here we're going to first grab the shape entity shape at the entities.shape id and then we're going to say if we didn't find anything then just return and then we're going to grab the new bounds. So the new values are everything inside initial but we're going to create a switch case in here. So this is going to look like science. Okay, you ready? All right, let's go. So in this section, the first case is as follows. Okay, so even though this looks like gibberish, there is some meaning behind this. And I'm going to try my best to help you understand. First, what is this NW? It has no meaning, right? Maybe I should have renamed this to northwest or something, but this is essentially northwest corner. Okay? And uh the user is dragging essentially the top left corner. And when dragging the top left, the bottom right corner needs to stay fixed. And so the width is equal to the original width plus how much more we need to move left. That's what's happening. So it's like an illusion. Okay? If that makes sense. So that's what we're doing in here. So um let's proceed. I think this is just a math formula. So go ahead and just type this out. And then after this, we're going to have another case. And this case is for north u for northeast. Okay. So I'm going to say northeast like this. And same thing. Okay. Just a different formula. That's pretty much it. So I'm going to say new bound new b uh bounds dot width like this. Then we're going to capture it by saying height. capture the height by saying this then new bounds y equal world and we're going to break. Okay. And also guys in the c in the codebase when you purchase it you will get all of the code comments for each and every single part in this um inside this use infinity canvas hook. Okay. So that way you will have no questions or at least you will know what's going on if you need to refer to it. So, if someone else is working on your codebase, which is most likely the case, that's probably why you're buying it or that's I mean that's probably why um you need some, you know, explanation in more in depth, then you can pass this over to them and they can read that. Okay. So, now we're going to do southwest. And for this first in here, we're going to say the following. Then after this, we're going to create the height. And then we're going to create the lock. Okay, we're going to lock this in and we're going to break. So just to help you understand here, I've already explained it up here, but I'm going to explain it here once more. So here, X is going to move left. Okay, so X uh X dot sorry, X is moving left from the world. Okay, so X is going to move from the left edge. the left edge is going to move and y will stay the same which is the top edge anchored. That's what's happening here. Okay. Now, next one is southeast. So, let's go ahead and do that. So, southeast is going to have the following. Just like that. Okay. And that's pretty much it. So, now down here we're going to hit enter. So, the switch case is done for this. And then down here, the next thing we're going to do is so shape specific updates that we need to perform when they're being dragged and resized. Right? So, uh different shapes need different handling obviously. And so, a simple shape like a frame or the rectangle that we have or the ellipse um this just needs uh for us to update uh the bounce. That's pretty much it. Okay. And so, that's what we're going to do in here. So, let me go ahead and grab this as well. So first thing I'm going to say in here is if just like this. So if the shape is frame rectangle or ellipse, we're going to dispatch update shape for that shape ID and we're going to pass in the new bounce. Okay. And then after that else if so if this is not this shape and if it is a free draw then again this is going to be a little bit of a complex action. Okay? Because we need to scale every single point. That's what's happening. Okay. So, freehand drawings are made out of individual tiny little points on the screen, right? And so, proportionally, we're going to need to scale that. And so, you can imagine what the math is going to look like. Okay? So, first we're going to do uh the actual drawing bounds. We're going to grab them without any of the padding. So we're going to say xs and ys is equal to we're going to find those points and we're going to map over them and we're going to return px and p y and then down here we're going to get uh another set of variables. So please go ahead pause and type these out. And then after that we're going to calculate the new the new area the new bounds. Okay removing all of the padding. So just like this minimizing and removing the padding from here, right? And then we're going to calculate uh the scale factor. So how much do we have to scale them by? So if the actual width is greater than zero, whatever, whatever. Okay. And then we're going to scale uh all the points proportionally. So scale all the points with that specific proportion. Then we're going to hit enter here. And inside this, we're going to dispatch to update that shape with the new points inside inside our store. Now, if this is a line or an arrow, then we're going to do the following. So, because this is a line, an arrow and a line, they're pretty much the same character, right? Um, they are going to have a start and an end point instead of the bounding rectangle. So, we're going to treat this slightly differently, obviously. So, we're going to have a different formula. Okay. And uh since like I said, they're defined by starting and end point, there's no height. There's no height and width for them. So we essentially need to map these new bounds, the new location uh back to the start and the end ending coordinates. And so for that, first we need to calculate the actual location, right? So I'm going to going to do the following like this. It's pretty much the same as above, but just slight bit different formula. Right? And now we have to calculate the new one. And we have to remove any padding. So we're going to remove padding here as well. And then we're going to map the start and the end points to this new bound. So in here, let's hit enter. So we have more space. In here, I'm going to say let new start x, new start y, end x, and end y. So the new location is going to be as follows. And then if the actual width is zero, right? That means it's a vertical line and only height needs to change. Width will stay centered. So we're going to go in here and we're going to say the following. Okay. So new the new points are going to be just like this. And the same thing for the start. So that was for start Y and start and new end Y as well. Now if the actual height is equal to zero then inside this it's a horizontal line. It's not a vertical line. So only the width will change. So height will essentially stay centered. So in here we're going to do the following. And we're going to grab this real quick. And then we have a diagonal line. So this is going to need to scale proportionally. Right? So I'm going to say else like this and we're going to do the following. Okay, awesome. Now after all of this, we need to update our store with the new information. So after this curly bracket, hit enter. We're going to dispatch to update the state. We're going to pass in the new state and the new the new points that we just created. Okay, awesome. And we're almost at the finish line. That's like that was the biggest part of this entire project. Now there's still more because now we have to focus on saving all this important data so that nothing goes crazy. We have to focus on all the other stuff. We have to look at it, test it, all of that. Right? So let's go ahead and uh almost let's just wrap this up real quick. So down here we're going to hit enter after this dispatch. So 1 2 3 4 5 hit enter. And now we're going to create create the handle resize end function like this. Okay. And this is going to set the following just reset the values. And then we're going to have some event listeners. So we're going to say add event listener for shape resize start move and end. Okay. We're going to create those. And the handlers are what we just created. We're going to pass those in here. See handle resize move. That's being passed in here. Okay. And then after this, we're going to need to clean it all up. So, let's go ahead and pass in the cleanup function that just returns these handlers with the same callback functions in here. And that wraps this section. Uh, I mean, not just the handle resize move. So, let's scroll down. Okay, we're almost there. Promise you we're almost there. Now, the next one is we're going to need U. Um, so outside this guys, hit enter here really quick. We're going to create an attach canvas ref. So this way we can connect all of our uh all of the elements that we're creating to the DOM. Okay, so connect to DOM elements. And uh this essentially connects our hook. So everything this is like the main part where we're connecting everything. So this is what connects our hook to the actual canvas DOM elements so that we can listen to all of these elements. Okay. So in here we're going to say attach canvas ref and I'm also providing some references here but you can see inside the real codebase you're going to get a ton of uh comments espec especially for this section right so we're going to clean up event listeners on the old canvas clean it up remove event listener for wheel and uh for canvas ref we're going to remove that store a new canvas ref so we're going to pass this in right here and u then for add wheel event listeners to a new so add wheel event listener to the new canvas for zoom and pan. Okay, so that's what we're doing in here. Okay, so now we have this function. So we're going to hit enter here after this blue bracket. Hit enter. And in this section, we're essentially going to uh going to control tool calls. So in here, I'm just going to say select tool and we're going to dispatch set tool to our store. Then we're going to uh essentially get the draft shapes data and we're going to store it in another helper and that's going to give us the ref. So I'm going to say get draft shape and it's going to return that ref that we need and we're also going to do the same for the free draw drawing points. Okay, then now we just need to return every damn thing. Okay, so just give me one second. I'm going to return it and I'm going to show you how to how to structure that. All right. So there we go. Go ahead and return all of these with me. So viewport the shapes list. And so essentially what we're doing here is the first section is the state itself. So all state related stuff. So the current tool, the selected shapes, the list of the shapes, the viewport, all of that information. Next is the handlers, right? The pointer handlers. So event handlers for stuff like interactions. And then we're going to have the helpers. So these are things like attach it to the canvas, select the tool, uh hide the sidebar, all that kind of stuff. Okay, so these are like utility functions for the components. So everything is built to scale. You just have to add to this and expand on top of this. Okay, that's pretty much it. That was Oh my god, that took forever. And I'm so so proud of you if you have come so far because that shows that you are ready to start your own SAS soon. Okay, so let's go ahead and I'll see you in the next session. Now, go ahead and open up your folder structure and you want to open up the zoomindex.tsx file, okay? Because that's where we're calling this hook. But now, we have to change this to a client component. So, let's go ahead and bring that in as well. And let's make sure to refresh the browser. Okay, awesome. No errors. That's a really good sign. Okay, and we can see something here, I think. Oh, sorry about that. Okay, so the next thing we need to do is uh probably mount these. Let me see why it's flying around. Okay, give me a second. All right, we're all good. It's the the reason why we're seeing that is essentially because we haven't put the center toolbar, right? And so it's it's just putting this somewhere around here. So you're good. We we don't have to worry about too much. Let's uh keep pushing through. So now we have this. Let's bring this back. Let's remove this. And now let's import our dispatch function as well which comes from use dispatch. So let's import this just like that. And then in here we're going to also need to create our handle zoom in. So zoom in is pretty much the same except it's going to multiply by 1.2 and we're going to put the maximum minimal scale. And the same thing for this like I said uh multiplying but max scale. Okay. And that's it for these helpers. Let's just quickly build out this toolbar. So, we have the zoom out and it uses the handle zoom out. And now we need something in the center here to see the number. So, what are we zoomed in at? So, at the bottom here, I'm going to create a div and I'm going to put the number. So, there you go. Now, we are at 100%. Right? And then finally, we're going to create another button in here. And this button is the zoomin button. Okay? And this is going to have the following styles for the button. Just like this. And it says zoom in. And this is attached. The on click handler is attached to the handle. Zoom in. Now for the moment of truth. If things are working and if I click on this, this should show 120. Okay. Let's go. Okay. Oh my god. Okay. So, yeah, it's just doing math under the hood and it's just zooming in. Um, so yeah, I think we crushed it. We did a good job. Okay. So, let's go back and let's bring this back here. All right. All right. So now we're going to go back into our index.tsx inside the toolbar right in here. And now we have to create the toolbar shapes. So what I'm going to do is I'm going to create this component. I'm going to copy this name. Open up my uh folder structure. And then we're going to go into the toolbar. And inside the toolbar, I'm going to create shapes index.tsx. And let's return a snippet like this. And now let's remove all of these props. Okay. And so now the first thing I need is a set of these types, right? Which is uh sorry, we're going to have an array of all of the all of the the values that we need to return the toolbar settings. And so I'm going to go ahead and create these tools. Okay. So as I keep importing, please pause the screen and type these. So it's we're going to need each tool is going to have these properties. We need the mouse pointer too. So this is what that is. We have the frame. We have a rectangle circle pencil tool. Arrow right minus type and eraser. Now the good thing is that we have created the entire hook. So we don't have to go back and forth too much into that hook. So, the thing that we need in here first is actually let's go back to our index file and let's import our toolbar shapes and let's make sure we refresh this. Okay, there we go. And there's some sort of an error here. Let's just fix this up real quick. Okay, looks like it overrode itself. Let's go ahead and import these once more. Give me a second. Okay, awesome. There you go. Now, if you open this, you see it's going to be towards the end. Okay, that's what we wanted. So now let's go ahead and remove this. So first thing we need is the current tool to know what's being selected and the selected uh the select tool as well. Okay. So let's go ahead and import this from use c use infinity canvas. And then we're going to replace this with a div just like this. And we have to mark this as use client. So let's do that as well. And inside this div, we're going to hit enter. And this div is going to have another div inside this div. And then inside that we're going to loop over all of the tools. For each of them, we're going to render out a button that comes from components button. And then that button is going to have key variant size and on click, which is going to be the select tool itself. Now, this looks like glass mode, like whatever you want to. I think that's called uh Apple glass UI, right? We try to have the same vibe, but we can't really do it. Okay, you can't do it in the browser. Um, it doesn't refract light, but it does blur out the light a little bit more. And it is it's not just a regular blur. Okay, it's slightly enhanced. Okay, so this does have this nice glass UI. So if something was inside the canvas, it's going to show there. Okay, you can see it underneath. All right, so for each of those, we're also going to pass in a class name. And that way, we also have a hover for it. You see it has this cool hover animation. Let me shrink this. There we go. Hover. And we also have the select tool right here. Okay. So, the select tool is being passed in on the on click with the title in here and the description. So, uh we have the title and description. So, if you hover over this, you can see what that is. And then you also have the tool icon. Okay, that's pretty much for the tool. Awesome. Now, let's go ahead and open up the page.tsx inside the canvas folder. And then inside this, we're going to essentially first grab the search params from our props. And then we're going to need to dstructure them and capture them in here as well. And now let's go ahead and await these props in here. So I'm going to call this params like this. And then in here, first thing I need is the project ID. So I'm going to grab that from it. Okay. And it's still returning pager. That's because we have something in here, right? So after this, if there's no project ID, we're just going to return saying no project selected. Then we're going to fetch the project data server side and we're going to render that. So in here, in order to do this, we're going to say project and profile. We're going to use our project query that we created and we're going to pass in the project ID. Okay, I think there's some error here. Let me see. All right. Sorry guys, we don't have to import. So this is project query. This is not projects query. So it's slightly different, right? Because we're going to pass in a project ID in order to get uh the project. So go into your config query config file. And below this, I'm just going to create the project query is an async function that takes in a string. And it's going to essentially first get the profile and then we're going to normalize that. If nothing is there, return null. And then we're going to preload all the project data into this based on that specific projects get projects query. Okay. And we're going to return the data back. Now let's go back in here and let's import this. And that should solve this bug. Okay. Awesome. So now if there's no profile data, now what do we do? Well, we're going to return authentication required. Okay. And you should definitely send the user back to the to the login page. But then after that um if there is no project we're going to say this is not your project you don't own this project and access denied. Okay then down here we're going to return this component with the pro uh projects provider and we're going to pass in the initial provider the and the initial data directly in here. Okay. So um it's saying something is incorrect here. Okay, initial project should be project. What's going on? I think I missed a bracket or something. All right, give me one second, guys. Ah, sorry about that. I actually forgot to create the provider itself, right? So, let's go ahead and search for this provider just to make sure. Okay, there we go. So, I haven't created it. So, you're going to open up your folder structure. You're going to go into components projects. you find list in here and you're going to create this inside this project itself you're going to create provider and inside that an index.tsx and I'm just going to return this project provider like this and this provider is going to need the children and the initial project. So let's go ahead and set that and then obviously let's dstructure hello cursor. Okay, there we go. So let's dstructure that data. And then in here first we're going to grab the use dispatch. And the reason why we're doing this is we're going to essentially pass down the data and then push it up to the store from here. Okay. So we're going to grab use dispatch. I don't know why cursor is so focused on this. Focus on where I am. Okay. And then we're going to have a use effect. Okay. So this use effect is going to do the following. So if there's any data, so if we pass something in and it has value.json sketches data, then we're going to grab that and we're going to load the project into the store and pass in the sketch data. If uh the project data viewport data, so viewport positions are also available, then we're going to set that as well. Okay, so we can kind of focus onto that design. And then finally, let's return the children items. Now let's go back one page. So I'm going to go back in here and inside this now I can return my projects provider. So at the bottom I'm going to say project provider and we're going to pass in this new component that's going to come soon. And uh let's refresh this. Okay. So since this provider component is using use effect well you need to make it a client component. That should solve that error. Awesome. And now let's go ahead and uncomment this. Let's copy this name and let's go ahead and create this Infinity canvas component. Go ahead and copy this title here. You want to scroll down to components and then inside this you're going to find the toolbar component. Right. So inside that I think we should place this. Actually we could find a better place for this. Okay. So inside this we have this canvas. Right. So inside that I'm going to create an index.tsx. tsx because this component is the main canvas here, right? Like this. And let's go ahead and return a react snippet. Now, this component is going to need to become a client component. So, let's go ahead and do that as well. And in here, first thing we need is that crazy hook that we created. So, let's go ahead and import that hook. And also, let's import this infinite canvas component. Okay, I was kind of afraid for a second because I saw an error. There we go. That was that was just uh something of because it couldn't find these uh the module pads. Okay, so once that's done, the next thing we're going to need to do is down here, I'm going to remove this and I'm going to create a React fragment. And inside this React fragment, we're going to return a component called text sidebar. Now, this is a custom component. So, open up your folder structure. inside the canvas and you're going to create the text dash sidebar. Now, this we might not see right now, but it's essentially whatever I guess uh very similar to something like this. Okay, very similar. The colors might be a little different, but it's going to look like this. And so, you practically have the knowledge to create something like a website builder, right? Awesome. So, hey, look at that. If you had never subscribed, you'd have never found this video. You would have never learned the skill and you probably wouldn't have started a SAS like this. How cool is that, right? So, go ahead and return a React fragment. And we're going to call this text sidebar. And let's go back and let's also import the text sidebar component as well. And now inside this, the first thing is this is going to need an isopen property. And this is open property is going to come from here. So, let's go ahead and grab that. And the first thing we're going to do is down here is we're going to return remove this div and we're going to return another div. And this div is going to have the following class names. And we're going to use the CN function here to essentially show this. Okay. So, just to show you, it's going to look like this right here. So, if I click on it, it's going to open up. That's pretty much it. Okay. Let's put something in here so I can show you a little bit more. There you go. All right. We'll get to that in just a second. But um let's remove this. And so the next thing is inside this div, hit enter in here. We're going to create another div like this. And inside this we're going to create one more div. Now this div is going to have a label. And this label is called font family. Okay. So let's bring that in. All right. There we go. And let's open this up. All right. Okay. So, we're not able to see it. So, what I'm going to do is I'm going to set this to true for now. And I'm going to say todo remove is open. Okay. So, now you can see whatever is inside this. How exciting. Okay. All right. So, after that, we're going to need to create a select item. So in here I'm going to say select. Don't worry about it if it looks crazy. It's just because that's how Shats and UI does it, right? They have all these tiny little components and then you build everything together um within each other like this. So let's go ahead and just import this. All right, there we go. Nice. Forget about this for a second and forget about this stuff. So it's a select component and this select component is going to have a few trigger values. We're going to pass in the select value and inside that we're going to return a select item inside the select content and then for each of those like I said select item with a span which is a font type. Okay. Now how do we get this? So the first one is the update um text property. So let's go ahead and create that function. It's just a very tiny helper function up here. So I'm going to say update text property is going to need the text shape which comes from slices. And in here we're going to check if the selected text text shape is non-existent and obviously we don't have that. So if that is null then only then we're going to proceed here. So before that I obviously need to store that state. So let's go ahead and create those states that we're going to need. So the first thing we're going to need is that select state select shape. And the next thing we're going to need is this one which is the uh the shape entities which comes from our store. And we're also going to need dispatch. So like you can see in here essentially what we're going to do is update text property if uh all right I didn't even create this. Sorry guys. So selected text shape is we're going to need to map over the entities. Right? to map over the selected shapes and then we're going to find the shapes at that entity at that specific ID and we're going to find for where it says text and then we're going to check if there is anything in here right so if there is something then what we're going to do is we're going to dispatch to the store we're going to update that state and we're going to pass in uh the that value okay now what's the value the value is essentially this right here. So, whatever was selected from this drop down. Okay. Now, if this is not opened, right, we're not opening this and we're not showing anything, then we're actually going to hide this. So, we're just going to return null here. Okay. And this needs to be use client and let's import use dispatch. There we go. So, now we can hide that. And uh that's because nothing is being selected. Okay. So if I uncomment that, we're going to see this error because nothing exists inside the selected text shape. So for now, I'm going to put this and okay, obviously it's going to throw an error here because we don't have the font families, right? So what I'm going to do is I'm just going to create a set of these. And you can create whatever you like, but I'm just going to put these font families in here. Okay, font family in here. And then I'm going to loop over all of these fonts and I'm going to render them down here. And for each of them, I'm going to show the selected uh the selected value. Okay? And it also applies to that font. So if I click on it, you see there you go. So let's refresh this. Okay. And nothing is saving by the way right now. But it's it applies this font style. Okay. Then after this, we're going to hit enter after this div right here. And inside this section, we're going to create another div that's going to essentially say slider from components. Okay, we're going to bring that in. And uh in here, we're going to put the font size. And so we need to get the selected text shape font size. So let's bring that in, too. Uh okay. All right. There we go. And this one here, too. And it's saying something is wrong. Okay. That's obviously because we don't have that value stored right now, right? We don't have that value, so we can't see those shapes. But um that's fine. No problem. We'll go ahead and still proceed cuz it's still straightforward stuff. This is not too complicated, right? So here we'll essentially render out the selected shape. And then we're going to render out the next section in here, which is another div after this. And this div is for the font weight. Okay, the weight. And you're not going to see that too, but you can assume it looks something like this, just as an example. And then after this, we're going to create another div. And this div is going to have all of the font uh designs like bold, italics, that kind of stuff. So, here's what I'm going to do, guys. I'm going to show you how to do this, and then you can create whatever properties you want, okay? Just to save you some time and save me some time as well. And so the first thing you need, let's just go ahead and create the next one so we can walk through that together. Okay, so the first one you're going to need is this right here. First you need an event, some sort of an element. Okay, so if that element is what do we have here? We have font way, right? The weight and this is 700 which is the bold item right here. Okay, so this is using a toggle and this toggle component comes from components UI. Okay, it's a newer component. I believe it's uh I think it's a it's um built out of the button element. And so what we're going to do here is if this is pressed, we're going to select that. Okay. Now, how do we select that? We're going to fire this update text property function right here. Okay. And we're going to pass in the property and its value. That's all you have to and you have to dispatch that to the store, send a patch and you have to put the property and its value and automatically that's going to append onto the elements. Okay, that's how powerful this is. So, same exact thing here. Okay, let me go down here. Where is that? Okay, and we just have to pass in the font way pressed if it's true 700 if not the default. So, same way I did did the same for italics. I did the same for underline. I did the same for line through for every single thing you see here. Okay. So, you can create pretty much I mean this is an Excaliraw clone. If you just remove this has Excaliraw into it, right? So, if you just remove the uh the website development part, worst comes to worse, you end up with Excaliraw and you can still make some good sales. Okay? You just got to you got to focus on uh promotion and marketing, but apart from that, you'll still crush it. So, all right. Now these are all going to throw errors. So what I'm going to do now is I'm not going to waste too much time. I'm going to copy and paste whatever I have done and I'm just going to show you the last one here which is the text color. Okay. And um so let's go ahead and let's refresh this. Okay. So text sidebar. Okay. Something is wrong here guys. Just give me a second. Okay. It was just the export and that should solve that bug. So now because nothing is showing, we're not selecting any text. We're not going to see that. Okay, we can't see that on the screen. So we will eventually, but that's the reason why we can't see that sidebar. Now, just to show you the final element down here, which is the class of the uh the text color, we just say pallet here. And this palette comes from uh this is the Lucid React, I believe. So okay, this yeah, this is Lucid React. And then we're going to have an input element that has the handle color change. So you can put a color tag in here. And down here we're going to have a div that renders out the color. So similar to this. Okay. So we can show the color. And there's so many other things that you can do. Go ahead, knock yourself out. This was just an over complicated design, right? You can't have size and also have font size. Like it doesn't really make sense, right? But um we did as much as you actually need. Go ahead and feel free to create as much as you want. Okay. Now, we're going to go back and after the text sidebar, then let's go ahead and scroll down here. I'm going to create a comment here and I'm going to say inspiration and I'm going to create another one called chat window. Okay. And then down here, what I'm going to do is I'm going to create a div. And inside this div, the magic happens right here. We're going to attach a ref. And this ref is called attach canvas ref. Okay. So attach canvas ref like that. Awesome. And then we're going to give it a role. So this role is called application. We're going to give it area label. We're just going to say infinite canvas. Infinite drawing canvas. Then we're going to give it a class name. And this class name is going to be as follows. So please pause and type. And this uses CN as well to get some states in there. Okay. And now we can test one of the first features which is zooming in with the scroll up. Okay. So if you zoom in now I'm on a trackpad and it still works. You can see the number here. It actually changes. Okay. I'm zooming into the screen and it's actually changing. So that means this feature is working. Okay. Awesome. Great job. And these class names right here. look at if we're panning, shifting, or whatever that is. And it's going to add some extra class, uh, some design, some styling over this. Okay. Then I'm going to say touch, touch action, uh, with the style prop, set it to none. And we're going to pass in all of our handlers that we created into this canvas. And then we're also going to pass the context menu, which is essentially going to prevent any default actions. Okay. And then we're going to set dragable to false because this does have drag and drop functionality. Right? Then we're going to create another div. So I'm going to say div. And this div is going to have a class and it's also going to have a style. So let's go ahead and say class name with the following styles. And we're going to say the following right here, which is viewport.t translate. All this kind of fun stuff. Just go ahead stop uh pause the screen and just type it out. Okay. And then we're going to render out a component called shape renderer. So based on the number of shapes we have, we're going to map over them and we're going to render out this component. Okay, that's pretty much it. So let's go ahead and say shape shape renderer like this. So shapes.map dot uh and we're going to return a renderer. And let's copy this. And let's open up our folder structure. And inside this canvas, you're going to find the shapes, right? So, actually, we don't have it. So, shapes like this. And you're going to create an index dot. Let's actually redo this. An index.tsx. And inside this page, let's go ahead and quickly return the shape renderer component. And this needs a couple props. So, I'm going to grab that as well. We're going to set um actually let me do it directly in here so I don't have to retype this. So it's going to look like this. And the types for each of these are as follows. There we go. And so shape toggle inspiration toggle chat all that kind of stuff. Okay. Then we're going to have a switch case. And based on the switch, we're essentially going to return a frame, rectangle, ellipse, stroke, all of those elements that we created. Okay. So in here, remove this return statement. We're going to say switch. We're going to remove all cases. And in here, for the first case, I'm going to say if it is of type frame, do the following. Actually, let me just copy this once and for all so we don't waste time. And we're going to import these. Now, obviously, these are custom components. Okay, we're going to create them in just a second. Don't uh import them from another icon folder or something. And here's what I'm going to do. So, just give me one second. Okay, so I'm going to provide a folder that will be accessible inside the YouTube kit, which you can grab from the discord. Okay, I'll provide all of this uh that I told you guys that I will part of the YouTube kit in the discord itself. So, go to the discord and you're going to find a folder. Okay, this folder is called shapes. So, here's a little, you know, uh, I guess surprise for you, a little gift for me to you. Okay, I don't want you to sit and type all of this. That's going to be a pain and I really don't want that for you. So, what I'm going to do now is I'm going to copy this shapes folder. There's only one thing that I cannot provide in here because it's a it's a dependency of something else and that's like a whole bunch of stuff. So, that's not going to be a part of this uh folder. But that's okay for now. you're going to find a shapes folder and it's going to come with first the arrow. So I'm going to copy paste that and it's a very simple component that looks like this. Okay, it's just an SVG that has some stuff on it. Okay, it's just useless com like math and stuff like that and it's also going to have a preview version of it and it might just be a little lighter I believe. I think that's the only difference or maybe I'm not maybe I'm wrong. Okay, sorry about that. So, um, then let's go ahead and import the arrow from our components folder. Okay, just like that. So, now I'm going to have the arrow. Next, I'm going to copy the ellipse tool. Then, I'm going to copy the frame. Then, I'm going to copy the inspiration. Uh, actually, we don't need that in here. We need the line tool. See, we have line in here. Then, we need a rectangle tool. So, I'm going to copy the rectangle tool. And they're just indexes with previews. That's it. Okay. And then we're going to have another uh element called stroke. So, I'm going to bring that in too. And then finally, we're going to have the text. So, text also is rendered in here. So, let's bring that as well. And this is just like an input field. Okay? It's nothing crazy. It's just like a way to show these elements on the screen. And they are just input fields and they are simply being rendered. That's it. They're just being rendered on the screen. And their types, that is the shape, the positioning, the line height, all of that stuff comes from the props. We're passing this in. Okay. And that's what we're doing for all of the elements. You can see it right here. So now I'm going to go ahead and import all of these. So go ahead, pause this video, import all of this, and let then let's continue. And with this component, you're going to get uh with all these components that I'm going to give you for free, you're also going to get this one component here, which is a liquid glass component. Okay? And that you want to put it under the buttons folder right in here. And it's just another button that has a bunch of props like on click, disabled, and we're just passing it down in here. And it has some uh liquid glass like vibes. Not saying it is, okay, I tried my best. It's just a background blur. Okay, that's pretty much it. You can read it. Okay, you can read and see what it does. Uh, it does does I mean it does refract a little bit because of the wave we have set it. That's pretty much it. Okay. Okay. Now, I've gone ahead and imported it. And there's also another helper file inside our utils folder and it's called polyline box. Okay, this is needed for one of the line elements. So, I think it is for either the arrow or stroke. Sorry, it's for this one. Okay. So, just make sure you import that one as well. Okay. So, consider this as a gift from me to you. All right. And so, um if you think that is good of a gift, feel free to click the subscribe button and consider that as the payment. All right. That's pretty much it. Now, what I'm going to do here is I'm going to shrink I'm going to just comment this out. Comment the frame out for now. And we're also leaving out one more button, which is the generated UI. So the first thing I want to do in here is add frame button and add generated UI. Okay. And u I have to put this under to-do. Shouldn't forget about that too. And now I'm going to go back to our shapes index.tsx right in here. So sorry canvasindex.tsx. And I'm going to import my shape renderer. And this render obviously needs toggle inspiration which we don't need for now. Generate workflow, the toggle chat, and the export design. This stuff is not needed for now. Eventually, yes, maybe. But for now, we don't really need it. All right, I hope you're ready for the moment of truth. If we have everything successfully set up so that the listeners are paying attention and they're listening for all of these rectangles being created, we have basically built this entire architecture from scratch. And so if this works, first of all, give yourself a pat on the back because you deserve it. You've come so far. This is not an easy task. In fact, most of them probably got scared away by the project and they ran away. But that was the hardest part. You're finished. You're done with it. Okay. And so now we're going to test this out. So the first feature I want to test is to make sure our selected shape is actually working. Awesome. There we go. And it it has a nice design, too. So it indicates that you're currently selected on this. Now, if I draw here, if I draw a rectangle, we shouldn't see a rectangle instantly. And the reason is because right here, we're rendering the shapes that have been committed. But towards the end, um, if I'm right, right, we're also going to need to render out a draft shape. It's a draft variant of our shape. Okay. It's going to look very similar to what we already have, but it's just going to have a slight bit, you know, variation, like lighter text, dotted backgrounds, all that kind of stuff. So, let's go ahead and draw a square. Okay. Don't see anything. That's what I wanted. Hey, let's go. Oh my god, that was so much. That was so much just to draw a square. Now I want to make sure that I can also draw a circle. So I'm going to create a little also I can move around. Look how smooth it is. Right. This is why we created all those performance enhancements. So you can you can move this around 360 and you can zoom in. Guys, this is crazy. You have no idea how much time and energy went into building this from scratch. Okay. And now I'm going to try to draw a circle up here. So obviously we can't see it. Okay, there we go. This is awesome. Uh, pen tool. We can't see that too, but there you go. It's drawing and connecting all the lines and eraser tool. Okay, nice. So, you see once it intersects that that's why we had that um that function, right, which combines the tool and the position of the element, its points on the map and so that if this is within that shape, it removes it. Right? So, this is a super helpful tool as well. And one thing you might want to add is maybe an eraser design because the cursor looks really odd. Uh maybe I'll do that later. I I don't know. It's not not really it's not important. Okay. Now, the frame is not going to work because we don't have a render for it. But technically, it has a frame right now. So, we got to be careful. Okay. I am so proud of you. You have come so far. I think with this being Let's just stop at this. Let's take a quick break. I hope you go eat something, okay? because you might be uh doing this the whole night. I don't want you to do that. Go ahead, take a small little break and then we can continue in the next session. All right, see you there. All right, now go ahead and scroll down here after your renderer where we're essentially rendering the shapes. And now we want to render the draft mode for all of our elements. That means uh this is essentially when we're drafting them or creating them but not committing them. So right now, you see when I click on something and I draw, there's nothing here, but something technically is there. And the reason why we can't see it is because there's no draft mode, no preview mode. And so that's exactly what we're going to be doing. So after this curly bracket, this is inside your tool toolbar index.tsx. Down here, I'm going to create the rectangle preview. Okay. So go ahead and say the following. So we're going to say draft shape. That means there is a shape that's currently uh active or that we're drafting. And in order to get this, we're going to grab this from our helper function. So up here, I'm going to say draft shape equal to get draft shape. Right? The helper function helps us get that. And then let's scroll back down. And so now we have that value. And if the type is rectangle, then we're going to return this custom type here, this custom component that's going to render out the uh rectangle over the rectangle preview. So copy this title and you're going to go into the rectangle file in here and inside this remember we had the preview right so make sure this component is already in here and if you downloaded the uh the YouTube kit I'm basically giving you this for free but uh if you already bought the codebase and this will already be inside your codebase. Okay so make sure the preview.tsx tsx uh for our rectangle here actually exists. So now let's go ahead and import this component. There we go. And now let's go ahead and try this out. So I'm going to click on the rectangle tool here. And if I draw something, there you go. Awesome. We can now see that there is a border that's creating this effect, but it's also lighter. And if I let go, it becomes a solid rectangle. Similarly, we're going to need to do this to um all the different type of elements we have. So, the first thing I'm going to do here is for the frame. Okay. Now, obviously, we don't have the frame. We have never tried it yet. And that's okay. But we're just going to import the frame because we already have it as part of the folder, right? The toolbar, um the shapes folder. So, we're going to bring that in. And then the the next one after the rectangle is the ellipse tool. So let's go ahead and do the same here. So you can pause the screen and maybe take this up as a small challenge, right? Just do this for yourself. I'm also going to pause the screen and then once we're done, I will uh once I'm done, I'll go ahead and continue from there. Okay, awesome. Welcome back. Hopefully you completed everything up till the line part. You might have uh maybe a question for the free drawstroke preview. What do we do for this section? Well, here we're going to need to show the free draw points. And we also have a another helper. So, hopefully you knew how to do this and you created that. And if you don't know, that's totally fine. Okay. So, all you have to do is invoke the get free draw points. And that's going to give you the free draw points, which you can then pass in right in here. And make sure you're checking the length to see if it's greater than one. And that's pretty much it. So, now let's test them all out. Right, we have arrow, ellipse, rectangle, line, and the free draw. So, let's go in here. And first thing I want to try is a free draw. And I want to show you how we're per we're using um the hook the rerender method to essentially trigger a rerender for our use refs. Okay. So, when I scribble here, I'm going to see tiny little dots that are spaced out a little bit. That just shows that you're drawing, right? It hasn't committed yet. You can improve that later on if you want to, but we're going to essentially draw that out. And what we should expect to see are dots. There we go. Awesome. So, it kind of looks like dotted lines. And then it connects. Boom. Great job. Now, there's one more I need to provide here, which I forgot, which is the selection preview. Okay, the selection overlay. Um, so what I'm going to do here is I'm going to say the following. I'm going to say selection overlay just like this. And this component is going to be a custom component. So, let's go ahead and build that out. So, inside your shapes folder, just going to shrink everything in here. There we go. And inside the root, you're you're going to create a selection.tsx. And then in here, let's go ahead and return a component just like this. Now, I'm also going to give you this component as a free gift from me to you. Okay? So, you should find this inside your YouTube kit. So, you pretty much don't need to do anything. Just copy and paste it. And it is a lot of boiler plate. Okay. Essentially, for every single case, we're returning something. We're returning a selection. And I've put only a only few comments in this. Uh it's I mean it's still good enough, but uh the use effect I mean sorry the the use hook the the hook that we were creating previously that one's going to have more in-depth code comments. Okay. So um yep. So consider this as a gift for me to you. All right. So go ahead, make sure you drag and drop that selection.tsx component into this root folder. Now let's go ahead and look at what this looks like. What does the selection overlay actually look like? So when I create a rectangle, right, when I want to scale this up or if I want to click on it, I need to see some sort of uh you know like a like a circle around here. So I can scale that up and down, right? We do this. We see this a lot inside Figma. And so that's what the the uh overlay is. So there you go. When you select the element, you're going to see this design. And now you can click on that and you can move it around. This is so cool, guys. We built this from scratch. Nobody on YouTube is going to show you this. So, don't forget to smash that like button and the subscri subscribe button if you want to see more free value, more free content just like this. Okay, awesome. So, there we go. Now, we've created this. Let me also try to do this for the the circle. Make sure it works here, too. Okay, there you go. So, it does the same. And if I shrink it. All right, it's working great. Um, for this one, I'm not sure. Let me see. I forgot if I did it. Okay, there we go. We did it. And it also scales it. And not just that, it also expands it the way you're moving it. So maybe you could enhance this feature to lock it in. Right? So let's say if you are drawing this u if you want to scale it with proportions with the same aspect ratio if the user holds shift and then scales it up you should probably give the option to scale it along that axis right so I'm just giving you other ways to enhance this and maybe like a selection uh I know this is called selection overlay already but uh to select all of this how would you do that now I'm also going to show you that uh inside a frame because a frame essentially does that does that for you. That means any elements that are within that will move together. Remember, I've already created that function. So, the architecture is already built. Everything is completed. You just need to improve, make this more production grade. Um, you know, sit down, make it look nice if you need to. I think it already looks nice. But, um, if you need to do all that stuff, make sure you spend some time and improve the code. Okay. Next, let's go ahead and open up the shape renderer in here. And that's going to show this one as commented, right? Because we did not finish the frame. So, let's go ahead and copy this title or you wouldn't even need to do that because I gave this to you for free, right? So, click on the frame, click on index, and make sure you have everything that you need. Obviously, we don't have the use frame. We're going to get that in just a second. And you're going to get this preview. Okay. Make sure you have these two. And now, let's go ahead and import this if we need to. So, I'm going to uncomment it. Okay. And make sure it's imported. Awesome. All right. And that wraps up this section because now we are able to render not only the preview versions, but also the elements onto the canvas through a renderer component called the shape renderer. In the next section, we're going to focus more on the frame itself. And we're going to create a hook called a use frame hook. And this use frame hook has a lot of things happening under the hood because now we're going to essentially deal with real data um AI stuff. I mean that's going to come towards the end but that's essentially giving you kind of like a road map as to what the the next couple modules are going to look like. Okay. So this section is uh we're pretty much done with this section and now we can wrap this up and I will see you in the next module. So, in this section, we're going to be focusing on the shape renderer, specifically the frame, and the helpers that go into the frame, like toggling the inspiration section, the chat and export design feature, and the generate workflow. And so, for this, inside our shape renderer, we also have a frame in here. And this frame is going to have this use frame. And so, that's one more thing that we're going to need to focus on. Okay. So, let's go ahead and take a look at our design to understand what we're building before we jump into it. Now, I highly recommend you pause this video and go back to the start and watch the entire demo. If you have skipped the demo for whatever reason, you may not know what you're building. And so, I recommend you go watch that video, watch that section cuz I show you the architecture and how and maybe give you some other information about how this app works. And watching the demo is really going to help you build the app and kind of know the flow of everything, right? So essentially we're building out this frame. It it's as simple as a rectangle component, right? It's as it's as simple as a as an ellipse component, but it has other complexities. For example, the first one is this section, the inspiration section. And the other one is the frame itself. So the frame also has a chat window. Okay? So you can see a chat window right here. And this chat window uh window helps you speak to the entire screen which is a design screen that the AI will spit out. Okay. So you create a design here, you sketch it out and then you plug that u sorry and then you click on generate design and that's essentially going to generate your screens here, right? And so now if you want to make changes on those designs, you will need to communicate with an AI agent or you'll need to communicate with AI. And so that's why we have the chat window as well. So the frame has two sections technically three but two from here which is this and the chat window. So not including the frames features itself. The frames features are exporting the design into an image. So converting this and also moving the entire design and scaling everything alongside the frame. So all of this is part of the frame. Okay. So, there's a couple components we're going to need to create, a couple helpers, a couple uh hooks, and some very powerful tools under the hood that's going to do all this magic for you. Okay? So, this is going to be an intensive session, okay? An intensive model. So, I recommend that you grab some cup of coffee and uh code along with me. Okay? That's the best way for you to learn. So, let's jump straight right into it. So, the first thing we're going to do is click on your frame component, which is inside your shape renderer. So click on this and go into it. And if you haven't commented this out, uncomment it. Okay? I mean, if you haven't uncommented it, uh, do that right now. So let's jump into this frame component. And this takes a shape and the toggle inspiration, right? But it has this hook here called use form. And this needs two things. An is generating state and the handle generate design. Without these two things, it essentially cannot work because we have this liquid glass button here that has those on flick handlers. So let's go ahead and create those values so we can export it and pass it into this. So I'm going to click into our use canvas hook. Okay. And I'm going to scroll down to the bottom. And then right here I'm going to say export const use frame just like this. And inside this we're going to need to return those states that it needs. So first let's grab that state is generating. So I'm going to say is generating and set is generating is like this. And then the handle generate design function is going to be another function that we're going to need in here, but I'm going to provide it for now. Uh I'm going to just create this without put providing any details for now. And then I'm going to return it from here. And now if you go back into this hook, that should solve this bug. Okay. And now just to show you that this works. Okay. If you go into your browser, let's expand this a little bit more and let's draw a frame. Okay. There you go. You can see the overlay for the frame as well. And if you let go, there we go. Now we have a real frame that has all of the complexities built into this. Remember, I gave you I gave you those designs, right? I gave you that frame already built. And you can take a look at what that looks like. But, uh, this is pretty much what we needed to see the frame, and I'm also going to delete that real quick so we can work on the, you know, the the core logic of the use frame itself. So, what is the flow inside this? The flow is first we have a frame then we create something called a snapshot. Okay, this is essentially exporting the design, exporting what whatever's inside the frame that we created using points and all that kind of fancy stuff. We're going to convert it into something similar to a screenshot. Okay, so it exports all of this into an image and then we use the AI APIs essentially to generate the UI and then it's obviously going to get added to the canvas. But I don't think if that's I don't think that part is going to be a part of this. But the point of use frame is to do the following right here. Okay, so that's the flow. So for now, um we may not be able to see something on the screen. Now it's all implementation and the under the hood technical stuff. So please go uh I mean pay close attention and if this is a little confusing I promise you just keep pushing through it's all going to make sense towards the end. Okay. So first thing we need in here is we need all the shapes. That way once we get all the shapes um we get all the shapes to include in that frames snapshot then we can use the generate or export frames to essentially export those. Okay. So let's go ahead and grab that from our use app selector. So I'm going to say app selector state object.values values for shapes.shapes state.shapes.shapes and entities and we're going to return that. If not, we're going to return this object. Then we're going to filter it. We're going to filter and say where the shape is not equal to undefined. So if something was wrong with this, you could also put a boolean in here. Okay? But u if something was wrong with the value, we want to make sure that we always get the right shapes. Then now comes the generate design function. So this is right here and inside this this is what's going to help us uh convert the frame itself into a real UI design. Okay. So I'm going to have a try catch and inside the try block first I'm going to set the state to true. So here let's set the state to true. Then I'm going to create a snapshot. Okay. So capture the frame, convert the frame and its contents into something uh into an image itself. and then we're going to use that later on. So that function is called generate frame snapshot. It needs all the shapes and uh it needs a frame itself. So what I'm going to do is I'm going to say await. Let's change this to async. And then this function here generate frame snapshot is another function that we need to create. So let's go ahead and scroll up top above use frame and I'm going to say generate frame just like this. And this is going to need a frame. So this is the frame actually. It's not the shape, but I mean it's it is a type of shape, right? That's why here we're calling this shape. So we're going to pass the frame in here and all the shapes that are inside that. And then this is going to return a promise and not not this. It needs a blob. Okay, because it's an image technically. Now this is going to throw an error obviously because it's not returning this data. So let's go ahead and first let's get all of the shapes that are inside the frame. So I'm going to say get shapes inside frame all shapes and our frame. And I'm going to say shapes uh I'm going to store that inside shapes in frame. Okay, this is a very small helper function. So above this I'm going to say generate shapes inside frame takes in the shapes which is an array and it's going to essentially uh take in the shape itself. And then we're going to say find all the shapes within the bounds of this frame. Okay. And so shapes.filter and we're going to filter for where the ID is not equal to the frame ID. And we're going to have another helper function here that's going to help us find if uh this coordinate based detection actually works for that shape that is within that frame. Okay, within the bounds of that frame. So this is another helper function that has a lot of mathematical stuff that goes on under the hood. But here's all we need to do. So is shape inside frame. It takes a shape and the frame. Okay. And then in here we're just creating those bounds, right? So frame left, top, right, and bottom. And we're just grabbing those values. Then we're checking if the shape has any of these types. So check if the shape and its center center point is within that frame or not. Okay. And if it is, then obviously it's part of that frame. So we're going to return true and we're going to return all the values essentially. So we're just going to return the following here. And this is just a math. So go ahead, pause the screen and type it out. And then here, same thing. So for text, we're going to check if the text position is within the frame as well. Also, just to show you how what the text looks like, guys, let's go back here. I've already did I already did it, but just to show you. So this is some text, right? And you can click on it, you can edit it, you can click out. So now it's not in focus mode. And yeah, this is how the text works. Okay, so let's go ahead and let's refresh. There's no saving, so we're good to go. And then if this is text, we're going to return this following uh thing right here. And then if it's free, we're going to say we're we're going to essentially return this data. For line and arrow, we're going to return remember the start and end points, right? We're going to return those. And default set to false. Now let's go down here. And so now we have that information in here. Okay, we know if that shape is within that frames bounds, the top, left, bottom, that kind of stuff. Okay, we don't need to console any message. That's fine. And down here, we're just going to return the shapes in that frame. That's pretty much it. So now inside our generate frame snapshot, let's go ahead and hit enter here. And the next thing we're going to do is we're going to grab the canvas. Okay, so I'm going to say document.createelement canvas like this. We're going to store that inside this. And then we're going to figure out the height and width of that frame. Okay, so frame right here. Frame.width frame. And we're going to essentially set that to the canvas. Okay. And by the way, this is being passed in from here. So we have the shape, which is technically the frame itself. Okay. All right. Then after we have the width and height, next we're going to say canvas.getcontext for this. Now this is fine if you don't understand right now. It's just part of the formula. Okay. And then if we don't have this, we're going to say we could not get the context of this specific canvas. So I'm just going to throw an error. And then down here, we're going to set the the background for all of the elements to black. So this essentially is our way of setting some default styles so that later on we can use HTML to canvas. I think that's the tool that we're going to use to essentially convert it. Okay. All right. What's next? So uh let's go ahead now and let's set the fill color like I said to black. Okay. And then I'm also going to set the rectangles to the following. Okay. So fill rectangle to the following. Then we're going to set some clipping uh some clipping uh regions to frame the to the frames bounds essentially. Okay. And this way when we render it out, it's going to look cleaner. So just go ahead pause the screen and type these out. Then we're going to render each of these shapes within that frame itself. So I'm going to say shapes in frame for each and we're going to fire this function here called render shape on canvas. So go ahead, scroll up top and after this get shapes inside canvas, I'm going to say const render shapes on canvas equal to an arrow function like this. And this is going to need some props. So let's go ahead and grab those. Okay, some parameters. Sorry, not props. And then first thing we're going to do is we're going to invoke the save. Okay, and then down here we're going to say a switch. We're going to create a switch statement like this. And inside the switch statement, we're going to put the canv shape.type. And now for each of these, we are going to render out something specific for that design. Okay? So, if it's a frame, we're going to render something. We're by changing the stroke style, the line width, all that kind of stuff. Okay? So um first thing we're going to do is check check if it's rectangle, ellipse or frame. And if this is true, then we're going to do the following stuff to its uh to its render. Okay, so relative X and Y, we're going to set it to the following. And then we're going to check if it is a rectangle or a frame. And then based on this, we're going to render rounded rectangles and frames for them. Okay, the way to do that is to say stroke style. So, shape.stroke and shape.stroke um and shape.stroke is not okay, we don't need to do this twice, but uh is not equal to transparent. Okay. And if so, we're going to pass that in. Um but if it is, we're going to set it to white. Okay. So, the stroke will always be white color. And then the line width is going to be the following. All right. Next, we're essentially going to uh draw a rounded rectangle for for rectangle shapes. And we're going to have a regular type design for the uh for frames itself. Okay. So inside this you want to hit enter and you're going to say const border radius for shape. If the shape is a rectangle then we're going to create a rounded border. Okay. And then let's go ahead and say begin path like this. We're going to pass in the rounded rectangle in here. And then finally we're going to pass in the stroke. So I'm going to say stroke just like that. Okay. Now, else if this is of type ellipse, then we're going to do the following. So, we're going to render only the border and strokes for the ellipse. Okay. So, I'm going to say the following right here. And then we're going to set the line width just like what we did up here. So, hit enter here. Set the line width to the following. Then we have to begin path. Then we're going to set the ellipse to the following right here. And then finally after this one ctx.stroke. Okay. And now we're going to break right here. Then if this is case text right here, we're going to essentially do the following. So I'm going to say pretty much the same thing as what we did up here, right? So we're going to get text relative x and y. And then we're going to say fill. So we're going to say fill shape.fill. or if that doesn't exist, then we're going to put white. Next, we're going to set the font. So, the font is equal to whatever the shapes font family is. So, I'm going to say shape.font family pixels. And same thing here, too. Okay. Then, finally, I'm going to set the text base to top and fill. We're going to invoke fill text. And we're going to pass in those values that we just did. So, shape.ext. For that one, we're going to pass in this and this. And then finally, let's break right after this. Okay. Now, for free draw, we're going to need to do the following. So, I'm going to say if the shape point.length is greater than one, then we're going to add all of the changes, all of the designs to it. So, the stroke style, the line width, line cap, and line joint. Okay. So go ahead and pause and type the following. And then we need to begin this path here. So start that here. And then we're going to capture the first point. So first point and then we're going to say ctx move to the first point.x minus frame x and the first point at y minus frame y. Okay, cool. Then for each of those for each of those shape points, we're going to loop over them and we're going to create a line to that. Okay, so this is how we export them. We we convert it to a render and then we can export. Okay, so for shape.points less points.length less than that, we're going to loop over starting at one. And then we're going to grab the point at this. Remember I said it's for the first point, right? Oh, sorry, not first point, guys. Uh, for each point and then we're going to draw a line to that. Okay. Finally, we got to say ctx.stroke. Let's go ahead and do that. And let's break out right here. Okay. Awesome. Then after this, if the case is of type line, then we're going to do the following. So, we're going to first set the stroke and line width. So, let's go ahead and do that. And we need to begin path just like how we did for the other elements. Then we have to create a move to. So move to which one? Start x - frame x start yus frame y. Okay. And then in here we're going to do line two. So we're going to draw a line to that point. And now we have to to run this to actually create this we have to do ctx.stroke. And then we're going to break out here as well. The next one is case arrow. So for case arrow, first we're going to need to do I mean it's pretty much the same thing, but um there we go. So draw the stroke and the line width and then let's begin the path. Okay, then we're going to move to same thing. So move to pretty much the same line two. So we're going to create a line there and the stroke. Okay, but what's the only difference? The difference is it needs an arrow head. That's the only difference. Okay, so to show you I think this is also a perfect time to show you what that looks like. If you have an arrow here, you see we have this arrow head, right? So that's what we're trying to replicate on the render function as well. So down here, I'm going to hit enter. So now let's go ahead and say the the length of that head is going to be 20. Uh sorry, it's going to be 10. And now we have to create some math. Okay. So this is going to create an angle. Now, I'm not sure which angle this is exactly because it was a lot of math that I did that I did, but um essentially we're going to create an angle here and then we're going to obviously add some fill styles to that cuz it's a little triangle there, right? And then we have to say begin path. Then we have to say move to next we're going to create uh next we're going to send the line to. So creating those lines and this is uh again like I said a lot of math. Okay. And then we're going to create one more line two just like this. And then finally we're going to close that path and we need to fill it as well. So let's go ahead and fill it. And then we're going to break out. There we go. Done. And finally at the bottom here we're going to say ctx.restore. All right. So I hope this made sense. Essentially what we did is we grabbed the canvas that is on the screen, right? And then let's go back to generate right here. Generate frame snapshot. We grabbed the canvas. So we created a context for this canvas, right? So first we created a canvas here. Then we also grabbed our frame that's on the screen and we made our canvas look exactly the same as the canvas. Okay? So frame and canvas. So frame douwidth, canvas.width, frame.height, canvas.height. So we did that and then we're creating this context. So this is what canvas context is. This is how you create a canvas context. And if you don't know what this is, here you go. So it's essentially this element that's a blank drawing surface. Okay. So you can use a canvas to essentially map out points within that. Okay. So that's what it is. And uh the most common type of context is 2D rendering context. And so it's accessed by calling this. So you can grab the context of this and then you can draw on top of that and that's exactly what we did right here. Okay. So for each of the types we drew we did some math we did some calculations and we drew some values on that canvas by invoking all of these. Okay. So begin path move to line two all that kind of stuff. So this ctx is the canvas essentially. All right. Awesome. So now we're done um rendering each of these shapes inside of the frame. We're going to say ctx restore. Okay. And let's also print a message here saying all shapes are have been rendered. And now we need to convert the canvas itself to a blob. Okay. So you see how this is built from scratch. Awesome stuff here, right? So first thing I'm going to do is I'm going to create this new promise. So return a new promise and we're going to say canvas.2 blob. Okay. We're going to invoke that. Okay. Okay, so it looks like there's an issue here. Let me just take a quick look. Okay, it needs the call back. All right, no problem. We're doing good. Okay, so I'm going to create that callback function that it needs. And this gives us the blob. And this has to return something in here. Okay, don't forget to put the arrow here, guys. I forgot to put the arrow here because this is a callback function, right? So, first thing is we're going to say if this is a blob. So if it is a blob then blob uh created successfully. Right? So we're just going to resolve this promise here. Resolve the promise inside this. Okay. Let me save this and then move it up. There we go. So we're going to resolve the blob. But if not, we need to create this blob. Right? So that means some some error took place here. And so what we're going to do is I'm just going to say reject. So fire the reject from the promise. and we're going to say fail to create the image blob. Okay. Now, what type of blob do we need to create? So, after this, this is the first thing which is the arrow function. You're going to put a comma after this and you're going to say image.png and then you're going to set this to 1.0. So, put a comma here and say 1.0. And that's pretty much it to generate the frame snapshot. So, let's go back down here. And what I'm actually going to do guys, I'm going to copy all of this. So everything we just created inside this hook, uh, not till the use infinity to the is shape inside frame. So go ahead and copy all of that. And only the generate frame snapshot should throw an error on your use canvas page. Okay, we're going to go ahead and open up your your lib folder and say frame- snapshot.tsx.ts. Okay. And in here, we're going to paste whatever we just copied. Okay. And it's going to need some types. So, let's go ahead and import those. Pause the screen. Import all of that. And then let me know once you're done. Okay. Okay. Awesome. So, let's go back to our use canvas. And now, let's import our generate frame. Where is this? Oh, I need to export it from that file. I think that's what I need to do. So, let's go back in there. Generate generate okay there we go so export this one let's go back let's import this and now we can use it inside this file okay so now that uh we have created a visual representation of all of our designs which is a wireframe um now AI can understand this essentially right so now after this snapshot I'm essentially going to create a helper or it's actually not a helper This is just for debugging. Okay. And we're going to download this blob. So, let's go ahead and say the following. So, I'm going to say download blob snapshot frame snapshot.png. So, this way we can see it. Okay. And now what we're going to do is we're going to go into that frame snapshot comp uh frame snapshot page. And in here, please follow with me. Please pause um sorry, please pause the screen and type. Okay. So, you're going to say download blob takes the blob and a file name. And then it's going to say create a URL for this blob. Create a link. So create a link on the page. Then we're going to set the URL to that href. We're going to set the download to the file name. Then we're going to append the link to that body to the document body. We're going to click on it. We're essentially manually attaching elements onto the DOM. And then we're invoking its methods. Okay. And then once we have we're completed this, it's going to show download to where whatever. It's going to show your folder structure. Um and then file system just go ahead and download it wherever you want. Okay. So now let's go back and let's import this. So now when we generate this we can actually see it from see it inside the console. Uh you can see it you can see it as an image. So you can make sure that everything was drawn drawn correctly. Okay. So after this we're going to hit enter. And now we have to prepare the API request. Okay. We have to prepare this stuff for AI. So first we're going to say form data equal new form data. Then we're going to append the image link into this form data. So form data.append, we're going to pass in the image. We're going to say snapshot. So whatever data we stored right here, which is a blob, pass that in. And then we're going to append that with also the the file name. Okay. Then we're going to pass in a frame number right in here. And obviously this is shape.frame number.2. Okay. And then after that, now we're going to also need to add the project's context. Okay? And this comes from URL search params. So, windows.loation.arch. We're going to grab the search params. And then we're going to grab the project ID. So, grab the project ID. This way, we can attach the uh that information onto that onto this form data. And then we're going to say if the ID exists, then attach it. And now in this section right here, we're going to need to create an API call. But right now, we're going to pause on that for a second because I want to test out a few more features in the browser. So the first thing is to make sure that we can create some text and also see the text sidebar, right? So let's go ahead and say title. This is the title. Something like that. Okay. Now, if I click on this title, I can obviously edit the title. And there's a little bit of padding here. And so maybe that's a little bit of a challenge, right? Uh you could create like hover states. So when you hover over it, you could show the selection overlay. Okay, I think that's another cool feature you could add. But there you go. If you click on that gap, which triggers this, it's going to show you the font size. So you can increase the font size. You can change the font color as well and uh do pretty much whatever we wanted, right? Awesome. All right. All right. So, I just spent some time just to create something just to see if it works. Right. So, I've used almost all the tools uh that I see here except for the arrow. So, let's go ahead and maybe try the arrow too. Why not? Right. So, let's try the arrow as well. And uh I've used the line tool. I've used square text scribble whatever. So, if I click on generate designs, let's just see if it's able to generate that. Okay. Downloaded an image. Let's go ahead and open this. Okay. Awesome. Wow. Oh, it did everything. Okay, there you go. So, you can custom make the color, the background colors, you can set it to white, whatever you like, but black is the best because AI, well, from what we found is the black on white design was easier for AI to identify than white-on-black design. I don't know why it just that's just what it was, right? But every element that I see on the screen is inside this frame, which is good news. Awesome. Okay, it looks like the generating thing is spinning because uh we forgot to update that, right? We didn't we didn't change the state back. So that's what that's something we got to consider. But apart from that, everything else is working so far. So this is good news. Now, there are some some challenges with this. Okay. And I want to I want to give you that info right now so you can update that in the future. The first one is the frame uh movement. I don't know if it's just me probably making a bug, but the frame itself is supposed to move this around and I thought I fixed that bug, but it looks like it's not moving it around. So, just just let me know if you guys are able to figure it out or maybe we'll figure it out later as we keep going. Right. So, I'm going to I'm going to try my best and see if I can fix that bug. But the cool thing is it does know the context of what's inside. So, we're so close. That means we know the context. We know what's inside. We just need to be able to move. That's it. So something is wrong there. And I saw that if I click on this element and then move the container, I'm able to move the stuff. So it might just be something with selecting multiple things together. Okay. And u that's the only other thing we need to work on. Maybe in the future, but even then it's not make or break. I will, you know, you guys can just let me know inside the discord if you want me to add that stuff in. Okay. and inside the the pro um you know the premium codebase. I'll definitely put that as as part of it. Okay, but I just want to say that this is the problem right now. This is one bug I'm facing. And the other bug is the line. So the line worked here, but in some places the line goes behind the screen. And so what I did was I just set a Z I mean what you're supposed to do is just set a Z-index. Okay, so that should hopefully fix that problem. And then um apart from that, I think everything else seems to work correctly, right? Oh, also for the text. So maybe in the future you might want to add a feature to show the hover state. So as I hover over elements, show a blue color icon, right? Like similar to this, just activate it. So that's that's going to be helpful so that users know what they're going to be clicking on instead of needing to aim for it. And another challenge I faced while drawing all of this stuff is copy paste. So at the moment I did not add it because it's not part of MVP. It's not part of the deliverable because I've already given you what you need to do, right? You can select this and if the user clicks on a keyboard shortcut Ctrl + C and Ctrl +V, you know that you should copy that element and paste it. So whatever is selected, you could uh paste that, right? Or maybe you could have a selection state of arrays. So, it's a selection state that has all the array. I mean, it's an array with all of the elements that are currently selected. And maybe you could have a selection box where if you select everything on the screen, all the elements that fall within that frame get added into the selection screen into that selection array and then when you move, you could use that for moving, you could use that for uh maybe copy pasting. So, that that is a super powerful feature. Okay. But regardless, most of the implementation is already done. So you just have to use your brain a little bit and uh move things around and then eventually you're going to get exactly what you need. So that feature worked. That means we're able to download the uh download the design in a PNG image which is awesome. Now we can take that blob and we can plug it in. We can plug it into the AI. Now the next most important feature that I want to work on before I move to the AI part is saving because this is a lot of complex data complex points on the you know on this on this canvas that we need to save in real time without making any errors. So in in traditional you know coding or like very MVP type coding what we would do is we would just hardcode that save that would work but if the user closes the browser or moves to a different tab or some sort of timeout happens that can lead to challenges right and so um I have a solution in place and I'm going to walk you through what we can do and why we chose to approach it this way. Okay awesome and I'll see you in that section. So in this module we're going to learn how to run a function outside of our application. Now in most cases in in most applications we have a simple action to response type of procedure right that is our flow when we code. So user clicks on a button for example they go here they're like ah clicked on the button and the button's a save button for example and so they click on this well what does the user expect? they expect the data to be saved, right? And the way we do it under the hood is first we take the action that was performed and then we determine okay maybe we should call an API route or whatever we need to perform but most of the time it's an API route for so for simplicity I'm just going to say API and so we decide to call this API route and now during this flow there are a ton of things that can happen the first one is this could lead sometimes to a timeout. Okay, so maybe the data that it was trying to save was too large or uh something happened on their server. Maybe they have a huge traffic spike. And so sometimes this can lead to a timeout. Another common reason why we could break this flow or cause an error to take place here is if the user closes the tab. And this happens a lot of the time, right? Let's say they clicked on the save button and then immediately they closed the tab or their browser shut down. This means it's going to stop this API call. And another way this could stop is through an unexpected error. Okay, unexpected uh error. So just something unexpected that could take place especially in an application like ours where we're dealing with complicated data, right? We're dealing with huge JSON sets. We need to make sure that at least we at least that we can guarantee that the data is going to save right and there's other things in this as well even payments. Let's say the user try to make a payment. Payment goes through user immediately closes the browser and uh let's say you set up your web hooks in a way where it needs the browser to run because it has to show a screen on the you know in front of them or something like that. But if they close their browser or a timeout took place, they're going to lose that feedback. And so you see the challenge here, right? And like I said, especially in our application, we're we're going to need to make sure we deal with the situation where we do not handle the function on the front end. And so if there was a way, if only there was a way that we could do this, well, the good news is yes, there is something we can do. Okay, it's called background jobs. And essentially you create a function that exists somewhere else. It has its own infrastructure and can obviously scale as much as it needs and you outsource that function to that server. And so this way even if the user closes the browser or a timeout takes place or an unexpected error takes place this background job or this function is going to essentially handle everything because if an error took place this background job needs to be smart enough to essentially go in there and do it on its own. Repeat the whole process, right? That means it's going to refire that that function that it was supposed to and make sure it resolves. And so this is how applications like cursor AI or lovable essentially create tools and then they give um they give AI agent access that can call these functions and if something takes place uh that breaks the application or breaks the flow it doesn't stop there. So if you have 100 steps but um you fail at the 508th step, if you were doing this in a traditional linear approach without a background job, it's going to fail and the entire flow is going to fail and you would have to manually re-trigger all of these from scratch. But with the help of a background job, you can keep track of every single thing. You can know exactly where it failed and exactly what's needed to be redone. and then you can essentially refire that function and make sure the user gets the expected data. Now, there is one amazing solution out there that can help us do this in a very short span of time. If you built an architecture like this, this would take you probably more than 2 months, okay? because you need to set up every single thing from scratch because the first thing you would need is a queueing system. Okay? And a queueing system I don't know if you you guys have heard of Kafka. This is something that you will need to use, right? Or you can also use Reddus. And so you're going to need to first have this queuing system and you're going to need to make sure is fast and scalable. And then you're also going to need to have um other sort of workers or the job runners that can essentially pick these jobs from the cues. And there's there's a whole bunch of other thirdparty tools you're going to need to use for this because if you build that from scratch, you're going to waste months and months just building this little background job. Okay. And then for retries and failing, you're going to need to do this on your own, right? You're going to need to create another web hook on your own to essentially notify yourself and then figure out which step failed and then accordingly you're going to need to do that once more. Right? Then what about scheduling? So let's say you had a uh you had a background job or you wanted a background job to fire 5 hours from now. You can't do this unless you have a scheduling curron job type um architecture into your app. And I would highly highly not I wouldn't recommend anyone to do that from scratch. It's going to take you forever. Okay. And uh not to forget you got to keep track of the state across all these different actions. You got to keep track of every single state so that each section can listen and also provide information to the next section. So state management across this is also important. And now, not to forget, you're also going to need need to keep track uh need to keep track of logs. Okay, that means you want to know exactly where your action is right now. Where the background job is currently and you want to know how long it's been running because now you have to deal with the server usage, right? That means how long is this function running um you know in the cloud and how long should you have to pay for that? And so now we're going to be paying for every single thing. just building this will take you 10 times more. Um, and that's why I found a much much better solution. Oh, I totally forgot. There's one more thing. You got to also ensure that all of this can scale if you're building it completely from scratch. So, you see the tiny little building blocks that go into place if you're building something like this from scratch. You need the API layer, cues, workers, retry logic, scheduler, state management, orchestrator that can pick up all of these. You need observability. So like where am I currently in the flow? You need the scaling infrastructure. You need SDKs. It is all over the place. And that's exactly why we need ingest. Ingest is a tool that pretty much does all of this, every single thing that I mentioned under the hood for you. They have an orchestration engine that works under the hood for both the workflows that we just discussed and also this new tool called AI agents. Now, um don't get confused with this. This is slightly different from uh from the background jobs, but essentially you can use the AI agents and you can provide it with tools which I'm going to instruct you on how you can do in the future to improve your application right overall. But you could use this AI agent kit to essentially handle tool calls. So you can give it all the tools and give it the functions it needs to call in order to run these tools and now you have your own cursor AI. How awesome is that, right? They also have uh well obviously you can use whatever stack you want, right? They have some uh they have an SDK for all of that and you can debug like I said you can see every single step of the way. You can see where you are. You can see where the background job currently is and it's production grade stuff and very very simple to pretty much set up inside your application. And um if you guys have heard of Zapier, Zapier is an automation workflow tool, right? They use something similar to Inest under the hood. Okay? So maybe they have their own infrastructure. I'm not sure. But Injust gives you all of what Zapier has, but from a developer standpoint. That means now you can do exactly what Zapier is doing today. How awesome is that, right? So, all you would have to do, let's say if you're building an automation builder, you would just need to create these functions that exist inside their uh inside their server. And I'm going to show you how to do that as well inside this uh inside this module. For example, you would have a send a Slack message. That's one of your actions. You would store a function that could essentially do that. And all you would have to do is create a chain workflow reaction between all of these together. That's pretty much it. You just control it through uh through an API response. You tell it, I need to fire all of this. Handle everything for me. And it is going to make sure that not only is everything queued up correctly, but it's also going to make sure every single action fired in the way you wanted it to. Okay, so Injust is one of the most powerful tools I have found so far, especially for this build, because we are going to need to make sure that our users data is being autosaved as they are working. And with that being said, Injest is also the sponsor of today's video. So go ahead and use the link in the description to open up your free Injust account. And this also lets them know that you heard about them from this video. So I've already signed up and the first thing is it takes me into this page. So once you're in this page, then you can continue. All right. So pause this video and then make sure you sign up and then once you're on this page, then we can proceed. Now, what you could do is you could change the environment here, but I'm just going to use this just for simplicity sake. So, go ahead and click on this and then click on event key and it's going to show you a default key right here. Go ahead and copy this key. And then inside your environment variable, go ahead and paste that key in here. Once you're done with that, the next thing you need is this key right here, which is the signing key. So, go ahead and copy this one, too. and then paste it inside your env. Now the way this works with Injust right now is you first need to create the app and the functions and then once you set up ingest from our side once we sync the app to our app it's essentially going to upload all those functions in here. That's that's an easier way to explain it. Okay, there's more happening under the hood, but that's essentially the the steps that we need to follow. So it is giving me something here. So I'm going to go ahead and run these commands. Now, please follow the exact same version number that I have. Okay. Now, go ahead and open up your terminal, and you're going to type in the following command. And for this, you're going to set the version to 1.11.3 and put a space. And it says you have to put dev there, but I I don't know if that's going to spin up dev, but let's just go ahead and hit enter here. Okay. So, we have a couple things. It's saying, would you like to proceed? Yes. We're going to hit enter. Okay. And that's how you spin up the server. Okay. So it says inest server is online on this specific point endpoint. Okay. So now with the help of this command you can essentially run inest locally. Okay. So you can basically um host those endpoints on this specific URL which is localhost 822 8288 right and you can follow their instructions. But I'm going to show you another way which is to create this app from this dashboard and then I'm going to show you how to sync the functions through the app. Okay. So let's go ahead and proceed with that. So go ahead and open up your folder structure and you're going to find this API folder in here. You're going to create another folder. You're going to call it ingest and then inside that a route.typescript. And inside this route essentially we're going to set up what they were just what they were just speaking about which is those functions that are hosted on that endpoint. It's a group of functions served on a single endpoint. That's what we're going to be setting up in here. So go ahead and open up the terminal and you want to say npmi. You want to say ingest at and the version number is 3.40.1 and go ahead and hit enter. Once that's completed, go into your ingest route that we just created. And in here, we're going to essentially export that server that that endpoint that they were talking about. So the way to do that is actually very simple. You're just going to say export const get postput and you're going to use this serve function that comes from ingest next. Okay, so let's go ahead and grab that. We don't need this for now. Okay. And so we have the serve function. We've passed that in here. And now we have to tell it the client, the ingest client that it needs to use and the functions that it needs to use. So I'm going to say client and I'm going to set it to ingest like this. And then let's go ahead and open up our folder structure. We want to scroll down and you can put this wherever you like to, but I'm just going to put it inside the source route. So I'm going to call this ingest like this. And we're going to create our client.typescript. And inside this client.typescript, TypeScript we're going to create um a client that can essentially help us send and receive events, okay, through ingest. So all you have to do is we're going to say constingest equal to ingest like this. And this is a real time middleware that actually comes from a different uh a different library. So let's go ahead and install that one as well. So I'm going to say npmi and I'm going to set the version number to 0.3.1 and go ahead and hit enter. And then make sure you say realtime middleware from ingest /realtime. Okay. So now we have created that event. So let's go back now in inside our API route and we're going to import that new client that we just created. Awesome. Now we need to create the functions. So for the functions, we're going to say functions like this. And it's going to need to be an array. And now whatever we want to do, whatever the action is or whatever background job or background action we want to create um needs to go inside this array. So now let's go into this in folder and I'm going to say functions.typescript. And inside this I'm going to say export const test test function equal to ingest and this comes from our client. Okay, you want to invoke it and in here you want to pass in first the ID. So I'm just going to give it an ID that I'll probably update a little later. So I'm just going to say ID like this. And it looks like I made a small error here. This is a different bracket just like that. Okay. And then inside this I'm also going to need to import ingest. It looks like it did not import it. Okay, there we go. And it needs three arguments. So the second one is the event. The event is going to be just like this. Okay, going to say project/autsave.reested. And then this needs an async callback function. Okay, so in here I'm just going to say console log just like this. And I also have to make sure that this returns something I believe. So, let me see. Okay, there was a comma expected here. All right, that should be it. Now, let's copy this function name. Let's go back in here into our route.typescript and let's import our test function. Great job. Next, go ahead and open up your terminal. You want to go to where you have your enro setup and you're going to copy this. So, click on it, copy link. Okay, and then let's go ahead and shrink this back. And let's jump into the browser. And now you want to click on get started. So make sure you've clicked on apps here. Then click on get started. And it's going to say create an ingest app. So let me click on this one and see if it's going to help us sync from here. Okay. So inside the apps uh sidebar guys, you want to click on create sync new app in here. Okay. So because uh the other one is running on local host. So you can see that right here, right? This one's running on local host. So we don't need that. I'm going to show you how to use our real URL. So, click on sync new app. And in here, you're going to want to paste that new URL that we just copied. So, I'm going to paste this. And then you want to put slash API slashingest just like this. Okay. And I'm also just going to copy this key just in case. And I'm going to compare it to make sure it's the same uh key that I have inside my environment file. But once this is done, just go ahead and click on sync app. And there we go. Now it has uh now it has kind of combined all of our functions inside here. So let's go ahead and click on functions. And there you go. It's showing our test function in here, right? Awesome. So this is how to do it with an actual endpoint. But if you're if you're on your local host, then you can go into this version, which is accessing it through here. And then you're going to need to sync a new app. You have to put a new address. And then you have to sync that app with a new address. Okay? So, uh, because we're not doing it this way, that's why I'm just going to proceed with this section. So, now that we have this in sync, now we can go ahead and update our function to handle it the way it actually should. Okay. So, let's go ahead and shrink this here. And now, let's click into our next uh into our test function. And let's go ahead and update this action. Okay. So, first thing is I'm going to call this autosave project workflow. All right. And I'm going to copy this title. I'm going to go back into my route and I'm going to replace this name. And then inside this, we're going to remove the console log. Okay. And so the first thing we're going to do in here is we're going to grab some stuff that comes in through the event ID. So we're going to grab the shapes data, the viewport data, and the project ID by dstructuring it from this data. Then we're going to create a try catch. A try. There we go. And inside this try catch we're going to await a mutation. Okay. And this mutation is called so I'm going to say await fetch mutation. And inside this we're going to first let's first go ahead and import it from convex. And then after that's imported now we have to pass in the uh exact function that we want. Right? So I'm going to say api.p projects dot and this is a new one called update project sketches. Okay, we don't have that obviously. So, we're going to create that in just a moment. But before that, let's just complete this. And this is also going to need some three uh three parameters. I'm just going to pass those in here as well. And then let's return success set to true. Okay. And if there was an error, I'm just going to throw an error from here. Great job. Now, let's open up our folder structure. Let's go into convex. And then we want to go into projects, which is right here. And then inside this we're going to create this new project. So export const. Oh, it's okay. It's already gave it. Yeah, it already gave it to me. That's pretty nice. So in here now, uh, first thing we need to do is pass in the arguments. So I'm going to say projects like this. And this needs a handler. So let's go ahead and pass in the handler as well. Okay. And this handler is going to need the following uh it's going to give us the following props. So let's just uh go ahead and dstructure them. Okay. Then inside this handler, first we're going to verify if the project exists. So this is a save. This is the save handler, right? It's a mutation. So first we need to find the project and make sure it exists. And if it doesn't, we'll throw an error. Next, we're going to prepare the update data that we need. So I'm going to say update data is all of this and the last modified is today's date. Then we're going to have uh to then we have to update it. So I'm going to say the following. So if viewport data exists then we're going to update it like just like this. So viewport data update data dot viewport data equal to the new viewport data. And finally we're going to update it in the database. So we're going to say db.patch and we're going to pass that data in. And we're going to return a true success true and just print out a message. And that's it. Now you have created this new function. So let's go back in here. And now let's open this up and let's try to sync this once more. So you want to click on apps. You want to go in here and you're going to click on this and see if I can sync this directly. All right. Resync app. Let's go ahead and click on that. And it's saying that the URL you served. Okay, this is fine. Let's just go ahead and reync it. Awesome. Completed. And let's click on our functions. Great job. Our functions are still here. So now go ahead and open up your folder structure inside the navbar.tsx index.tsx. tsx in here. We're going to need to uncomment this. And now we can copy this name and we can build out this component. Okay. So, open this. You want to go into canvas and inside this you want to create autosave. Oh, what is this guys? Sorry about that. So, inside canvas autosave and inside that an index inside this an index.tsx tsx and then in here we're just going to go ahead and return a component with the following name. Now this doesn't need any prop. So let's go ahead and remove that as well. And this is going to need to be a use client component. So let's also go back to the browser so we can see something in here. And the main thing that's going to happen inside this component is we're essentially going to say switch statement and we're going to check for the save status which we haven't created yet but essentially this is how it goes. So, we're going to look at the save status. If it is saved, then we're going to show the following check icon. If it is not saved, uh not saved, we're going to show or there's an error, we're going to show an alert icon. And then we're just going to return nothing here. Okay. So, now let's go ahead and grab these states. So, the first thing is I'm going to create the uh save status, which is going to be a use state just like this. And let's import our u state. And it's save status and set save status. Okay. And then before this, we're also going to need a ton of other stuff. So, let's go ahead and grab that, too. The first one is use search params. Okay. Next, we're going to grab the project ID from a search params because remember, we're passing that in here, right? So, let's go ahead and grab that from here. Then, we're going to get the user ID. So, uh the user information which comes from our Redux store. So, let's bring that in. And then we're going to grab the user info. And then we're also going to grab some from our uh from the shapes and the viewport. So I'm going to say shape state and viewport state. So let's grab those two. Then I'm going to create some refs here for debouncing this save as well. And so for that I'm going to say debounce ref just like this. And this needs use ref and it's a set timeout. And then we also need abort ref. Okay. And then down here I'm going to create a last saved ref. And that's for actually we're going to create one more which is is ready. So down here I'm going to say is ready boolean. We're going to pass in the following. Okay. Then we're going to need another helper. This helper is essentially another hook. Okay. And this hook is called use autosave project mutation. So let's go ahead and bring that in as well. We already created that, right? So, I'm going to go ahead at the bottom here or above the view state right here. I'm going to say bring in Oh, I don't think we have created this guys. Give me a second. Okay, sorry about that. We haven't actually created this yet. So, let's go ahead and create this. We only built out the the file, but we haven't actually created it, right? So, if you go into Redux, you go into API, you go into project, you're going to find the file that we created, right? But we have we have to actually export this. So down here, we're going to say export const use autosave project mutation. Okay. And we're going to grab that from our project API. Okay. And everything in here is good to go. So let's go back now. And now let's import this. Awesome. There we go. Now going back to our application down here, we're going to hit enter. And in here, we're going to create a use effect. Okay. So I'm going to say use effect just like this. We're going to remove everything that's in here. Okay. And let's import use effect as well. And inside this use effect, we're going to first check if we are ready or not. And if we're not ready, we're going to return. Okay. And is ready is essentially just checking if we have the user ID and the project ID. That's pretty much it. Next, down here, we also want to make sure that um we're going to take the state of our shapes and our viewport, and we're going to stringify everything. So, we're going to say state JSON.stringify, pass in the shapes and the viewport stuff, and it's just going to stringify all of our JSON values, and then we're going to check if the state string is equal to the last save ref.curren, then we're going to skip over it. We're just going to return. Okay? If not, we're going to essentially create a debounce. So, I'm going to create a timeout here saying debounce.curren uh is equal to a clear timeout. And now down here, we're going to create a new timer. So, I'm going to say debounce.curren equal to set timeout like this. And inside the set timeout, first thing we're going to do is we're going to set um the current. So the last ref, the last save ref is now going to be the new value here. And then I'm going to check if abort ref equal uh and I mean if this exists, we're going to abort this right here. And then we're going to create a new abort controller just like this. And then we're going to set saving status just like this to saving. And also let's go down here and let's say 1,00. Okay. So this essentially happens every second. Um and now we're going to have a try catch in here. So try catch just like this. And inside our try block we're going to say await autosave project. So let's go ahead and grab that from here. I'm going to say await autosave project and we're going to invoke this. And I need to also change this to an async right here. Okay. And this needs the following data. So I'm going to go ahead and just put this inside an object just like that. Okay. All the data that it needs. And we're going to say dot unwrap. Okay. And then down here we're going to set the save status to saved. And we're going to also set the new uh the new timer to and I'm sorry, sorry about that, guys. We're going to create we're going to say set timeout like this. And in 2 seconds, we're going to say set save status to idle. Okay, so that means everything is completed. And now we're back to normal. That's pretty much what it is. And that's why down here we're returning nothing. Okay, awesome. Then inside the catch block, if anything took place, we're going to essentially say, hey, error took place, right? And this is error from here. And then we're going to say name is abort error. Then we're going to return. And we're going to set an error in here. And then we're going to also set a timeout for 30,000 to go back to idle. Okay. You probably do not want to do this. You could remove this if you want, but um I'm going to have that for now. Then we're going to need to essentially return and clean up all of this stuff. So I'm going to say return. If there's something inside the debounce ref.curren, current, then we want to clean that up. Okay, so just delete those. And then in here, I'm going to also uh update our dependency to use the following. Okay, awesome. Then after this, we're going to have another use effect. And this one is going to clear our debounce ref, and it's also going to uh clear our our abort ref. Okay. So down here I'm going to say return. If there is anything in here, clear that. And if anything in here, clear this as well. The reason why we're doing this is when it first mounts, we don't want it to automatically save. We don't want that, right? So that's why we're just resetting it right here. Then if we're not ready, we're just going to return nothing, right? Just return nothing here. And if we're saving, we're going to return another saving state with the loading two right in here. Okay, let's import this. Awesome. So now we have our autosave component completed. Let's go back and let's import this. Awesome. There we go. And now I just want to show you something. So in here inside our API, we haven't actually created that route, right? Cuz we said the route has to be project um where is this exactly? I think it's in it's it's in our Redux, I believe. though. And so we did say it has to hit that end point. But notice how it just continues to hit it as long as it can to try to resolve the error, right? And so obviously there is a limit on this. It's not just going to keep going forever and ever and ever, but it will attempt to try to solve the error if there was some problem. Okay. So what we're going to do is inside our API folder now, we need to create another folder called project route.typescript. And then in here we're going to create a patch request. So I'm going to say export const just like this. Okay. Uh function patch request gives us next request. And in here we're going to have our try catch. Okay. So let's go ahead and uh let's go back to home so it just doesn't keep firing that so we don't hit any sort of weird rate limit. And then I'm going to create this try catch block here. And inside this first I'm going to need to um grab the user ID that's coming in from our request body. So I'm going to say the following. So body is going to be of this type and it's going to have this also. But we want to get we want to sorry we want to grab this from here request.json. Okay that's going to be inside here. So let's go up top and I'm going to create that interface the type here. It's going to be as follows. And then inside this, now that we have the body, let's go ahead and dstructure to grab all these values that we need. Okay, so I need project ID, the shape, viewport data, and the user ID. Now, if these don't exist, we're going to throw an error. Okay, and then if everything is successful, so let me also get this next response. If everything is successful, we do have this. Now, we're going to fire off the ingest event. So this ingest event is going to fire one of those functions we created. What is that function? So remember in here inside this autosave we created this project/autsave.requested, right? It's going to fire off this specific event here. So that's what it's going to do. So we have to fire that event from here. So that's this I mean this is why inest is so simple to set up. So inside this all we're going to need to do is after this if request u if check here we're just going to say ingest sendevente event. We're going to put the event name and the data. That's it. That is how simple it is to set up ingest and leverage an infrastructure that would cost you thousands of dollars a month. Okay? And I I don't even care about the money part. Like if it Okay, sure. Even if it costed me $5,000, no problem. My issue is the time I would have to put in to build something like this. So this is why Injust is very promising when it comes to saving you time and money. Okay. And I love the tool, man. Ingest is awesome. So let's go ahead now and make sure we return this here saying, "Hey, true. Everything's successful. Project is saved." And that's why if you looked into your dashboard, you would have seen that that uh error icon, right? Error abort. So, and now finally, if something happened here, we're going to return a 500 serverside error. Okay. So, now we have our routes correctly set up. So, let's go into the project and let's give this a shot. There you go. So, by default, we have this right here. And now, I'm just going to create something here. And I'm just going to scribble inside this. And you see it refires and it saves. Let's refresh. And there we go. All of our data is saved and it's rendering it on the screen. And now if I remove something. Okay, it saves it. And I'm just going to say new. And you see the the um the timer the timer fires one sec. Obviously, you can expand uh extend the timer a little bit more. I feel like this is too close, right? This is just 1 second, but it is saving this in real time. So now if we powered this up with AI and AI is making changes, we can save this in the background and not worry about things crashing. Okay, this is awesome. We have unlocked a superpower. Okay, I'm so happy for you. I wish someone gave me all this knowledge, man. All right, now let's move on to the next section. Now the next most important part of our SAS is to accept payments from our customers. And in the past, we have taught you how to use Stripe, Stripe Connect, and Lemon Squeezy. But in today's video, we're going to be using Polar. Now, Polar is a new product that went absolutely viral. It went absolutely viral on Twitter, on YouTube, everywhere. And I came to know about this about 3 months ago, and I took a look at what they have to offer, and I'm sold. The things that Polar offers is so much better than most of the payment providers out there. They're also not the sponsor of this video. I'm using Polar just because I believe in the features. I believe in the quality of the tool and I believe in the future of the tool, right? It's still a newer tool, still newer. It's a newer payment processor. I guess that's what you what you would want to call it. Um, I don't know if that's what they call themselves, but Polar has a ton of features under the hood that if you were to build by yourself would take you a lot of time. Now, their expertise are in two fields. So their expertise is in SAS and subscription-based billing and digital products. So if you have clients that sell digital products, that sell license keys, that sell GitHub access, right, Polar is an all-in-one for them, it's the perfect fit because you can create benefits, bundle them, bundle them up into a price, and when a customer pays, they can access these directly from their Polar portal. So it's it's powerful in a way where it takes away all of the you know the development overhead for you and the cost to do fulfill all of that and it's also such a waste of time if you were like if you were using Stripe right you'd pay almost the same amount in transaction fees and so if you're using Polar which I believe so now they're looking to move off to uh move to their own infrastructure it's going to drastically decrease so they are competing with Stripe and their payment and their billing is very straightforward. It's nothing complicated. It's a very simple linear process for your customer to pay. But I really like these two things because in the reason why I chose Polar for this project and like I said, they are not a sponsor. Um I picked it because it's a perfect fit for the project, right? Is first you can charge subscription base, which is what we're going to be doing in this project. Okay? But in the future, if you would want to add another feature just like how cursor does, which is pay as you go, get your own, you know, choose your own LLM, your favorite LLM, and just pay as you go. If you wanted to do that, building that from scratch would take you a very long time, and I don't want that for you. I want you to speed up this process. And so, by using Polar, you could just switch to usage uh usage billing. And with the help of usage billing, you can offer a pay as you go type structure, payment structure on top of your monthly subscriptions. And this is exactly what what Cursor AI is doing as well. Cursor right now has a $20 subscription. You grab it, that's your ticket to get the software, right? And that gives you plenty plenty of credits, which is awesome. They give you they're very generous with everything. And they also have a usage based billing when you hit your cap of your monthly allowance, right? whatever whatever you're given your monthly cap, you have the option to switch to usage based billing and pay for what you use. So, in your app, if you would want to incorporate that feature, Polar would be I I think Polar would be the best fit cuz it does everything for you. And I also love their UI. Their UI is so nice. It's very unique. Um, it's got this super exaggerated, dramatic rounded borders. I love it. I don't know why but and their transaction fees it it's very affordable. If you were using Stripe and if you were making a payment uh if you were accepting a payment from a customer who is outside of the outside of the United States you would have to pay close to 4% plus 30% 30 cents per transaction with Stripe. Now I'm I might be incorrect with the exact numbers. I'm just saying that it's pretty much the same right with Stripe with Polar. It's very competitive. And now when they do choose to move off to their own infrastructure, which I believe so they're they're already making that transition. It's going to drastically reduce this as well. Okay. So, um I really love Polar and I wish I wish you guys could um you know, let them know as well that that you are coming from Web Prodigies and you heard about them from us. And regardless, you don't even need to. I'm sure you're going to love Polar just by using it in this video itself. But one other really nice feature that stands out with Polar is tax reporting. So they act as a global merchant of record. That means they handle all of your tax compliance no matter which place you are in. Obviously you have to make sure you you fall within their uh their areas of operation, right? But I believe so that they cover more of the countries than Stripe does. Okay? And so for people who are in India who have a who have a you know who have struggles with creating Stripe accounts because you're from India because it's invite only now right they've pretty much stopped that. Polar is your other alternative. Okay so that's pretty much that's the intro to Polar and that's exactly what we're going to be using in today's video. So go ahead and open up your browser and it's going to take you into polar.sh which is the main site. Now you can use that if you want or you could use sandbox.polar.sh. Both are exactly the same. There's no difference between between both of them. And uh the only difference is obviously this is in a sand sandbox mode. But you can I hope I'm I hope I'm right with this and I hope you don't take my word but I I think I think you can transfer your products directly to your actual Polar account from your um from from your sandbox mode pretty soon. Okay. I think they're incorporating that feature, but I'm not I'm not 100% sure, but I'm just saying uh because it it only makes sense to have a sandbox that you can transfer your features into your main account, right? And so, just to make sure that we all have the same data, we're going to be using our sandbox. Okay? We're going to learn how to use a sandbox. It's the exact same thing. Nothing changes. It's the same website, everything. It's just that you're now in a testing environment. Okay? So let's go ahead and proceed to the next section. So once you have logged in, it's going to ask you for your information, your store information. Go ahead and enter that. And it might have taken you to this page. Now I'm going to show you what to do in two different scenarios. But if it takes you into this page, go ahead and just call this standard. It doesn't matter, but I think actually just keep the same naming convention cuz we might change it, right? So standard plan. And I'm just going to say this is the standard plan. Enjoy. Okay, nice. And then um you can upload media, you can do whatever you want. I'm going to set this to a monthly fixed price of $50. Okay. Oh, cam and select. All right. And once that's done, you want to scroll down here and it's going to ask you what type of benefit do you want to add. Now, this is um if you want to grant something to your customer, right? So typically I think right here we we don't need a benefit as such because it is just a payment or maybe I've just understood it incorrectly because I think I think what it is is these are benefits metered credits license keys discord invite all this is metered credits but if I click here it's going to ask me to create a custom benefit. Ah might as well whatever. So I'm just going to say plan access. Okay plan access custom. Let's just go ahead and create it. Okay. And now let's go ahead and create the product. And I'm also going to show you what you should do if you're inside the dashboard itself. Okay. But now it's going to ask it's going to essentially tell you what you need. So go ahead and copy this right here. And now at the time that this video is made, I'm on a different version. And I want you to be on the same version or you're going to find errors. Okay. So what you need to do is you're going to go ahead and open up this another terminal. Sorry. And then in the terminal, you're going to say npmi, but after this puller slash-sh.js, you're going to say the following. Or actually, here's what we're going to do, guys. Instead of installing only the Nex.js version, I'm just going to call this SDK. Okay? So, type the same thing. And then in here, you're going to do 0.34.12. And go ahead and hit enter. And now, it's going to take you into this page. And it's going to first prompt you to also, sorry, we're already on this page, but it's going to ask you to add an environment variable. This is the access token. So, I'm going to add this. And there's a ton of actions here. Let's go ahead and just select all. Okay. And I'm just going to call this test 4 or actually let's just call this S2C. Okay. And then go ahead and just click on create. And now copy this token. And you want to go into your environment variables and you need to add it under the polar access token. Okay. Um I see this. So access token server only. All right. Perfect. That's that's exactly what we want. And then I'm just going to backspace all of this. Then let's go back into this right here. And now you want to create another uh actually you don't have to create another token. There's a success URL. It says my app uh polar success URL. I don't think we have that, but we do have the public URL, right? And we also have a web hook secret. So, we have to get that. We have the token here. We just need these two. So, standard plan. Okay. So, what we're going to do now is we're just going to go ahead and see what they're saying here. So, to integrate checkout, you need to do the following. Okay. So, let's go ahead and just say go to dashboard now. Okay. And this is their dashboard. Looks super cute. All you have to do is if you were trying to create the product from the dashboard directly, click on products, go in here and then select new product and then it's the same exact process. Okay, just make sure you put exactly what I told you to and then you should be good to go on that. And then if you want to grab the keys from here, if you click onto settings, you should find uh your keys in here. Okay, there you go. So there is an authentication key and you can create the this is the token. So, you can create this token in here, this access token. And guys, please do not use my keys, okay? Do not use my tokens. Create your own. All right? In fact, I'm going to delete this right after this video. So, please create your own. Please follow through the same process that I told you and create your own variables. Okay. The next thing I need now is this web hook secret. So, I'm going to open this up. I see web hook in here. So, I'm going to click on this and I'm going to add an endpoint. Okay. Okay. So inside your inside your terminal, make sure you copy your Enro URL and you're going to go into this dashboard where you created the endpoint and you're going to put the following. So you're going to paste this. You're going to say / API/billing/webhook. Okay, so make sure it's the exact same spelling. Don't make any errors. And then in here, it's going to ask for uh what type of format. We're just going to select raw data for now. And it's asking about these these events. So, I'm just going to say checkout uh customer created. I'm just going to fulland just click on click on everything. Okay. Okay. There we go. And now I'm just going to go ahead. Okay. So, it's asking me to select this. Okay. Select raw and then click on create. And it's going to create your endpoint and your web hook is pretty much set. So, this was this is the power of this static nro URL. If you had to change this through local host, imagine you you'll need to jump through loops, right? You'll need to go in here, change it here. You have to change it inside uh inside convex. You have to change it inside inest. You have to change it everywhere. So use the static URL. Okay. Um all right. So this is saved. We're good to go here. Now let's go back to our application. And uh one more thing we want to do, guys, is in here you're going to find this web hook secret, right? We need to put that key actually. And I think I lost it. So let me go grab that once more. Okay, I grabbed it. So I'm we're good to go. And then in here, you see this next public app URL, right? We're going to need to set that as well. I totally forgot. So, let's go in here and we're going to need to remove this up till the uh up till this section right here. Okay. Anyone? And for your Polar standard plan, you need to get the ID for this product. So, so to do this, you want to go back into your Polar. You're going to click into your products right here. Click in. Click onto the standard plan. And uh let's search for this real quick. Okay. So, click on this right here and click on copy ID. Okay. And now let's go ahead and let's paste that into our environment file which is right here. Awesome. Now, go ahead and open up your folder structure. We're going to scroll into API folder and inside this we're going to click into this function so I can easily navigate to our functions uh path. And then inside this, we're going to need to create the handle polar event. So remember I told you how we can also use payments which is another important part in our application uh through a background job. That way payments always go through no matter what's right. So let's say customer makes a credit card payment something happens wrong you can retry with the help of a background job. Okay. So go ahead and say export const hand pol hand handle polar event like this. And this is essentially it's not going to be an error function. It's going to be ingest.create function just like this. And inside this we're going to need to pass in those endpoints. So the first thing we're going to say is this is polar web hook handler. And the event type that fires this off is called polar web hook just like this. Okay. Looks like I made another small error here guys. This is not an object. These are individual objects. Okay. And we're going to say polar web hook.received. So this is the event. And then after this we're going to need to pass in the arrow function. And this is going to be an async arrow function. So I'm going to say async like this. And then inside this I'm going to remove whatever it's giving me. And we're going to get the we're going to get the event and the step data. Okay. So comma step. Then in here first I'm just going to print out so I can debug if I need to. Just going to console log some messages saying you know in is starting the polar web hook event. Okay. Then first is we're going to narrow down our event payload to make sure it's a payload. It's a polar type web hook that we can handle. Okay. So I'm going to say is polar web hook event. And this is another helper. So you want to scroll actually let's just go into our types folder. So into types right here we're going to create polar.typescript. And in here we're going to do the following. Okay. So I'm going to say is this a polar event? It's a function and it essentially returns an event. So it returns if x is boolean true then we check the type of it and then based on that we return type data or the type data here. Okay. So now this also requires another event. So I'm just going to create another interface type here because we need it right here. Okay. Just like this. And this is I made a small error here. So let me just redo this. Okay. So now we have the polar web hook event interface type. Now let's go back and let's quickly import this so we can check. Okay. And now we're going to check the incoming data. So after this down here I'm going to say check incoming data. And this is going to be of type received event which is another type we need to create. So what I'm going to do is I'm going to go into uh my types folder and in here I'm going to say the following. I'm going to say received event type received event like this. Okay, it's polar web hook event with this right here. So now let's go back to our function and in here let's import this. Awesome. So after importing this now we have to essentially grab the type. So type incoming type and data unknown is incoming data. Okay. And now we have to extract the subscription from this. So essentially extract the uh subscription/order snapshots. Okay. So what I'm going to do is subscription which is of type polar subscription which is another type that we need to create. So I'm going to open up my types. I'm going to go into polar and in here I'm just going to paste the following. So go ahead and please pause the screen and type this along with me. And in here we're going to get this. we have to create this polar price, polar product, and polar customer. So those types are going to look just like this. Okay, ID, email, ID, recurring interval, and ID name. And that's what we're passing in here. This is just this basically just a subscription data. So now let's go back in here, and I'm going to import this. And now we have to extract the subscription. Okay, so this is going to be another another function. So let me go back into Polar. Uh, I'm just going to go into this file for now. And then in here, we're going to do the following. So, I'm going to say export const extract subscription like and we're going to say data unknown because that's what's being passed in. It's going to return a polar subscription or null. So, either this data or null. Okay. So, what we're going to do first is we're going to say d equal data as record. Right? We're going to grab the data from here. Going to check the subscription. So, d.subsubscription and type of subscription is object. And then we're going to say if id is a subscription uh the ID is equal to subscription ID, we're going to grab it from that. And then if the type of ID is string and the type of status is string, we're going to return a subscription type with all of this data. Okay. Now, honestly speaking, you don't even need to do all this crazy stuff. Like you could just set up the web hook to not check for all these types and just make it very minimal. I'm just doing a little more than that. Okay? So, I'm I'm trying to help you understand from a from an MVP standpoint that you don't need to do this stuff. You just need to accept the payment. And so, what you could do is just set up the uh the payment link inside here itself. Create the web hook to to listen for those uh for those subscriptions. And that's it. You're you're set. Okay. Then down here, we're just going to return null um if this type was not data. Okay. Now let's go back here. A type was not object. Sorry about that. And in here I'm going to import this function. And then the next one is we have to get the order that was made. So I'm going to say order like this is polar order which we I thought we already created this polar order. Okay, we did not. So let's go into types again. So please pause the screen and type this with me. So we're going to grab the polar order like this with all the following uh information. And the billing reason is essentially the subscription cycle. Okay. So down here uh inside this component, we're going to go ahead and import this. And now we have to extract order. Okay. So the extract order is very similar to the extract subscription. So let's click into that. And at the bottom we're going to say extract order. And this is just going to check to make sure that uh data does exist, right? And data is of type object. And then we're going to grab the data. We're going to grab the ID from it. And then we're going to return the data that we need. Okay? which is this polar order and if not we'll just return null here. Okay. Now going back here let's go ahead and import this. So now we have the order and the subscription data. So now with the help of this we can check if this does not exist then just return. We're going to return from here. Okay. Now we're going to resolve the user's ID and um or we're going to resolve this to the user's email. Okay. So what we're going to do here guys is I'm going to say const. So const user id is ID like this. We need to import this from convex. We're going to say users and in here we're going to say or null and this is not equal to this. This is equal to okay. So this should be equal to await and we're going to say step.run. Okay. So now we're using injust here. So we're running a step inside inest and this is to resolve the user. So we have to pass that in as a first parameter. Okay. So let's go ahead uh sorry first argument and then we're going to pass in an async arrow function just like this. Okay, looks like there's some typos here. There we go. And inside this async arrow function, we don't need to dstructure anything in here. First thing we're going to do is we're going to grab the metadata. Okay. So, we're going to grab metadata from the subscription metadata. So, let's grab that. Then, we're going to check if metadata ID uh exists. If we find it, great. Uh, inest is using the metadata user ID. Okay. And we're going to return this meta user ID right here. If not, then we're going to use the email. So, we're going to grab the email for the user. So, I'm going to say const email equals subscription. email uh the customer email and or if this is uh if this exists then we can use order customer email and if this still does not exist then we're going to use null. So this true use this no then use this no then use this. Okay and then in here we're going to throw uh we're just going to console. Now we want to make sure that this actually the email does exist here because then we're not going to be able to resolve to that user. Okay. So I'm going to say if the email exists only then do the following try catch and inside this try catch block first I'm going to console log okay and then I'm going to say found the user ID and now we're going to use a fetch query to essentially call the get user from this user table get user by ID a get user ID by email okay and we're going going to pass in the values in here that it needs to check uh check with. So get the user's ID by this specific email. So go ahead and copy this title and you're going to open up your folder structure. You're going to scroll up top to convex. You're going to go into users.typescript and at the bottom you're going to say export const user ID by email just like this. And also guys make sure you have your uh convex up and running. Okay. All right. This is an issue because we just made an error here. Uh that's fine. We got to import this. So let's import V from convex values. And so the argument is the email. We're going to check with this email and the handler is find from the database from users with the index of email. And we're going to check where the Q do. These are helper functions, right? So Q do. And the email is as follows. Okay. And we're going to return the first one. So if user exists, return that ID. If not, return null. And now let's go back here. And now this should not throw an error for you. Okay. Then finally, let's just return the found user ID. And I'm also going to just print a message if I need to. Okay. If there's an error, I'm going to return null. And I also have to print some other error messages. So I'm going to say email lookup failed failed to resolve user email. Okay. Now at the bottom here after this green bracket, I'm also going to say ingest firing from ingest. No email found to look up the user. So this is bad. Obviously all of this failed, right? So now we can't do any operations. And then finally, I'm just going to say finally uh final resolved user ID because we didn't return from here. So we resolved everything successful. And then if there's no user ID right here as well, then we're going to say no user ID resolved. So skipping the web hook processing. Okay. Now if all of this was successful, now we're going to build the payload for convex. Okay. So we're going to build convex's upsert uh payload from our subscription snapshot and u if not we're going to hydrate or update uh from the order. Okay. So if there's no creation then we're going to update. So polar subscription ID is equal to subscription ID or order subscription ID. So if this does exist we're going to say a polar subscription ID already exists. This ID exists right in here. Okay. And now if nothing exists, we're going to say no no no ID exist, right? And so we're skipping from here. Okay. So first process is we're going to essentially capture the current periods end date. Okay. So I'm going to use this helper function here. Um and this helper function is going to be I'm just going to put it inside our type in here. Okay. So I'm going to say the following. So this is essentially going to check if X is null. If it is, return undefined. But if it's of type number, return it. If not, we're going to say date.parse and we're going to put that in there. We're going to maybe it's a text, right? We're going to parse it up. And then we're going to make sure that the number is an actual number. Okay? And if so, then we'll return that new number. If not, we'll still return undefined. And now let's go in here and let's import this new helper that we just created. And now we need to build that payload like I mentioned. So in here I'm going to say payload equal to user ID and all the information that I have right in here. And we're using that conversion helper function in here as well for the cancel that cancel at and trial ends uh date and time. Okay. Then I'm just going to print a message in here saying that subscription payload whatever and just JSON stringify it. And now we're going to upsert inside convex. Okay. Now this is also another thing that we're going to outsource to. So it happens on the background. It's another step. Okay. So I'm going to say subscription ID just like this is step.runupsert subscription. And then inside this we're going to create a try catch. And then in here I'm going to basically print two console messages. Okay. And then here I'm going to first say const existing polar. So check if a subscription already exists before upserting. So we're going to say await fetch query and we're going to get by the polar ID so we can see if they have a subscription. And so in order to do that we're going to go into subscription.typescript. And then down in here we're going to check export const get polar ID just like this. It's a query and it needs to check with these arguments. We're passing these arguments inside and essentially we're saying query subscriptions with index this and where q do equal to the polar subscription that we just passed in and we're going to grab the first one. We're going to get that ID. So if that subscription exists then I'm just going to print a message here saying it does. And I'm going to create another one. Whoops, that's a fast car. Okay, never mind. And then down here, I'm going to say existing. Kind of freaked me out, guys. I'm not going to lie. So, existing by user. Um, and then we're going to say fetch fetch query and we're going to get the subscription for that user. Okay. So, again, this is another helper we need uh sorry, another uh function we have to create in here. So, inside another query. So in here I'm going to say get subscription for user is a query that takes this argument in and the handler is it's going to query subscriptions with this index. It's going to return the first one. Okay, for that user ID and so now we have that specific um value in here. Okay, so we're going to get the subscriptions for that user and we're going to make sure we have a subscription for that user ID. Now if all of this exists, okay, if the polar exists, polar ID exists, uh existing bipolar, existing by user, and we're going to check the ID is equal to the existing ID as well, then we're going to say that we detected a duplicate entry. So user has a different subscription bipolar ID versus user ID. Okay, so something is going on and we can print this error message. Okay, looks like I made a small error here. Uh we don't need this extra bracket or do we? Okay, we do not need that. And so after this, we're going to hit enter and I'm going to console log the following. Okay, and so this console log has to happen inside this. Okay, then after this section, we're going to use the fetch mutation and we're going to say result await fetch mutation absurd from polar. Okay, so you can copy this title and you're going to open up your folder structure and inside the subscriptions.typescript at the bottom you're going to say the following. So you're going to say export upsert like this which is a mutation and so let's import the mutation. And then in here we're going to need to pass in all of the arguments. So I'm going to say arguments is equal to the following. And then we have a handler. So let's bring in the handler as well. And we do not need all of this. So what I'm going to do is just remove this. Okay. And for this value, I'm just going to call it args. We'll pull it out when we need to. And then inside the handler first, let's print a message if you want to debug. And then I'm going to say check for the existing subscription by the specific price ID. So look for it. Subscriptions by polar subscription ID. And we're going to grab the first one. Okay. If it exists, awesome. Then we're going to check for any existing subscriptions for that user ID. Then if so, if everything's successful, then we're going to create a base. Okay, this is like another type uh another piece of data that we're going to construct over time. So you're going to pass in the following info. Please, please pause the screen and type all of this. Okay. And in here, we're going to create something called default grant. So let's scroll up top and up here, I'm going to say default grant. and default roll roll roll over limit and we're going to set that to 10 and 100 and these are just some uh temporary values that we're storing in here. Right? So credits roll over and the credits grant period as well in here. Okay. And then the next thing we need to do is we're going to scroll down in here and I'm going to say if existing by the let's move this inside. And um also don't get confused here guys. These default rollover credits and the default grant is what we are doing on our end. Okay, that means like I said we're not plugging this into polar yet. We're only plugging we're only plugging our stuff which is a subscription. That's pretty much it. Okay, you can use their own their you will need to do that on your own which is to expand on top of this if you want to add that functionality in the future. Okay, it's not going to be crazy hard. They it's pretty much straightforward. Um you can also use AI to just help you build that entire stuff. Okay, it will do it for you. And I think they have some AI documentation to help with that as well. Okay, so we are handling this locally on our end. But if you want to handle that um this is okay. So this is more like you this is not usage based okay this is a default grant of credits and you consume that but on on polar's end it's a different way so it's a different me different structure that is pay as you go that means you consume unlimited credits okay so it's very different so that's why we're not incorporating that so if you want to add that feature on top of this you will have to obviously expand on this app okay now if we found that um the price so the there's an exact match for the polar ID. Okay. And we verified it with the user. Then down in here, we're going to essentially verify the subscription belongs to the user. So if the polar ID user ID equal arguments user ID, then we're going to patch up that request. Okay? So we're going to do the following. else down in here inside this block. We're going to essentially treat treat this um in a different version in a different way. So first we're going to check if the user has an existing subscription. Then if the subscription exists in here then we're going to do the following. So we're going to preserve the credits B the credit balance and we're going to we're essentially going to grant um from our existing subscriptions. Okay. So whatever they have that is their credit balance and uh if you're a SAS developer or SAS entrepreneur and you're looking to start S2C as a real SAS company then all I'm asking for is just 30 seconds of your time. I do have something to pitch and once I'm done if you think it's a fair deal awesome. I'll show you how to get in before we run out of spots. But if you just want to carry on with the video and you just want to continue, then I really don't mind. I wish you the best and I hope to see you in the future when we launch this publicly. But I will let you know that there are some benefits with joining now. And so just give me 30 seconds of your time and then you can decide if this is for you or not. So this is our limited time founders beta program for S2C. We know the struggle, right? You've just purchased the codebase. You're ready to go. You wanted to start this as your real SAS company, but now you're hit with the reality of needing to maintain the code base over time, updating it with newer features, fixing all of the bugs, and then also some technical debt because if you don't know how to code, you're going to create hell for your customers. And so, we know about this problem, right? And so, that's why we decided for a limited time, we're going to get a dedicated development team to continuously upgrade S2C for you. So, if this already sounds exciting and you want to give me the next few seconds to hear more about this, then here's what this program is all about. So, first of all, this is a beta program, which means that it is only available for people who have purchased the codebase. So, you can't join this program from outside. You can't purchase it. You can't you physically can't enter uh un unless you have joined right now and you have purchased the codebase in this specific time frame. And also the most important thing is we only have 100 spots because we want to work with a smaller number of people cuz this is a beta program. And most importantly, we want to get valuable feedback, right? And that's why we're going to give you all of these benefits that I'm going to explain in just a second. And as a result, we also see if I mean, we also see if we could we enjoy doing this in the long term cuz it is it's a lot of time and energy and we want to make sure that this is fun for both you and I. If you were to hire us or hire a development team to do this for you, I'm sure it's a no-brainer. you would have to spend thousands of dollars uh because you'd have to hire these people. And so that's exactly why we created all of uh all of the features inside this program. The first one is there's going to be monthly feature releases, okay, for S2C. There's also going to be instant bug fixes. That means you can show up in the community. Uh you're going to get access to a little community. You can go in there and you can say, "Hey parent, we faced this bug. Any ideas if we can put this into this this month's fixes?" Right? and we're going to assign that uh to like a priority and we're going to push that at the end of the month. Then there's also performance optimizations. In the future, you might want to optimize some of your features. We can do that as well, right? And also security updates. You might want to make your application stronger and protect yourself and that's exactly why we created uh this founders beta program. Next, priority support. You might have some questions regarding the code or you might want to speak to us regarding a new feature that you want you might want to add into the application. this is the perfect opportunity to ask because you're going to be speaking to the creators of S2C. And my most favorite part is the feature voting system. So, inside this community, you'll be able to create uh new feature requests, and our team's going to go in there, see which feature was voted the most. We're going to put it into a backlog based on priority, and we're going to push that out for you. So you essentially are going to get all of the benefits and uh you know off of having a real development team and also have a direct say in the product's future. Now what is the irresistible offer? First of all, this is a risk-free 30-day money back guarantee. There's there's no risk at all. So whatever offer that I'm going to show you, if you don't like it, feel free to just reach out to us and we'll give you your money back, okay? In your first 30 days. So, the irresistible offer is if you join the first 100 members, you will get a lockin price at our lowest price this program is ever going to be, which is $47 per month. Okay? And it will never change. Even if we increase this to $200, $300 per month, it's going to be 47 for you. Okay? This is a founder uh founder member lockin. Now, please keep this in mind. This is a beta program. Okay? We're testing this out and uh we hope to provide massive value and we know we're going to but we want to make sure that we can actually handle all of these requests. So, okay, parent, I love this. How do I get access to this? So, when you purchase the codebase, you'll be redirected to another page or you'll find a link somewhere that uh that says, "Hey, grab the S2C uh founders beta program." So, you grab the codebase and then you can also have the option to enter the first uh 100 uh to grab your spot from the, you know, the first 100. And I'm so sorry if you see this page and you see that we're out of spots. We'll eventually open up spots. We just need some time. Price might change obviously, but um we just want to make sure that we can work with a small team, get valuable valuable feedback and make sure the program is good for any other future code bases that we want to add into this program as well. So you'll either see a link where you can click and uh you know directly purchase online and that's going to give you a community access called prodigiesuniversity.webroies.com. That's just his subdomain. That's not Prodigy's University, but that's just how he named it. Or it might be different. Okay, you'll find it. You'll you'll receive an email or once you purchase the codebase, this is the landing page. You can scroll down here and claim your spot from here as well. Okay, so I hope this was of immense value. We're trying our best to to give you give back to the community as much as possible and help you save tens and hundreds and thousands of dollars as well. Okay, so if you guys find this valuable, go ahead, click the button and join and I'll see you in the other side. And then inside this section essentially we're going to need to preserve all of their previous data. Right? So right here remember we're giving them grants and so we have a credit balance for this user. Right? There is a credit balance of how much they're using and how much they have already used. And so we need to preserve this data. Okay. So that's what I'm going to do right here. Here I'm essentially going to preserve this so we don't lost we don't we don't lose this data even if their ids or their their subscription IDs change. Okay. If you're still a little confused, you can watch the the first section of this video um of this section where I just I help you understand a little bit more why this is more complicated than just user has subscription update subscription. Okay, just watch that. It might help you understand a little bit more. Um but like I said, you don't have to do this stuff. You really don't. You could just settle for subscription exists, update it. Subscription doesn't exist, create a new one. That's fine. But over time, you just like I mean, not over time. It's not going to change. But if it changes, if their ids change or their the data that we have um something changed or the web hooks come in the wrong order, then you will face this error. Okay? But it's it's highly unlikely. So that's why I'm saying you don't need to do all of this, but I'm doing it anyway. So it's it's there for you. You can refer to it if you want to, or you can just remove it. It's all up to you. Okay. So now we're going to go ahead and preserve the old data with our base data. And we're going to update the user subscription. Okay. And finally down here, we're going to return the user's subscription ID. Now, if the user does not have a subscription, then finally, we'll create one. So I'm going to say else here like this. We're going to create uh we're going to say new ID. We're going to create db.insert. We're going to pass this in for subscriptions with base credit balance set to zero and the last credit uh cursor which is the last credit usage set to undefined. Okay. And finally, let's just print a message and let's return. Okay. Now, the other case here is that there is a user that exists with a subscription but they have a different polar ID. Okay. So, if that's the case, then first we're going to preserve all of the data. Then we're going to update their existing subscription with a new polar data, but we're going to still obviously preserve their credits and all of that base data. Okay? And then finally down here at the bottom, we're going to say um this is a new subscriber, a new user completely. And so, we're going to insert the following data. Okay? And then at the bottom here, let's return this when it's called. Okay, we're going to return the new ID. All right, so now let's go back to our functions.typescript and let's com continue from here. Okay, so now we're going to double check to make sure after we update to make sure that uh there are no duplicates for for upsert. Okay, and this is another one which is get all for the user. We're going to pass in the user ID and we're going to get all your subscriptions. So what we're going to do here is we're going to go in go back into this one the same file and above this mutation I'm just going to say get all subscriptions for the user with the following arguments. We're going to find the subscription. We're going to get with find with this index. We're going to collect all of them. And then in here we're going to essentially verify that. So I'm going to say if the length is greater than one. So all u right here guys sorry. So if the length is greater than one then essentially something something went wrong. We created multiple subscriptions and so we have to do something here right. So what I'm going to do in here is I'm going to say for all these subscriptions we're going to print that error so we can see it right? we can see that on the back end and then accordingly you guys can do whatever you want whether it's unsubscribing to one of one of them or not. So this is usually where you'd have to contact support and then go through that route. Okay? And then at the bottom here we're going to return the result. Now finally if there was an error I'm going to print that error and I'm also going to throw an error from here. Okay. Awesome. Now the next section here is we need to decide whether we need to grant credits, create, renew or you know whatever if they're updating that we have to decide what to do with the credit. Okay. So first we're going to say create. Okay. And then looks like a renew type subscription. And we're just using a regular expression here against their type to see what type was created. Okay. And then based on that we're going to check if they're entitled to a subscription. And this is called is entitled uh status which is another helper function which we could just do in here. So let me uh let me just pass okay let me just create this might as well guys. So inside your polar.typescript I'm just going to create this is entitled status in here. It's just another regular expression, but I I don't know why I put it in a different file. It's probably because I'm going to use that uh somewhere else. That's that's maybe why I put it in here. Okay, so I'm going to go back to this file and I'm going to bring this in. And then down in here, I'm also going to console print some messages so I can see them on the server. Then we're going to essentially build a stable. Uh we're going to create a key in here. Okay. And so I'm going to say key here. Okay, it's called indepotent in ind potency key. Okay, uh basically to grant it to the user. And so we're going to pass the polar subscription ID, current period, and the incoming ID. Okay. And now let's go ahead and let's create this. So, I'm going to scroll up top and up here I'm going to say grant key takes a subscription ID, the period end, and the event ID and we're going to return the following data. Okay, awesome. Now, let's go back down. And then here, I'm just going to console that uh new change. And then I'm going to say right here if entitled or it's create a renew then we're going to allow on first unknown period. Okay. So, I'm going to say grant and we're going to do step.run grant credits. And then in here we're going to have a try catch. Okay, so this is essentially going to grant credits to the user if needed. And it's usually I mean we're going to set that as 10. You could probably put it into your own um you know environment file and that's totally fine. But this is what it what what it's going to do. Okay, we're going to fetch mutation. We're going to pass in this. We're going to create this in just a second. So I'm going to copy this title and then we're going to pass in the data it needs and the amount and the new key. And then I'm just going to print some error messages and some console logs. Okay. So, let's go into our subscription inside our convex folder and I'm going to scroll down here and I'm going to say export const like this. Okay. And the first thing is the arguments. So, I'm going to go ahead and pass in all the arguments in here. And after this, the next one is the handler. So, I'm going to say handler. And this handler is going to give us all of our values arguments. So, I'm going to go ahead and dstructure it from here. Okay, just like that. And then inside this first also really quick guys, if you don't know what this means, if you don't know what this indoency key is, it's essentially a temporary key that we use to verify that a transaction only happens once. Okay, so this way this key exists once and then it's we resolve it. And so that way the API call let's say if some a customer is trying to make a payment and we create that one indepotency key and that key ends up getting sent to the database and I mean getting sent to the server and then we use that key we validate the transaction and we take the money and then all of a sudden the web hook something happened to the web hook and is sent one more request. This key will no long will be invalidated. So we'll no longer use it. Okay. so that it will will no longer charge the user another subscription. So that's what that is. Okay. So this payment obviously like I said is a little more advanced. So now we're going to check if there's some duplicated independency keys in our database inside the credits ledger then we're going to essentially skip it because there's a duplicate. Okay, we have a duplicate of it. And if not then in here we're going to say the following. So we're going to say subscription equal await database.getair subscription. But if we cannot find a subscription then we're going to say subscription not found. Okay. Then we're going to say last grant cursor if it's equal to the indepotent indepotency uh key in here. Then we're going to skip this and say the cursor uh cursor match right here. Okay. And then down in here, we're going to say if not entitled, and this is essentially an array with two values that help us check the status of the subscription. Okay, I'm going to go up top here and I'm going to say entitled new set active and trailing. And so we're seeing if it's within that. Okay, if it's not within that, then we're going to return this the following data. Next, after this down here, we're going to say grant. We're going to put the default grant and if the grant is less than or equal to zero then we're going to return true. We're going to say zero grant. Okay. Next. Here we're going to basically say literally next. Okay. And we're going to pass in the credit balance plus grant and the default rollover limit. Okay. And then in here we're going to patch this request. So I'm going to say database.patch patch the subscription ID, the credit balance, and the last grant cursor. Then finally, we're going to update, we're going to insert into our ledger, into our credits ledger as well. Just like this. Okay. Now, at the bottom here, finally, we have to return. So, I'm going to return true. Grant grant balance. Next. That's it. Done. Now, let's go back and let's continue from here. So looks like I haven't used this grant here which I need to obviously. So that means that this is still uh something is still remaining here. So let's see where that needs to go. Okay, cool. So we created this step here. So we're going to scroll down here and we're going to hit enter. And then after this we're going to basically console the grant result. And then we're going to check if the grant is okay. We haven't skipped. Then we're going to do the following. So the first thing we're going to do is we're going to send the event to grant the credits to the user. So step.ende event credits granted and it's going to be billing/credits.granted. And we're going to say ID credits-granted with the with the polar subscription ID, the current period. So we can see this uh clearly in there. And then we're also going to pass in some data in here. Okay. And then after this, you can console some messages. Why not, right? So, let's print some messages here. Might might as well put it right here, too. And then finally, for this one, an else statement saying credit granting conditions not met. Okay. Now, we're going to send another event, and this is essentially to always emit a synced and a synced event and to schedule the pre-expiry reminder. Okay. So, I'm going to say subscription synced. So, uh step event subscription synced. and we're going to say billing subscriptions.sync and then we're going to pass in the ID and this data. Okay. And then after that I'm going to say the event was sent to sync and then down here I'm going to have the following. So current period end date and if the current period uh period end date is greater than today's date then we're going to say run at and we're going to pass in the following data in here. And then finally we're going to say await steps sleep until wait until expiry and then again start. Okay. Then we're going to recheck the entitlement at at runtime just like this. Okay. And inside this it's going to take so we're going to say if check if it's still entitled. So step.run check entitlement. And in here we're going to say async function just like this. And inside this, we're going to have a try catch. And let's remove all of this. Or actually, I think it did a good job. I think it got it right. Let's see. So, await fetch query API subscription has entitlement. Perfect. Pass in the user ID. Okay. So, and then we can also print this message. Might as well. Now, if there's an error, um, we don't need to throw an error in here. Okay. So, we can remove this section. Uh actually try okay it's fine let's just throw the error if there was an error. I mean we're inside a try catch right and then if after this if still entitled await step. send event pre-expiry and we're going to pass in the following data. Okay. And that's pretty much it for this handle polar event uh for injust. So you see how much ingest is doing. It can do all of this in the background and you can schedule them and you can get them to fire whenever you want it to fire. Okay, you just have to create those steps. Even for this one right here, it's like a cron job. Essentially, we're saying wait until this thing expires, which is the um the date that we wanted, right? Which is run at today's date plus I even forgot what I put here, but I think this is the next billing, I assume. Um, and that's how we're we're able to trigger a lot of stuff to happen directly on on their end. So, we're telling it to sleep until this specific date. And then once that's done, it's just going to continue from here. Crazy, right? Awesome stuff. Now, we got to pass this into our polar event insideest. So, we're going to go into API inside app APIest route.typescript. And now, let's go ahead and say handle polar event. And let's also make sure we import it. Okay, awesome. And now we have to go back to ingest and we have to sync all of our functions. So I'm going to go back to my app. So I'm going to click right here and I'm going to click on this and say reync app. And you could override input. What does this mean? Don't override. Please ensure that your app ID. Okay. No, it's fine. We don't need to. And let's go ahead and resync. We could not reach the URL. Please verify the URL is correct. This should be correct. Let me take a quick look. All right. Sorry guys. I actually shut down my server on accident and so that's why I was throwing that error. Okay. So now if we try to reync this should work. Boom. Awesome. Two functions found and it also brought in our new polar web hook handler. Look at that. Awesome. Nice. And to look at the previous stats of the previous function that ran, you can click on autosave project. You can check out all the runs. Okay. So you can see every single event, how long it ran for, what was the data that went that went through. Uh ton of awesome stuff inside inest. Now the next thing I'm going to do is I'm just going to shrink this real quick. Let's go back into our application. Let's close this and I'm going to look for my to-dos cuz I remember we had a subscription billing and we commented all of that stuff, right? So let's go into billing. That's hard coding right here. We're going to remove this and we're going to bring this back. Let's check for another uh billing hardcoded in here. So if not entitled send the user back to billing page, right? Um there we go. Just like that. And then let's see what else do we have. So this one's good to go. Um billing. Let's check it this way. Okay. Um billing logic. Okay. So this is the billings page. That's fine. Hardcoded. Remove that. Um, we remove this combined URL page. Okay, this is fine. Billing credits. This is okay. This is okay as well. So, if I try to access anything now, let's just see what happens. Okay, so it sent me to the billing page. Awesome. Now, let's go into our billing page right in here, which is inside source approtected billingpage.tsx. And now we can complete this page as well. Okay. So, uh also don't forget we have to create our billing API endpoints. Okay. Or else we're not going to be able to listen to the web hook. Okay. So, first thing is click on the billing page.tsx. And what we're going to do is we're actually going to create our session in here. We're going to call this user. And we're going to move the page.tsx inside it. Just like that. And now we can actually see something. Okay. Um and then let's shrink this real quick. And let's remove our to-do logic up top here. And then now let's go ahead and remove uh create a div in here. And this div is going to have the following styles. And inside that I'm going to create another div just like this. And this is going to have another div inside this part. Okay. And we're just going to import the sparkles. And we're just going to say unlock s2c premium. Okay. It doesn't matter. You can do whatever you want. Um just make it as simple as possible. And then the next one is we're going to have a card component. So after this div, you're going to hit enter. You're going to create card component like this. And you're going to want to import card. And inside this, we're going to have the card header first. Just like that. Card title as well. So let's import all of this stuff. And uh before the card title, I'm actually going to put a badge here. So I'm going to put a badge. And if you want to speed up this process, guys, you can go to any one of the chats blocks and you can just grab something, right? So you don't have to type all of this. So what seems to be the issue? I think I imported the incorrect badge component. So it's from components UI. There we go. Much better. Then I'm going to have the card title, which is standard plan. And after that, I'm going to have a div that just shows the amount. Okay. I'm going to have a simple description that comes after our header and I'm just going to say get 10 credits every month. Just very simple. Okay, nothing crazy. And this padding is supposed to be padding. Okay, not this one here. Um, usually card is supposed to have its own padding. Let's see what happened. Okay, so I'm just going to put this inside the header itself. Okay, cuz card description I think is for the header section. Card content is for the body. Okay, so let's import the card body component as well. And inside this, I'm going to pass in a div just like this just to give more information on the, you know, whatever this is. Perfect for freelancers, creators, whatever, you know, each credit unlocks, full AI, just put whatever you want. And then I'm going to have another div after this. So, hit enter here. We're going to create a div. Inside that, we're going to create an H3 that talks about what's included. And we're going to have another div after the H3. And this is going to have the information that it's just going to have the information about what's included essentially. Okay? Just like this. Very simple design. And then after this section, so after this flex, you want to hit enter here. And in here, we're going to create another div that talks about the next one. So, I'm going to bring in the download icon. Okay. So, you can download premium assets, whatever that is. And then after this, one more to run complex designs. And I'm going to pass in the code. Okay. And then I'm going to have one more for flexible usage for design needs that uses a zap icon. So, let's import that one, too. And then, finally, I'm going to have a simple credit system is another feature. Okay. So, here, hit enter. And I'm going to say simple credit system. Also, sorry guys if I missed anything. It's just the same thing. If you uh if I missed the section, I missed showing it. It's the same thing. Just pause right now and type this out and then copy paste it over and over again and just change whatever is inside. Okay, let's go back down here. And then once the card content is completed at the bottom, we're going to say card footer. And we're going to need to create the subscription button. But before we create the subscription button, I'm just going to comment this out. And after after this card component here, we're going to put a card footer. We're just going to say something like 30-day guarantee, whatever, 24/7 support, right? And now let's go up here and let's create the subscription component. So copy the title. You want to open up your folder structure and you're going to go into your component buttons. We're going to create checkout index.tsx. And in here I'm going to return a snippet like this. And now inside this first I'm going to make this a use client component. And I'm going to go back and import my component as well. Okay. And then inside this, we're going to remove our props. We don't need the props here. And then in this component, we're going to return a button component. It's going to be very simple. Just a regular button that comes from shotsen. Okay. But yes, I did put some custom styles on it. You don't you do not need to. Just use a simple button. Okay? You don't have to copy whatever I'm doing right here. Just save yourself some time. Okay? And so this is going to need a couple helpers. So, I'm just going to comment this out so we can see it work. So, let's go in here and say subscribe. Something like this. There we go. You see the button right there? Okay. So, yeah, this is a a very simple button. So, you probably don't even need all that crazy stuff. And so, I'm going to go ahead and uncomment all of this. And now, we're going to bring this in. So, this is essentially the use subscription hook. Okay. And uh this subscription hook comes from let's go to to our hooks. We're going to create use billings.typescript. Okay. And inside this we're going to need to ex uh ex export this hook here called the following. Okay, which is use subscription plan. And this is essentially going to do the following. So the first thing we need is another hook. Uh this is not another hook here. This is from our Redux API. So we're going to need the use get uh lazy. Let me see if we even created this query. Okay, we did not create this query. So I'm going to open up my folder structure. I don't even think we created these elements inside of Redux. So let's go to Redux. Let's go to API. And we're going to create billing index.typescript. Okay. And inside this I'm going to say export const billing API equal to create API. We're going to invoke this just like this. And let's also import this. And now I'm going to pass in please do not make any spelling errors here. Okay. The reducer path is as follows. The base query path is as follows. So I'm going to import this as well. And the uh we don't need this. We just need the endpoint. So let's remove this. The endpoints are going to be get checkout. And it's going to say builder.query that comes from here. And we're going to pass in the URL. This is the checkout URL that I was talking about. Okay. So now we also have to export at the bottom this hook. use lazy get checkout query. Okay. And now let's go back in here and now we're going to import this. So I'm going to say grab this this inside the use billing hook. We're going to grab this use lazy get checkout query and we're going to grab the ID from this from our app selector from our store. And then we're going to check we're going to create a function call unsubscribe. Okay. It's going to have a try catch and essentially we're going to await trigger id. So this id.unwrap and then we're going to say window.location.href is equal to that. So we're just creating that subscription link manually. Okay. Polar does have a way to just create subscription links directly in there and copy paste it. We're just manually creating the subscription link. Okay. And then we're returning this and we're setting the current location to this. Then we're also throwing an error if anything happens wrong and we're showing a toast message. And now we have to return the state back. So let's go back here. And now let's import this hook. And now we can use it inside our subscription button. Okay. So now if you click on this it will take you but it will take you there. But there's one problem. We don't have our API endpoint set up. Right. So open up your folder structure. You're going to go into source app API and in here you're going to create the billing route and inside that you want to create checkout. Oh, why does it keep jumping? You see that? Uh, I don't know what's going on. Route.typescript. Nope, not that. There we go. Okay. billing slashcheckout slash uh sorry it's billing API billing slashcheckout so it's not this it's essentially okay that took me a while so there we go route typescript and this is going to be a simple get endpoint that does the following we're going to grab the search params which has a user ID if there's no user already thrown an error. Then we're going to create a new polar client. Okay. And this comes from our Polar uh SDK and we're going to just pass in the environment as sandbox. Okay. You can I also have this set for you default inside the environment just in case you weren't in sandbox. And then we're going to pass in the access token. Then down here we're going to pass in polar checkouts.create. We're going to pass in the products, which is our product, uh, our standard plans ID, success URL, which is our public address/ billing/success, and the metadata. Okay, cuz we need this. And then we're going to need to send this URL location back. Finally, our web hook. So, we just created um, you know, this endpoint that's going to serve us the URL. Now, let's go ahead and create web hook inside billing. Okay, routes.typescript. And in here, this is going to do the following. So, we're going to have a post endpoint. It's going to grab our web hook secret. If it's not there, throw an error. Then, we're going to use this array buffer to get the raw data. And we're going to check if this object from entries from this header from this raw data has our header headers object. Okay? And if so then we're going to proceed down here which is first we're going to create this variable called let verified we're going to validate the event and this comes from polar okay to validate that through web hooks they have this thing where you can say buffer from raw data this is just their own syntax okay we're going to say headers object and the secret the secret came from our polar secret in our environment variables if not then we're going to throw an error here we're going to return for three Okay. Now, if there's polar web hook event, we're going to pass in verification. And if that does not exist, then we're going to say it's an unsupported unsupported data type. Okay? And then unsupported event essentially and return 400. And then down here, we're going to say event equal verified. And then down here, we're going to say ID string. We're going to pass the event ID. And then finally, we're going to invoke our web hook functions from ingest. Hey, look at that. New more new wall new wallpaper. Looks nice. We're going to invoke this inside. Web hook received. And that's going to fire that entire function we just created. Okay. And then we're going to pass an ID and the data just like this. And throw an error 500 and also return 200 if everything was good. So now we pretty much have this set up I believe. So we can give it a shot. We can see how it goes. And if not, no worries. We'll come back to it. Okay. Okay. So I just clicked on subscribe and it threw an error saying that we did not add this to our store. So I totally forgot inside our store. We created this new billing object, this new billing um API, but we did not create we did not add it yet. Right. Right. So, we're going to go into our index in here and we need to pass in the billing API and we also need to pass in this u the project API as well. Okay, so I'm I'm surprised nothing actually happened from there. So, let's go ahead and bring that in. Okay, there we go. I also see this other error that says we need to include the middleware references only once. So let's see where that error is coming from. Oh, never mind guys. I I just asked AI. Turns out I added this once more. So I added project project twice. That's that's why I was saying you could only have that run once. Okay. So now let's go in here and let's click on subscribe and let's see what happens. Okay. Redirecting. That's good news. Hey, there we go. $50 per month and we have the plan access. This is essentially the benefit I think that we created, right? And now you can go ahead and put your credentials in here and if everything is right, if everything is correct, the user will then have entitlement. They'll be entitled to get into the profile into their account and inest is going to fire the function, the web hook. All of that stuff is just going to magically happen. Okay, so give me a second. and let me fill this up. Okay, so I'm just going to pass in some test information and click on subscribe. Okay, fingers crossed. It's still going. Payment successful. Hey, look at that. Awesome. Okay, now there's one problem. Customer session access token. Okay, it was supposed to send me to the success screen and I haven't actually created the success screen yet, right? If you remember, um, let me see success. So, slash success. Okay, so it's supposed to send me here. I don't know if I have. So, this endpoint is called billing checkout. Let's just see. So, billing credits granted. Okay. So, user is not entitled. Awesome. And this endpoint is checkout. So, this obviously was called Oh, that's a huge response. Okay. Oh, so this is the success page, guys. I'm so sorry. Look, this is what the link says, success. So, billing/success and the user's info. So, it is correct, I guess. Or did I put it incorrectly? So I have my app protected billing user page success worked. Oh, that makes so much more sense. It considers this as a user session. I hope that's making sense. Okay, so I'm just going to test this out and I'm going to copy this link here and make sure I'm able to actually get this to work. So let me let me do something. Let me just duplicate this real quick. Okay, so nothing happened there either. All right, just give me one second, guys. Okay, there we go. So, this is Okay, this is what we needed to do on the success page. And now when I refresh that, obviously, uh it's no longer going to work with that old link. Okay, so there you go. It's going to redirect. It's going to take me in here. So, what's happening inside this page? So, inside this page, essentially, here's here's all we got to here's all we got to do. So, first on this page, inside success page.tsx, tsx make it a client component. Use router redirected. Okay, it's another ref and a timer. We're going to grab the current user. We're going to check their entitlement. Okay, if they do have that, then we're going to do something in here. So, we have a use effect that has entitled set inside it. And we're going to check if the they're already redirected. If they are, we're not going to do anything. Then if me, which is essentially this query to get the current user, is undefined, return. We're still loading the user. If not, then we're going to check if they're signed in or not. So me exists or no. If so, we're going to send them to O sign in. Then if we're still loading the entitlement because that other API request is there, right, this use query, then we're going to return as well. And then down here, if we're entitled, then we're going to send the user to the dashboard page. That's the first thing. Then this is 45 second fall back to billing if still not entitled. So if redirected currents if they're already redirected, stop. We're just going to return. If no user yet or they've already been entitled. So no user and they're already entitled and return as well. But if not, we're going to create this 45se secondond fallback saying set timeout if they're not redirected. Set timeout to true. Redirect current to true. And we're going to replace the billing back to the billing page so they can pay. Okay. And then we're going to clear the timeout right here. And for a UI, you I mean I pretty much don't have anything. It just says finalizing your subscription. It it happens really quick. You can't even can't even catch it. Let's go back and see. Okay. There. Uh it's it's really fast. Okay. It's really fast, but it's just going to show finalizing your subscription yada yada. And then just sends me into that page. So if me equal undefined checking your account entitled equal undefined confirming your entitlement and then timed out. Okay. So if it's timed out we're going to say something took place u and broke everything. Okay. And now I'm going to go back to my autosave component which is inside here. Let's click these. Go inside navbar right down here. And now remember we had these credits, right? Let's go ahead and quickly grab these. So for the credit balance, you want to scroll up top and you want to say credit balance use query API subscriptions.get credit balance. We're going to grab that for the user ID. And then down here, we're just going to replace this and we're going to say credit balance like this. And we're going to say credits next to it. Okay. Okay. I trust you guys are going to make that look nicer. So let's go ahead copy this. Let's go into subscriptions up top here. Subscriptions. And let's go ahead and create this one. So this action here, this query here is as follows. So get credit balance. It's a query with the following arguments. It's just going to go into our database. Search for subscriptions with this index. We're going to get the first one and return that back. That's literally it. Okay. And now if you refresh, boom, there you go. Now you can see how many credits this user has. This is awesome. We just built a real production-grade subscription system with our own with our own credit handling architecture as well. And I'm sure you don't you don't need to do all this crazy stuff. You could just use a simple subscription and user if subscription exists update it. If user doesn't exist, create it. And then once you make money, once the SAS starts to bring money in, then you can focus on updating it here and there. Okay, that's it for this section. and I will see you in the next one. In this section, we're going to be focusing on completing our mood board because now we can finally generate designs and themes using AI. So, go ahead and shrink your folder structure right here, open source components, and you're going to find your styles. So, right in here, and inside that, you're going to find your mood board index.tsx. And we already have this uh to-do element here. So, let's remove that. And now inside this we have this button right here. We just need to complete the section. So go ahead and please type in the following with me. So I'm going to remove this button and I'm going to say generate uh generate style guide button. And this is going to need the following. So it's going to need an image file input and project ID. Now throughout this project, first we're going to set up everything and then we're going to go into our AI uh dashboard and then get all our credits, all that kind of stuff. Okay. So for now, first let's create this element. Now this also requires the project ID. So we might as well just pass it in before we proceed. So I'm going to scroll up here and we're going to need a couple things, right? So up here, let's go ahead and say search params. So let's grab that and let's make sure this is use client. And then after that, we're going to grab the project ID. And that should solve this error right here. Now go ahead and copy this component and you're going to open up your folder structure. You want to go into buttons here. And then inside this, you're going to create a folder called style dash guide and index.tsx inside this component. And then I'm going to go ahead and return our React fragment, sorry, our React snippet. And then this component is going to accept those props. So let's bring that in. Let's go ahead and also dstructure them from here. And now we're going to need to essentially render out a button here. So let's go ahead and say the following. So I'm going to remove this return. And I'm going to say return if images.length are greater than zero, then return this button here. And then we also want to have an onclick handler disabled and then some loading states. Right? So let's just quickly go ahead and import these icons. Okay. Why is it not Okay, there we go. Awesome. And so now let's bring in these states. So this essentially needs to first render. So I'm going to go back one page and import this style guide. And then let's see if we can find this button on our mood board. Okay, we're seeing an error. And the error is because of all of this, right? So what we could do is we could just hide it. But we already know what the button is going to look like. It's just a regular button that says, you know, generate style guide. And then we also have just have some loading states. So, let's go ahead and hit uh enter here. And let's change this to use client. And then up here, we're going to need to create a hook called use style guide. And this hook is going to give us two different things, a loading state and the handle generate style guide. Okay. So, go ahead and copy this title. Open up your folder structure. You want to go to hooks and you're going to say use-styles. Uh, sorry guys, we already have it in here. Sorry about that. We're going to scroll to the bottom and we're going to say export const use style guide. Um, just like this. And inside this function first, we're going to grab some parameters in here. So, we need the following. So, let's bring that in. And this needs something called ref object for the final file input ref and images. And then the project ID. So now we need to get a helper function called generate style guide and uh this is going to come from use generate use generate style guide mutation. Okay, so let's go ahead and grab that. So open up your folder structure. You want to scroll down into your Redux folder API. You want to go into your style guide right in here and inside index all the way at the bottom, we're going to need to create that mutation. Okay. So all we're going to do in this file very straightforward. We're going to create a simple create API like this. Okay. From query this should be fine. And we're going to use the fetchbased query. But make sure this is API/generate. Okay. And then we're going to need two types here called generate style guide response and the request. So let's bring those in. Okay. So that should solve those bugs. And then for the tag type, for the tag types, I'm just going to pass the following. And this query function in here is going to be the following. So these are the endpoints, not the query function. These are the endpoints here that says generate style guide, which is builder.mutation. And we're going to pass in the request and response. And then uh I'm sorry, we're going to get this request and response here. And then in here, we're going to have the query set the UR for the URL URL set to style. The method is post and we're also going to pass an invalidate tag. Okay, so it's going to invalidate everything for this. Now down here, we're going to need to export this, but it looks like something is wrong here. All right, guys. So the error here was that we imported this from query, but we want query react. So go ahead and import that, and then this shouldn't throw any errors. Okay, so go ahead and copy this title. And now we can go back to our component and let's import this. Okay, so I'm going to say generate style guide. I need this. And this is going to be is loading set to is uh is loading, which is is generating. And we're also going to need to import this. Now, we're supposed to actually build out this endpoint, but we we're not going to do that right now. We're just going to go in this order. Okay, let's first finish this section and then we'll go into that. So, first I'm going to need the router. Then I'm going to create a handle upload click. Okay. So I'm going to bring that in as well. And in here, this is essentially going to help us open up a file, right? It's going to help us open up click on one of the inputs and manually open them. Okay. And then down here, we're going to have another handler called handle generate styles, which is equal to an async arrow function. And inside this error function, we're going to do the following. The first first we want to check if there is any project ID. So no project ID, then we're going to throw an error. If that's good to go, then we're going to check down here if the image length is equal to zero. If so, throw another error. Then if some of the images are still in uploading state, we're going to throw an error there as well. And if not, if everything is good to go, then we're going to have a try catch and we're going to say loading. So analyzing the mood board and we're passing in uh just some some sort of designs here. I mean, this is just configuration for the toast. Doesn't really matter. And then down here next, we're going to have this function that we just imported. We're going to pass in the project ID into it. And then if this is successful, we're going to show another toast. And then we're going to do router refresh. Okay. If and once this is done, we're going to say toast success. We're going to show a toast message. And I'm also going to set a set timeout. And this timeout is going to show another one saying the style guide is generated. Okay. And switch to the color tab to see the results. Then finally, if there is an error, I'm just going to print out all of the stuff. Okay, just like that. There we go. And now at the bottom here, we have to return this. So return it from this function from this hook just like this. Okay. And now we can import our use style guide hook. So now we can use all of this. So inside this page, now that we have this down here, this shouldn't have any problems. Okay. So you see generate with AI, right? If I click on this, obviously it's not going to work. It's going to throw an error and that's because it's a 404 error or 404. There we go. Because we haven't created that API endpoint, right? And so we have to go ahead and do that next. So go ahead and open up your API folder. And inside that I'm going to create generate. And inside this we're going to have redesign a couple routes. So please follow with me. First let's just do what we need. So we only need style. And inside this we're going to have a route.typescript. And this generate is also going to need another route.typescript. But I'm just going to leave it at it for now cuz I want I wanted to throw an error so I know that I have actually completed or not. Right. So the next thing is this is going to have a post function. So let's bring that in. Okay. So it's a post endpoint and inside this we're going to have a try catch just like this. And first thing is we're going to grab the body and grab the post ID from the body. And if there's nothing throw an error. Okay. And we're going to use next uh response to throw that error with a 400. And if everything's good to go, then we're going to call this uh we're going to essentially call this function. And this is another query that we need to create. So go ahead and copy this name. And you're going to open up your query.config file. Okay. I'm just going to click through here and I'm going to scroll to the bottom. I'm going to say export const. Just like this. Okay. And inside this, the first thing we're going to need to do here is we're going to need to grab the profile info. And then we're going to normalize the data. And then finally, if there is no profile ID, we're going to return false and say balance zero profile null. Right? If not, we're going to grab their user the user's credits. Okay? We're going to say get credits balance and we're going to grab the balance and then we're going to return. Okay, that's pretty much it. Okay, make sure this is exported. And now that should solve this error. All right, there you go. Make sure you're importing that. Now, if the balance is not okay, we're going to send a 400 error. Okay, and if the balance is zero, we're going to say you're out of credits. And then we're going to essentially create another one called moodboard image query. And this one is essentially just going to help us grab all the images for that project for the that's inside the mood board essentially. Okay. So let's go ahead and just import this one. Okay. We've already created that. So let's bring that in. And then we have to check if there's nothing inside the mood board or the moodboard images is zero then there's no moodboard images. So just throw an error. Okay. And if not, then we're going to say const moodboard images dot uh images.json. We're going to store that inside this. And then we're going to map over those images. And we're going to find to make sure that all of the images have a URL. They have a value. And then we're going to say system prompt equal prompts.styleguide.system. Now our team spent about two three days just creating this prompt. It is good enough. Obviously I expect you to improve this. Okay. Everything is based on your on the AI prompt that you create. That's the final secret. Okay. So as long as you can get that AI prompt to be exactly what you need, you will get a consistent outcome. Now it's all not always going to be the a consistent outcome. Sometimes it might change, but you got to try your best to get it as close as possible. Okay? And yes, I will also give you this completely for free and you can access it from the description through the YouTube kit or if you purchase the codebase, you're going to have that in there as well. Okay. So, what we're going to do is we're going to go into our folder structure and you're going to shrink everything in here actually and then you're going to create something called prompts and inside that an index.typescript and like I said, you're going to get this prompt for free. Okay, it's a huge prompt and it does a bunch of stuff. It has two things. It has a generate UI prompt which is you have to create all the the designs and we also have the system which is style guide related stuff. Okay. So for this one right here we need the style guide system prompt. So I'm going to grab that from there and I'm going to pass it in here. Okay. Then the user could also add some messaging. So I'm going to say analyze the images mood board whatever whatever. And I'm giving it some extra prompts as well. Okay, so this is a user prompt. Uh, sorry guys, let me rephrase that. This is not users message. This is a user prompt. So part of the prompt body needs to have two user two roles, right? The system role and user role. And so that's why we're putting the user role here and then the system prompt is in here. Okay. So now let's go ahead and generate that. So I'm going to do the following. So I'm going to say const result equal generate object. And this is um let's go ahead and see where to get I think this is the generate object function is native I believe. So ah okay sorry about that guys I thought this was a different type of generate object. This is an AI call, right? So, this is essentially from a package uh called Versel SDK. And all you have to do for this is pretty much say npmi AI. Okay? But I'm going to give you my specific version number to install. So, open up your terminal and you want to say npmi AI at the following version number and go ahead and hit enter. That's going to install this this package for us. Okay. And now let's go ahead and import the generate object function from AI. Okay, there we go. Now the next thing is we also have to install the type of AI SDK we choose to use inside this prompt. So in this project I'm going to be using Anthropic, but I also want to help you understand why we made this decision and why you should also make this decision if you choose to launch this as a SAS or any other SAS as well. Okay. Um so anthropic and GPT they're two different I mean very popular right from open AAI and we have clouds right which is anthropic but both of them have different use cases anthropic in my opinion is just much better when it comes to generating code analyzing code all that kind of stuff and even claude is going down that route you can see claude code coming up and I have a subscription to everything okay I love using AI so they are their expertise is AI generated code that is anthropics and so if our application is going to be generating code it's probably a better option to go with anthropic right now what what's the trade-off it's a little more expensive that's the only challenge but you're going to get an industry-grade output which is what we need if we're going to run this as a SAS the other option is to use GPT now GPT is cheaper yes obviously it is cheaper and I think GPT's expertise is is more human to AI connection than web developer connection if that makes any sense. And so right now GPT is not going to be the best option for us. And so that's why I I'm basically going to be using anthropic in this project. Okay. So go ahead and open up your terminal and go ahead and type the following. And for the version number, you want to put at and then you want to say 2.0.6. Okay, this is the version that I used in this project. And then go ahead and hit enter. And that's going to install our package. Now, let's go back into our code. And now we can install this an uh import this anthropic from up here. So, we're going to say import anthropic just like this. And now, let's go down here. And now you shouldn't see any more errors. Great job. Now, we need this style guide schema. And we already actually I thought we already installed it. Let me go ahead and uh let me go ahead and create the schema. Guys, give me one second. Okay, so I'm just going to put it up here. So yeah, you can put it right up here. It's just a schema. So I'm going to say style guide schema needs all of these things. Okay, it's going to have theme description and the colors section. And forget about the Z for a second. All right, that's just Zod. And then we're also going to have the typography section. So let's go ahead and import Z from Zod. And now we're going to need to bring in these different types or they're not really types. They're actually uh another more ZOD schemas. So here is the primary color. Okay. And this is going to take the title and it's going to have all of these swatches. And for the color swatch itself, I'm going to create another schema that has the following. Okay. So please pause and type this out. Then I'm going to do all of the others which is the secondary UI utility and status colors. And this is exactly what that's going to look like as well. So please pause the screen and type this as well. Okay. And there we go. Now we also need the typography section. This is also very straightforward. We have two of them. First is a typography schema. It's going to look like this. But then this is going to need the style schema for these styles. And that's going to look just like this. Okay. So please pause and type this as well. And that's it. Now we're done with our schema down here. So and now that we have consumed Anthropics AI, we obviously need to consume credits, right? So that's our next step. So let's go ahead and create this consume credit query. So open up your folder structure and you want to look for consume. Sorry guys, it's query.config. I'm just going to hack in from here. Okay. And now let's scroll all the way to the bottom. And now all we're going to do in this file is as follows. So we're going to say consume credits is an async function that takes in the amount just like this. So how much do we want to consume and then down here we're just going to say raw profile and grab the profile data. Normalize the profile data. If no profile return false, right? Very straightforward. And then we're going to create this fetch mutation that's going to use this helper that we're going to create onto the API layer called consume credits. And what that does is it just passes in the amount and if not we're just defaulting it to one. You can probably put this inside of your environment files. Okay. And then pass in a reason the UI ID as well. Uh the user's ID as well and then the token. So let's go ahead copy this and let's open up our folder structure. Let's go up top into convex into subscriptions. And at the bottom here, we're going to create that consume credits function. Okay. So go ahead and say export const consume credits equal to a mutation just like this. And then we're going to pass in the arguments. So you're going to say args and just pass in the arguments. And then we're also going to need a handler. So go ahead and pass in a handler. And this handler is going to give us this entry and also all of the arguments that we just passed in. So let's grab that. And then in here we're going to say if the amount was less than or equal to zero, we're just going to return false saying invalid amount. Then we're going to check the indent potency key. Okay, it's so hard to say that word. I don't even know if I'm supposed to say it that way. But essentially, remember I told you how the key works, right? We're going to query the ledger for this index. We're going to check if the key that's in here, right, is equal to the key that was passed in. Okay? And then we're going to grab the first one from that. And if there is a duplicate one, if there is a duplicate key, then we're just going to return okay, true and say the the key um the indent potent key is true. Okay, if not down here, we're going to go here and we're going to say get the subscription for this user and we're going to grab the first subscription that they have. And if they don't have, we'll say something's wrong, no subscription. If they don't have any entitlement, that means if they're not active, right? Remember we have active and trailing. If we don't have that, then we're just going to return false and we're going to say not entitled. And then down here, if subscription credit balance is lower than the amount, we're going to say insufficient credits. Okay? So this way, you're limiting your user to only 10 credits per month. Okay? And then down here, we're going to say subscription.credit balance minus the amount, and we're going to store that into the database by updating it uh through a patch request. So update your subscription uh sub update by subscription ID and you want to pass in the credit balance and what's the new credit balance essentially. Then we're going to update our our credits ledger just like this. Okay. And we're going to pass in the new data into the metadata here so we can you know come back to this later. And then we're going to just return a true from here and balance set to next. And now let's go back and this should solve this bug here. You're no longer going to see this. Okay. Awesome. And then that's it. Like I said, at the bottom here at the credits uh consume credits query, we're going to return okay the balance and the profile. So now let's go back into our generate style uh into our style folder right here. Route style route. And then at the bottom here, we're going to essentially invoke that consume credit call. So at the bottom, I'm going to say consume credit consume credit query. And we're going to pass in one as the amount. and we're going to say not equal. And if this I'm sorry, not equal to okay, then we're going to return 500. Now, we're going to essentially store all of this generated data, right? We're going to store all of this generated style guide inside convex here. So, what I'm going to do is I'm going to say fetch mutation like this from convex. We're going to bring in our API from the generated folder and we're going to have this update project style guide. Okay. And we also need this token here. So, I'm going to bring in this token as well. And let's also bring in the ID. All right, there we go. And now we're going to create this one. So, copy this. And then you're going to head over into your folder. Inside your folder structure inside projects, you're going to scroll down here. And then in here, we're going to say the following. So, I'm going to say export const update project style guide, which is a mutation. And that's going to have the following arguments just like this. Okay. So this is the JSON value. We're storing that in our database that way. And then in here, we're going to have the project ID. Next, the handler is going to have the following. So I'm going to say authenticate. So now they're authenticated. Throw an error. If they don't own the project, throw an error. And then here, we're just updating. So style guide, uh, sorry, db.patch, project ID, the style guide, and last modified. Okay. And then return success, and the style guide back to the front end, uh, back to the, you know, wherever it's been called from. And that's it. So now this error should also be solved for you too. Now once we have consumed the credits and we have given the response at the bottom here. Now we have to say sorry we have stored this response. So consume credits saved it in the database. Now we have to return the response. So we're going to say style guide generated successfully and throw uh send back success true. And if there was an error, I'm just going to say console log error like this. And we're also going to return 500. Awesome. So now the next thing is we need to get some anthropic credits so we can actually use this, right? So let's go ahead and grab that next. Now from this section onwards, I'm not going to be able to show you my AI credits and my API keys and stuff like that just because that is confidential information and the internet is a very dark place. So what I'm going to do is I'm just going to direct you exactly to where you should go to grab this. Okay. So first thing is there are two links. There's console.anthropic and you have the regularanthropic.com. This is for claude code. Okay. At least that's that's how I've understood it. And then claude aai is also for claude code and the claude chat. But console.anthropic Anthropic is where you can grab credits from here. So go ahead and click on Enthropic Console and then in here you're going to click on continue and go ahead and just log in. So I'm using a testing fake account so you're not going to see any of my credits but I'm just going to show you where uh where to go. It's going to take you in here. Go ahead and just you know sign up, do answer whatever questions they have and then it's going to take you into this page. Okay. So, if you don't see this page with nothing inside this section, obviously this will change in the future. It probably already changed, but the whole point here is you're not inside your Claude code. You're not inside Claude AI. You're inside your console. Okay? So, if it takes you to this page and it gives you the option to generate an API key, you're good to go. That's that's what you want to focus on. So, go ahead and click on generate API key. It's going to ask you to purchase credits and then go ahead and buy about $5 worth of credits. Now, I would recommend you do 10 and 10 or 15 because our app is pretty expensive, okay? Cuz we have image generation. We have a lot of uh inspiration designs, all that kind of stuff. And we're also for we also have style guide that uses inspiration images, right? So, obviously work on this. I'm just showing you what the what you can do inside the app. Feel free to strip out what's not needed and optimize some of the things that are in place. Okay? But I would recommend you put $15 in place. By the way, I do not make any money from this. I am not sponsored in any way. This is not an affiliate link in any way as well. All right? So, go ahead, purchase these keys, uh, purchase these Enthropic tokens, and then credits, and then you're going to get an API key. Okay? You want to copy that enthropic API key and you're going to go into enthropic key inside your environment variable and you're going to paste it in here. Okay? So, make sure you paste it right inside this location, not inside OpenAI, inside Anthropic. And if you're using OpenAI, I've already showed you how to do that in all of my other videos. So, you can go to those videos and watch how I did it. In in I mean, in fact, I think the last video we used OpenAI, okay? So, go to that and watch how they did it. I mean, how I did it and how I got the key for that. Okay, so that's it. You will not see my environment file anymore. From now, I expect you to know where to put the keys. And I mean, we're pretty much done. We already have all of our variables in place, so we're good to go. But from now, all I'm saying is you will no longer see this. And if you do see it, please do not use my keys, okay? It costs me money and I do not want to go bankrupt. Please. Thank you. Appreciate it. Okay. All right. So, that's pretty much it. I'm going to go ahead and grab my key and then we'll proceed. All right, so I've just added my keys in place and so we should be good to go. Let's just see where we are so far with this generate with AI button. Okay, so I'm going to go ahead and click on this. I don't even know if I have enough credits. I'm going to see if I have to add even more. Um, okay. I think we should be fine. Um, let's go ahead and generate with AI and let's see where we are. Okay, so it says fail to generate style guide. Let's see what's going on. Okay, looks like we made the same error again, which is we did not create this style guide uh slice inside our Redux store. So, let's go ahead and open up our Redux store and let's continue from there. So, in here inside the API folder, guys, not the slice, this is the API folder. You're going to go into your index.typescript and we already created this in here. We just need to import our style guide. Okay, just like how we did for this. You see we did project API. same way we need to do for style. So I'm going to say style style guide API and we're going to need to import it. Obviously this is a lowercase s and same thing here as well. And so now we have that set. Awesome. Okay. And our AI retried this call and that's how we have this running in here in here. Okay. So it's picked up some images from our mood board. Okay. Something looks wrong. Did I shut down my server? Ah, okay. I get what's happened. So, because we're we are on the free tier of our Enro account, we we will obviously need to upgrade because we have reached the limit of how many requests you can make to this to this uh to this address on the free tier. Now, what I would recommend is if you are really on a budget, you can just create a different account. I hope this is not against their terms of services. Do whatever you want at your own risk. Okay? Um, and you could use a new ID in you could use a a new URL in here, but keep in mind you have to change it everywhere. Okay? You have to change it inside the app. You have to change it inside. You have to change it. When I say inside the app, I meant ENV. And obviously, I can't show you that, right? So, inside your env. So, make sure you do that. And you can do that through here. So, click on app and then you want to make sure you overwrite. So you click on reync and you override the input and you want to put the new address and update that once more. Then you want to do that inside con inside convex as well. So you want to go into your application. You want to go into settings into environment variables and you're going to go to site URL in here and you're going to replace this with the new URL. Okay? And this is the same uh you know the full URL itself. So make sure you update it in here as well. And then obviously you need to also do it inside your Google Cloud console. So you want to go into your Google Cloud and you want to update it for the redirect URL and also the original URL. You're going to need to put that in there as well. Okay. So and anywhere else that we need to do this, please go ahead and pause this video. Take some time to update this key and then we'll continue. All right, guys. I had to jump through hoops to get this new U. All right, guys. So, I had to jump through hoops to literally get this set up, but now I have my new URL. And one more thing I forgot to tell you is you're probably going to need to also update your uh your web hook endpoint inside Polar. Okay. And now I need to sync my ingest as well. This was this was so much work. I'd rather just pay for the get the pay tier, but okay. So, now we have the new functions. Okay. Our functions have been installed in here, too. And this did not create a different app. app. I hope so. Okay, so the app ID was the same. So, it did not create a new app. Instead, it just use the same app and just use the new URLs. Okay, that was a lot. Now, I recommend you just if you actually building this in production and I would recommend you just buy their Enro page here. Okay, it's very affordable. You just grab it and then you can use it for your um without, you know, going through the hassle of changing it back and forth. This took me some time and like I don't know how many services you're going to have in the future where you'll have to keep going in and changing it all the time. Okay, it's just a hassle. All right, that's pretty much it. And as you can see now, I have consumed some credits up here, right? Because I ran this a bunch of times after the video was done and uh just to see if things were running. And if I do this once more, let's try analyzing mood board images. Okay, awesome. Okay, there we go. It says style guide generated successfully. Style guide generated switch to colors to colors tab to take a look. Hey, look at that. We have a brand new set of colors and it is using this font that I actually don't like. But hey, AI says what it is, right? So, I'm just going to go with whatever AI said looks awesome. But take a look at this. It generated a full color palette based on the theme we uploaded. It took the same orange yellow hue, right? And it created it its own accent color. and it did a lot of work. Okay, so great job to Enthropic. Thank you so much for saving my life. Now, for the best part of this project, we're going to need to move into generating uh move into the next section where we can generate designs from our sketches. Okay, so let's go ahead and proceed to that next exciting part. And also, really quick, I just want to show you, you see, we clicked once more and it consumed one more credit. Okay, that's pretty much it. I just wanted to see you that uh just wanted to show you that that works as well. So, the first thing we want to do is we want to go into our index.tsx under components canvas shapes index.tsx. Okay, I found a to-do item here. And so, we obviously need to complete that as well. And in order for us to get the full experience of this, we're going to also need our inspiration window to show up. That way, we can add images into that and generate designs based on the inspiration images. Okay. So, first things first, scroll down here to the bottom. And inside this section, we're going to need to create another component to render from from this uh switch case, which is generated UI. Okay? Cuz our shape type can also have uh generated UI as well. So, that means the next section which is the image here, which is basically this right here, right? This one, this is also a component. This is also a renderer. So we have to render something inside for that component too. So that's why we're creating this. So hit enter here. You want to say case and you want to change this to generated UI like this. And for this case we're going to return a component. And this component is called generated UI just like this. Okay. Now copy this title. You want to open up your folder structure. And inside the shapes folder, you're going to have this generated UI folder in here. Okay, it's going to have it's also going to have an index.tsx and it's also going to have uh some more stuff in here like the chat and stuff like that. And we'll get to that in just a second. But first, let's go ahead and in uh return a component here. So, I'm going to say tsx like this. And we're going to return a component here. And let's also make sure we import this component. Okay. Now, inside this component, we can then go ahead and do the following. So, this is first going to bring in some props. So, let's go ahead and grab those props real quick. Okay. And now, this needs some type as well. So, first, sorry guys, we need the types in here, not the props in here. I put the wrong I mean, yeah, there we go. That's what we need. And I'm going to import the generated shapes. And let's dstructure and grab our props from here. So down here, we're going to render a div, but this div is going to have the following styles. And it's also going to have a container ref. Okay. So let's go ahead and create that. Uh actually for this container ref, we're going to need to have another hook. All right. And this hook is called use update container. And this hook is going to do not not too much, not something too complicated, but just enough for us to get some helpers that we can place on top of this. So, go ahead and open up your folder structure. And you want to look for use dash styles like this. Click on this. I'm just going to hack through it. Okay. And then I'm going to scroll all the way to the bottom. And at the bottom here, I'm going to say export const use generated UI like this. And this is going to be an arrow function. And this arrow function is going to get the shape here. The bish is of type generated UI shape. And then inside this, we're going to first grab our dispatch. So let's bring that in. Then we also need a ref called a container ref. So we can pass that in as well. So I'm going to bring use ref in here. And then we're going to have a use effect. And this use effect is going to ensure that the the shape of the the height of the shape is updated when the content also changes. Okay. So inside that content uh this one that we're creating right when content has been created inside we have to manually increase a height. So that's what we're trying to do here. So for that we're going to say use effect if container ref like this. So if container ref.curren current exists and the shape has a UI spec data which is a different type of element inside it then we're going to create a timeout and this timeout is going to get the offset height and if there is and if that offset height the actual height is greater than zero then we're going to do some math here we're going to say this should be greater than 10 and if that's the case then we're going to update this shape okay and we're also creating a little more uh spacing here so it can perfectly fit inside and we're going to set this to every 100 milliseconds. Uh every 100 milliseconds. That's correct. This is milliseconds. And we also have to clear time out here. And the most important part is this dependency array. So please you please make sure that you pass this in here the way I did. Okay. And now we're so what we're doing is we're going to be using HTML. Okay. And the reason why we're using HTML is because when we use something well you can you can obviously use chats if you want, right? Now the challenge in using Shatsen is that you have to make sure that the database can handle all of that JSON data. Okay? Cuz it's it's a it's a longer file. It can give you the right it can give you exactly what you want. In fact, you can get whatever you want here. You can get spelt, you can get HTML, you can get whatever type of code you like, right? But the complexity is that you have to make sure that you can store it correctly in the database. So what this means is you'll have to either store it as a string and no longer as a JSON object. Okay? So you'll have to store this entire path which is which is basically storing the metadata of all of the elements on the screen as a string inside the database instead of JSON so that it can handle the large text. Okay, so that's one challenge. And because I set it up this way using HTML, I'm going to continue to use it this way. But I've given you the secret sauce. This is all you need to do. Just tell AI, here's my question. Yeah, just open up cursor. Here's my problem. Here's what I want. I want you to use Shadzen instead. And it will use Shadzen. Okay. But that brings another huge problem. If you're using Shadsen, you have to be able to map each and every shaden component within your app. Okay? So that means you're going to tell AI that I also want you to create a mapper a mapper file and each component will be mapped to your UI components folder. So that's one more thing you have to consider. Okay. And then on top of that each of them should also have the ability to accept the custom colors and the custom fonts all that kind of stuff that you just created for those elements. Okay. Now, that section, I've already built it for you, which is using your themes, and I'll show you how that works. But I just want to help you understand what comes with the new feature that you add. And so, when you think of a new feature, think of what happens more to that. Is there anything else you have to do? Okay. So, so far that was a big challenge. And then that's going to mean that I have to deal with a whole different rapper and then whole different elements. And that's that's way out of the scope of this video. My goal here is to give you as much as I possibly can in the shortest span of time possible. Okay. So now what we're going to do is because this is HTML, we're going to need to essentially mount the HTML inside the div using a property called dangerously set inner HTML. Okay? And that's the only way to mount it inside it. But we have to sanitize this HTML text or else that could be a security breach. Okay? So what I'm going to do is I'm going to create a sanitize HTML function and I'm also going to put a comment here for you. Okay. And so this is going to essentially sanitize that code. So let's go ahead and return this back through this through this hook. And now we can bring this in from up top here. Okay. So I'm going to say const sanitize HTML and container ref from this new created. Sorry guys, I used the wrong name here. This is not user generated um UI. I think AI did that without without even telling me. Why did it do that? Um and I see an error here. Okay, that's good. So, let's just go back real quick. And now let's import this one. Okay, there we go. And so now that we have this, we can pass in the container ref into this div. Awesome. Now, inside this div, we're going to have another div in here. So, I'm going to say div just like this. And this div is going to have the following styles. And please set it to the following height as well. Okay. And then this is going to have another div inside it. So you you guys can see the code comments, right? So for some areas inside the codebase, like I said, I put a bunch of code comments for you. So you could read through that. Okay? And especially for our main, you know, infinity canvas. I put a lot of code comments. So it helps you understand a little bit more. And you obviously have AI, so it's going to help you understand even more than what I've already written. Okay? So, don't forget to grab the codebase. I'm sure most of you already grabbed the codebase to, you know, follow along with this YouTube video, but um I would highly recommend if you're looking to start this as a SAS, you can build all of this from scratch. You know, obviously there is a license and you will have to grab the license, but um if you do want to just start, right, that means grab the codebase, make a few changes to make it production ready, right? So it it reduces your your um your build time by 3 4 months so that you can just sit and just focus on security authentication and just making it a little nicer, right? And then you're set to go. You can hire a developer online for 1K or $500. Ask them to just do it. $500 is crazy, but I'm just saying it's only going to take them a couple hours maybe, right? Probably one week of time. So they're not going to charge you tens and thousands of dollars. Okay? So, get someone online that can help you from Fiverr, wherever you want, and ask them to or get a friend, right? You could do that, too. You guys could team up and do this together and grab it. It's on a, you know, it's on a deal right now. And this is for a limited time only. Okay. So, grab the codebase and pretty much you'll have everything that you need set up, ready to go. So, that way you don't have any errors on your end. Okay. So, the next thing I'm going to do is I'm going to use my liquid glass button. And this is going to use a handle export design function. So this way I can export the design as well from here. Okay. So I'm going to scroll up top and I'm going to create that handle export design function. It just checks if there's any shape data and then it just uses the export design function that's passed in here. Okay. So then inside this section I'm also going to pass in the download u button in there. And then I'm also going to have another one called workflow. So let's import this one too. And this one essentially is going to generate the workflow from here. So what is this workflow? So in my design, this is another bonus feature. Okay, but it's not part of the I mean you're you guys are getting everything, but what I'm saying is this was like a bonus feature that I added towards the end. And essentially in the beginning it was only sketch to one design like this. Okay. But then I wanted to see the entire flow. I wanted to see every single design that I need after that. So not every single but maybe four or three pages, four or five pages, right? Which is what happens from here. This is the dashboard page. But what about all the other pages, right? And so that's the next section which is generate workflow. But I didn't want that to generate instantly and once, right? I wanted the user to have the option to generate the workflow because it's very expensive. Over time, you're going to spend $1 for the entire workflow, right? And if the user starts texting with the AI, that's going to make even more changes on top of that. So you have to keep all of this in mind. Okay. And I think in the in inside development for even more optimization, I removed the images that were going to be added from the inspirations tab during the chat mode. I think that's what I did because um AI already has context of the code and Claude is pretty good with understanding that stuff. Okay. So, uh that's what the handle generate workflow button does. The next one is the message. So, if you want to text each and every workflow, you're going to need to have this message, right? So, I'm this is going to essentially help us toggle the the chat window. So, I'm going to go up here and I'm going to invoke this. And this comes in from our props. We're going to invoke that. So, that opens up our chat window, which we haven't created yet, obviously, but we'll get to that in just a second. Now after this div we're going to hit enter and you're going to say if something exists here then I want you to render the dangerously set inner HTML prop property with the HTML set to the sanitized HTML. And then down here we're also going to generate we're going to we're going to generate like a a loading screen. Okay, just to show that we're generating the design. Awesome. Then after that, at the bottom here, we're going to hit enter after these two divs. And I'm just going to say generated UI just like this. Okay. Now, there's a bunch of things we need to create for this. So, please just bear with me. Let's go back one step. So, remember we created the use frame function, right? The use frame right here. And that that has something called handle generate design. Now this handle generate design makes an API API endpoint call which we haven't completed. Okay. So let's go ahead and complete that section. So just as a quick reminder this section does the following. Okay. So it first gets a dispatch. We have a generating uh you know uh state in here and then we're going to grab all our shapes that are from our store and then we're going to have the handle generate design button. So we first set it to true. Then we generate the frame from the snapshot which we've already created. Then we download a blob so the user can see that. Okay. So we download blob pass the snapshot whatever this is. Actually this is not for the user. This is essentially for for the AI. Okay. Then we're going to create the form data like I mentioned and we're going to append all of the data the image and the frame number to this. Okay. Then down here, we're going to grab the URL params and we're going to set that to a new URL search param just like this. And then down here, we're going to essentially get I'm sorry guys, we're going to grab the URL param from our window location.arch and we're going to extract our project. Okay, the project ID and then we're going to say if the project ID exists, then we're going to append that to the form data. And now we have to send that response to AI. So I'm going to say response equal await API/generate which we haven't created yet but it's a post request and we're going to pass in the form data. Then if the request is great we're going to show um you know I mean if it's not okay we're going to say an error took place and if no error took place then we're going to generate a UI position because we need to now place this new UI design next to the frame right somewhere next to this right here. So that's why we're going to do this right here. Okay. Then we're going to generate um essentially the UI shape itself. And in order to do that, we're going to need an ID. Okay. So I think nano ID essentially does a it's from Redux, right? And it's going to generate a UYU ID for you. And you can also use a UI UU ID package if you'd like, but I'm going to use what Redux is already providing. Then we're going to dispatch an action called add generated UI just like this into our store. And then I'm going to pass in the positions, the ID, the UI spec data, and some uh something else called source frame ID. Okay? So that way it can paste it right next to it. Then what's next? Now we need to stream the response. So this is essentially another cool feature in our app which means we're going to be streaming the response to the front end instead of just saving it in the back end. Okay, that means doing it on as a background job. Now you can use ingest. So this is where ingest also has some awesome options for you. So instead of having to do all of this yourself um by streaming it, let's say if the user closed the browser, you're going to lose this data, right? So what do you do now? Well, here's where you improve the app even more. Okay, so you might want to uh still use a background job. Okay, so take that up as a challenge. I think that's a pretty good challenge. I've taught you a ton in this video, so I hope you were able to take that back home. Consider it as homework. Okay, so all you'd have to do is you'd have to create a background job, but you cannot track the response from a background job. Okay, at least that's what I found. I wasn't able to and that's why I had to strip that part out. But essentially, if you had Versel's uh SDK and Versel's streaming streaming API inside this, then you could stream it from that as I mean, I thought you could stream it from that, but I wasn't able to. But what you could do is you could have a background job that's running, right? that will essentially save half of what's generated or as much as what is generated so far because this is streaming right now. So you could have a background job that saves it or you could just use your your autosave background job and save that data in the back end. So that way as the data comes in you keep saving it over and over again. Okay? It's pretty much the same thing that would happen if you were streaming it and saving. It doesn't make a difference except now we're offloading that to the background job which is a perfect opportunity because if something happens and something breaks the background job will fire that once more and it will handle everything. Okay, it's going to handle the scalability. It's going to handle u to make sure that it actually fires again and stores the data. So that's another challenge for you. So I hope you're able to accomplish it and if you do, you know, feel free to stop by our Discord and show showcase what you've done. Okay. So now we're going to stream this uh stream this data. So I'm going to say decoder equal to text decoder like this. And the accumulated markup is going to be into a text just like this. Then I'm going to create a timer. So I'm going to say updated time sorry let update time last update time equal to zero. And we're also going to resign a value. Okay that's fine. And then here we're going to create an update throttle uh throttle that essentially helps us update every 200 milliseconds to reduce the flickering that's happening. Okay, so this is essentially going to grab the new updated data every 200 milliseconds. Now I'm going to say if reader then we're going to have a try catch and inside this try catch we're going to create a while loop. So while this is true in here we're going to say the following. So await reader read. And if this is completed, we're going to update it. Update the database. So sorry, update our store with the with the final accumulated markup. Okay, just like this. And we're going to say updated shape like this. We're going to pass in the data and whatever we need to patch up with. And we're going to break out of it. Okay, so I think we're actually saving it here, guys. or am I did I This project was way too long in the making. I think I've already done it. Shapes. Give me one second, guys. Okay, I I've I'm actually not sure and I do not have time to go back and look at it, but I think that we are only updating it on the front end. Okay, I don't think we're saving it in the back end. So, your challenge is still there. Okay, so now once we have this, we're going to create a chunk out of this. I'm going to say chunk equal decode and we're going to pass in the value and then we're going to say the accumulated markup plus the new chunk is going to be equal to the new accumulated markup. Okay, next after this we're going to create a new date. So create now and then we're going to check in here right if so after this I'm going to say if now minus last time is greater than the updated throttle time then we're going to again update with the new data. Okay. And then after this, we're going to so down here where you find this green color, you're going to remove this and you're going to have a finally block. Okay. So this finally block is going to say reader.release lock just like this. And then down here we're going to have the catch. So inside the catch, I'm going to show an error in here. And this error is going to use toast. So I'm going to bring in toast from sonar like this. And what seems to be the error? I think I have to say error. Okay, there we go. And then finally for this at the bottom here, I'm going to say set is generating to false. Okay, there we go. Done. Now let's go ahead and complete that endpoint, the generate endpoint. So I'm going to open up my folder structure. Actually, let's just go back here and see what we did here. Okay, handle generate. So I'm going to create purposely create an error here so I can come back to this. But let's go back to our API endpoint and inside generate we're going to create another file called route.typescript. Okay. And inside this route.typescript we're going to essentially create a post endpoint. So I'm going to say post just like this. And this is going to have a try catch. So let's go ahead and bring in our try catch. Okay. And on top we're going to essentially grab all the data from our form data. So I'm going to say grab this from form data and extract the image and the project ID. And if none of these exist or we're not able to validate the file as an image, then we're going to return a next response saying 400 error. Okay. But if we're good to go, then we're going to essentially credit there. We're going to call the credit query. Okay. a credit balance query and we're essentially going to grab the values here. Okay. So now we're going to check if there is no balance then uh no balance. We're going to say fail to get balance and if their balance is good to go that means sorry if it's zero then we're going to say uh no credits available and if everything looks good now we're going to actually uh consume those credits. So, we're going to say consume credit query amount 1. And if this is good to go, uh, awesome. But if not, we're going to show 400. And now we have to convert that image. Okay, we're we're passing in an image into this, right? So, we have to convert the image into a base 64. And what is this image? This is essentially the frame. So, remember, we're downloading that as a blob and we're attaching it to the file, right? To the form to the form data. So we have to extract that. So I'm going to say image buffer equal to08 image file array buffer. And down here I'm going to say B 64 image buffer from the image buffer.2 and I'm going to say B 64. Now I need to grab the style guide and I'm going to say style guide query and we're going to pass in the project ID and that's going to give us our style guide. And then in here, I'm going to extract the style guide.json. And I'm going to grab the uh I'm I'm just going to type cast this as following. And then we're going to grab the inspiration image query. Now, this is something we haven't created yet. And this is essentially going to help us understand what inspiration images the user has attached to the specific uh frame. Okay. To the specific project. So, let's go ahead and grab that. So, open up your folder structure and you want to say query.config like this. And I'm just going to click into this one right here. So, it takes me directly to the file. And at the bottom, all we're going to do is we're going to say inspiration image query is an async arrow function that takes a project ID and it's going to preload this specific query. We don't have this yet. We're going to create that in just a second. But essentially, we're going to pass in get inspiration images. And in here we're going to say project ID. So for this specific project ID and a convex o token as well. Okay. Now let's go ahead open up our folder structure. Let's go up to convex. And in here we're going to create that inspiration.typescript file. Okay. So I'm going to say inspiration dot typescript. Okay. And you want to hit enter. And inside this you're going to need to essentially create that get inspiration image. Okay. So, inside this file, I'm going to say get inspiration images just like this. And let me also make sure that we're not we're no longer seeing that error. Awesome. And then in here, we're going to pass in the arguments as follows, which is the project ID. And then we're going to have our handler. And our handler is first going to check if the user is authenticated, if they own the project, and if so, then we're going to get the storage IDs. So, I'm going to say storage IDs get all of the inspiration images from this project. Okay. Then once I have that, I'm going to get the URLs for each of them. So I'm going to say storage ids.mmap and for each I'm going to say storage.get URL just like this. Okay. And then we're going to essentially return a unique ID right here. So we're going to return this inspiration- aique ID for client side tracking. And we're also going to return some other data such as states and the index and stuff like that. Okay. So, this is essentially the order of how the screens are going to show. That's why we need this. Uh, sorry, sorry, guys. The order of what how the images are going to be put in place. Okay. And that's pretty much it. And then we're just going to return an error if something something happened. Okay. And finally, at the bottom, we're going to filter out any failed URLs. Okay? And we're going to sort them out by this index that we just created. So, sort them out by that index a minus B. Okay? And that's it. Finally, let's return all of the valid images. And let's go back one step. Awesome. Inspiration image query created. Let's go back to our API endpoint. Now, I'm going to go back to our API endpoint. And now I have imported this. So, that should solve your error right there. And now, I'm going to grab the images from this. So, image inspirations.im images.valjson, which is an array of URL strings, right? So, let's grab that. And then I'm going to make sure that all the image URLs are, you know, um are truthy, but we've already done that inside the function. But just in case, we're going to do it here as well. Then we're going to grab the following colors, the typography, and we're also going to grab our system prompt that we created, but this system prompt is for the generated UI systems. Okay? So, it's slightly different. It's not the style guide system. And we're going to essentially pass in all this data into that prompt. Okay. So now uh guys, like I said, the that prompt file is also going to come with everything you're going to need for the prompts. Okay. Consider it just as a gift from me to you. That's pretty much it. So now what we're going to do is this is going to need to have everything that that prompt needs in order to create that design based on the colors, the typography, the system prompts, and the image URL. Okay. So here I'm going to say const user prompt equal to and please put back tick here. Okay, back ticks are essentially this. And now inside this I'm going to paste another prompt. Okay, and like I said, this prompt is also going to come as part of that. So if you go into your generated prompts right in here, I'm going to actually put it. Okay. So, I'm going to say const user prompt and you're going to have it in here. So, all you have to do is uncomment this, copy it, and you can paste it in here. Okay. So, this is going to have every single thing that we need. Um, and it's going to be it's going to attach all of that in here as well. I'm going to show I'm going to show you that in just a second. I actually did not do it myself. So, just give me one second. All right. All right. So as you can see I'm telling the user I'm telling as a user prompt I'm essentially saying use the user provided style guide and I'm providing you know t I'm telling it that it has to be tailwind v4 utilities use arbitrary classes. The reason why we're doing this is we need to get a style guide type system. So if you used bg white this is not going to be light and dark mode compatible. But if we use bg-background, then this is compatible with light and dark mode. So next, I'm also passing in all the image URLs saying you're going to receive six image URLs and we're essentially mapping over them and we're rendering them. Okay, so the image URLs will be added later on. Uh, and we'll add that inside the anthropic call, but I'm telling it in here that you're going to get the images through the image URL. Okay, it's going to be in a string of array of strings essentially. And then in here we're passing in the colors by looping over the colors and returning the color swatch name, the color hex code and the descriptions. And then same for typography. Okay, so this is how we create all of that together. Now we're going to essentially create a stream text and this comes from AI from Versel's AI. So let's bring that in. And we're also going to grab enthropic. And this enthropic comes from our AI SDK enthropic, not from ingest. Okay. Um, for some reason, if you stream the text with injust enthropic AI agent, I'm not able to get the response correctly or I think I may be coding it incorrectly. I'm not sure. But, uh, if you guys figure that out, please please do let me know. Okay. And then for messages for user, we're passing in the user text, the user's prompt. And the for the image, I'm saying it's B 64 images. And I'm passing in this right here. Okay, sorry guys. This B 64 image is the is the the buffer image, which is the sketch itself, and then we're passing in all of our inspiration images to look through. Now, another way you can enhance this is since Enthropic can look up URLs, maybe I'm just guessing, maybe you could just put Pinterest images, but this might be I actually had that idea in the beginning, which was directly pin Pinterest images into your design, but that would be against Pinterest's, you know, uh, terms and service and all that kind. There's like a whole thing behind it. Okay? So, you have to make sure you don't plagiarize. And now you have to be uh compliant and all that stuff. Now I'm just uploading images, right? These are my own like I mean the ones I uploaded right now were just from Pinterest. So please don't come after me. I was just doing it for demonstration purpose. I do not own those images. But I'm just saying uh you can essentially add you can use your own images in here now and not have to worry about uh the compliance part. Okay. So that's why we had to strip out Pinterest from it. Sometimes ideas that you think are awesome are actually not that awesome, man. Like there's always something behind it. I mean it's probably awesome but um there's always something there to bring you down. So as long as you have the drive to fix that you know you don't have to worry about anything. Okay so now we have to convert the streamed response to a regular stream for the browser to understand. And the way to do that is to say await start like this. And this is inside an object. Okay. So and you're going to say start controller. This is essentially like a class. I think that's what it is, right? And so then in here, you're going to create the total chunks, total length, accumulated content, and then you're going to have a try catch inside this. Sorry guys, there was some there was some typo with the way I was typing this, so I just redid this. So we're going to have the async inside the readable stream. We're going to have a try catch inside this as well. And the try catch has to be inside this async start. Okay, so this is essentially going to await from each of these chunks. We're going to add the chunk length. Okay, we're going to accumulate the content and then we're going to stream the HTML markup text using this. Okay, and then finally, we're going to close this controller down here. Finally, let's go ahead and return a response. So, after this section right here, return new response stream, and we're going to pass in connection keep alive. This is important here, okay? And everything else. So, this is going to be text HTML cuz that's what we're streaming. And uh that's pretty much it. And if there's an error, you want to throw the error down in here. Okay, awesome. Now, the next thing you're going to do is let's go ahead and solve this error because I remember I deliberately caused this error so I can go back and fix that, right? So, I'm going to go back into that file and I'm going to bring back the handle generate design. Awesome. Now, we also need to pass this in from the main component, which we're not doing right now. So, if you go back um let's go back to our canvas index.tsx right here. We have to pass in all of this into the shape renderer. And this is going to use a couple hooks that's going to help us accomplish this. Okay. So, the first hook we need is use inspiration. And this hook essentially is going to give us the inspiration state to show the inspiration window. and you know how to toggle it, all that kind of stuff. So, let's go ahead and let's create this simple hook. So, I'm going to open up my folder structure and I'm going to go into use canvas inside hooks right in here. And all the way at the bottom, I'm going to say use inspiration is going to have a state that's going to store whether it's open or not. And we're going to have a toggle. We're going to have an open. We're going to have a close. So, if you click this, it's just going to fire this one and set it to this. Okay, that's pretty much it then. Or actually, um, sorry guys, you could do it that way. Yes, you could. Or you could just set it to opposite. And that's what I've done here. I've just directly set this to opposite. But you could use the open and close for other buttons inside. Okay. So, let's go back in here and let's import this use inspiration. Awesome. And now we need to pass in the use inspiration into our toggler and uh into our toggle inspiration right here. Okay. And we also have the is inspiration open. And this stuff is going to go into our inspiration window right here. Okay. Awesome. So then the final thing is global chat. Now, this is something that we will work on, but I think this is a good place to kind of pause and then I think we should work on the inspiration as a separate section. Okay, so that brings us to the end of this module and I'll see you in the next one. All right, welcome back. Let's go ahead and continue from where we stopped. So, now go ahead and remove this line right here. And if you have a to-do, you can also remove that as well. So I'm only going to remove the inspiration. And now down here we're going to say the following. So I'm going to create inspiration sidebar just like this. And this component is going to need the is inspiration open past in. And we also need the on close which is the close inspiration. So let's go ahead and say on close inspiration. All right, there we go. And now the next thing we need is to first copy this title. We're going to open up our folder structure. And now let's go into this inspiration component. So you want to go inside components inside the canvas inside shapes. And then inside that you want to create the inspiration dash sidebar like this. And inside that you want to create index.tsx. And now in this component, I'm going to quickly return a snippet just like this. And let's also accept the props in here. So the props are essentially is open and on close. And from here, I'm going to dstructure all of these values. Next, inside this component, we're essentially going to need to render this window only when it is open because the user is pretty much ready to generate a design, right? So what we're going to do is first let's go ahead and draw a div here. So I'm going to remove this and I'm going to say return div like this. And now I also want to go back one more page and I want to bring in my sidebar so I can see this stuff. Okay, there we go. It's going to look a little odd for now, but as long as we can see it, we're good to go. Okay. And so we're passing this in. And it looks like is inspiration open is throwing some errors. Okay. So let's do something here. This is actually the wrong word. So it's is open like this. Okay. And then now let's proceed. So after this we're going to create another div inside this component. And we're going to pass in another div inside this. And this div, these divs are going to have the following class names. So, please pause and type all of this. Okay. And then inside this, we're going to have an image icon. So, let's go ahead and bring that in. Okay. And in here, we're going to say inspiration board. And all we're trying to do is is just build something like that looks a little bit like this. Okay. So, let's go back here and let's also import our label. Awesome. And now we're also going to have a button. So, after the label, you're going to hit enter. Sorry, guys. After this div here, hit enter and we're going to create a button component. So, let's go ahead and import this button as well. Okay. And let's also import the X button right here. And there you go. Now, you can see it says inspiration board. Okay. The next thing is we have to create a another div. So, let's go ahead and build this div after this. So, after this button, after this div, hit enter. And then you're going to say div like this. And this div is essentially going to have uh some some drag handlers and other things that we're going to come to later on. Okay, not right now. But uh what I'm going to do is I'm just going to remove this. Okay, we're going to remove the CN function. We're just going to provide this string here and I'm just going to remove the drag active. Okay, there you go. And we'll figure it out later. For now, I just want to have something in there. Okay. And don't forget you need to put your to-do add drag and drop. Now inside this div again we're going to have an input element. Okay. This is just to upload a file. So I'm going to say input file input ref which I'm going to comment out. And the onchange I'm going to comment as well. And after this I'm going to have another div. So go ahead and say div after this input. It should look just like this. And inside that I'm going to I'm going to create an upload element. So let's bring this in as well. And then inside this I'm going to have a paragraph. Okay. So after this we're going to say paragraph just like this. We're going to loop over all the images the user has created and we're going to render them out in here. Okay. So for now what I'm going to do is I'm going to comment this out and I'm going to comment this out. Okay. And right here I'm going to just comment this one out as well. So, let's hit enter and let's comment this one out. Awesome. There you go. Looks so much nicer, right? Then, if there are any images, we're just going to render them out at the bottom, like I said, and we're going to show this button inside it. So, in here, we're just showing this upload. And in here, after this, we're going to show each image and we're going to show a delete button. So, that's what we're going to be doing. So, I just wanted to draw this so you could see what's going on. And then after this, you're not going to see anything for a while, obviously. So, I just wanted to give you a quick glimpse of what we're building before we start. Okay. So, now let's go ahead and scroll all the way to the top because we're going to need a ton of stuff here. And so, let's go ahead and create that first. Okay. So, first for the images and set images, we're going to have a state and for the drag and set drag. So, two states here. Let's go ahead and import those as well. And then after this, we're going to need the file input ref as well. So I'm going to bring in a file input ref. Next, we're going to need our search params. And we need to grab the project ID from that. So we're going to grab this from use search params. Okay. Now, we're essentially going to query to get inspiration images. And so we need to create an upload URL for these images. So we have a function that can help us do this. And this is called generate upload URL. Okay, so let's go ahead and import all of the stuff that we used and okay, looks like I created this for something else. So, let me go ahead and open up our folder structure. We had something similar to this, but this inspiration was for the mood board, I believe. Right. So, go into inspiration right here. And up top, you're going to say the following. So, you're going to say mutation handler. And for this handler, you're going to say check if the user is authenticated and if so, just get a upload URL. Okay. And so now we have the upload URL stored in here. Next, we're going to had have another thing called add inspiration image. Okay. So let's bring this in. And now we have to create this one. So let's go ahead and open up our folder structure. And in here we have created the get inspiration and get the get URL. But now we have to create this new add inspiration image. So I'm going to say const just like this. Add inspiration image equal mutation. And inside this we're going to need to first pass in all of our arguments. So I'm going to say arguments just like this. And this is going to need a handler. But we're going to remove all the stuff and just build it from scratch. Okay. So inside our handler, first we're going to check if the user is authenticated. You guys already know the drill. Same exact thing, right? Get user status. Then we also have to check the project is something that belongs to them. If not, we're going to say you're not authorized to edit this project. And now we're going to get all of the current inspiration images. So I'm going to say current inspiration images project.insspiration image. Okay. Now we're going to check if the user already has this image. So does it include the storage ID? And if so, we're going to say the image is already uploaded. If not, we're going to check next if their limit is exceeded or not. And if it's not upload not exceeded then we're going to add the new element here the new image here to the to an array. So everything that they already have which is their current images plus the new image ID. Okay. And then we have to update it in the database. So I'm going to say update the project with the new inspiration image array. And finally we're going to need to return this back to the front end. Okay. Awesome. So now let's go back. And now this should not throw an error anymore. Awesome. Now we need to create another one called remove inspiration image. Now I have taught you to do so much in this project. Go ahead and pause this video and try to do the remove inspiration image and try to take it up as a challenge. Okay? So pause this video, try to do it. If you don't know how to do it, I'm going to show you exactly what the answer is. All right, welcome back. Hopefully you got the right answer. If not, no worries. This is exactly what you needed to do. So, first thing we're going to do is we're going to create the same function that we did before. And then inside this, we're going to pass in the arguments. And the arguments are exactly the same as the previous one, right? So now we also need to have a handler. And for our handler, everything is pretty much the same. Okay. So up till here, which is get the users uh account, check if they're authenticated, check if they own the project. If no, we have to throw an error. And now we're going to store the current images, but we're going to filter out from the current image and we're going to filter out the storage ID, the image that they're trying to delete. Okay. And then obviously we have to update. So it's a patch request. So if you wrote this, great job. Okay. So we have to write a patch request and then we have to try to delete the file from our storage. So try await storage.delete. Okay. Then after this let's return a true let's return a true success true an object with the following property. So success message and the remaining image. Okay. Now let's go back here and this should no longer throw an error for you. Next we're going to create another query here called get inspiration. So this one is existing images equal API inspiration get inspiration images. And in here we're going to need to pass in the project ID. Okay, so we're storing that. Now what we're going to do is we're going to load the existing images from the server when the component mounts or um when when our project essentially updates. Okay. And so we can tell that based on the existing images. So we're what we're going to do here is we're going to create a use effect. We're going to invoke this and let's just use this sample here. And then inside this first we're going to check the length like this existing image and there are some I mean there are some elements and if so we're going to create server images which is uh just like a mock data right we're essentially saying existing images mapap for each of them we're creating this new structure and we're storing it inside server images okay and now we're going to merge the server images with any local changes that took place so this essentially gives a user a quick, you know, it gives it some gives the user quick feedback, right? So, we're going to say set image just like this. And we're going to say local image dot uh previous filter the image for um image where it's not from the server. Okay. And then we're going to add that. So, we're going to return all the server images and our local changes. So, something is wrong here, guys. Let me just fix this. Give me a second. Okay. So the reason why this does not exist is because here we had a different uh different name and I passed in the wrong name into this type. All right guys, so what we're going to do is we're going to update these props here. So update these two to this and this one is going to have another type. So I'm just going to call this props like this. Um or you could call this a different name, but for now I'm just going to keep it like this so I can follow with the code. Okay. So down here now this should no longer throw an error for you. Now if there are no existing images or there's nothing inside this then we're going to check else if there are existing images and the length is zero. Okay. Then we're going to say there's no images being returned from the server. So we have to keep only all of our local images. Okay. Okay. So, I'm just going to filter them out for the following. All right. Awesome. Now, let's scroll back down. And now I'm going to continue from here. So, the first thing I'm going to do is I'm going to just go in a linear fashion. Okay. So, right here we had our drag and drop. So, I want to update all of this stuff and get some real data here. So, I'm going to remove this and I'm going to say the following. So, the first thing is this is not an input, guys. Sorry about that. It's it's right here. So let's go ahead and upload this one. So I have the following class names. So now let's go ahead and copy this name. Let's scroll up top. And now we're going to need to create our handle drag. Okay. So these are just drag and drop handlers for our images. So it's you technically speaking guys, React made an update where you don't need to use use callbacks anymore. Sorry guys. So, uh, what I meant to say was for the handle drop this use call back technically react has they made an update where you no longer need to use use callbacks. Now, it is the React basics to use a used callback when there's functions that have expensive renders and things like that. And so, if you use AI to code, it's going to give you this use call back. It does not break anything. it's just there because that's how React was built back in the day. Okay. So, just saying if you're using the latest versions of React, I think they did create um a new uh you know version where you do not need there's a new update where you do not need to explicitly say use call back this way and instead you can just create the function and that's just going to handle all the logic. Okay, awesome. Cool. All right. Now, the next one we need is the handle drop. So for handle drop all we're going to do is pretty much the same. So also just I mean I think this is straightforward but essentially we're just checking if it's a drag event or drop event whatever that is uh sorry drag enter or drag over and then we're setting it to true and if it's drag leave setting it to false. Okay. Now for the other one handle drop essentially what we're doing is pretty much the same but we're checking this e data transfer object. What is this? So when you drag a file, you can essentially attach some data onto that drag event. Okay? Not only file, just anything that's dragable on the screen. You can add some sort of data. You can add data to that drag event. It's kind of like metadata. And this is exactly what I did when I taught uh when I introduced my first I guess my first most viral video on YouTube, which is Plura. And in that project we built a website builder uh you know a bunch of cool features like having multi-tenency and also having uh you know stripe connect to take fees and all that kind of crazy stuff. But in that we had a website builder which needed this feature so we can understand which element is being dropped into the current page. And so we did that through the data transfer object. Very simple solution, right? And it's so lightweight. You just have to add an ID and with the ID, you can tell what file was dropped and you just append that to the array that holds all of the items on that website page. That's it. And then you just go from there. You just read the data and then you you delete the data from the transfer once it's completed and then you reset it when someone drops another event, drops drops another file file, I meant sorry. Okay. So now let's go ahead and create this handle um this handle file select. And so to do this I'm going to scroll up here and I'm going to say const handle file select. And this is going to be an arrow function that does the following. Okay. So let's remove all this crazy stuff in here. We don't need it. And then the files here is going to be the file. It's going to be a file list or it's going to be null. Okay. And then inside the dependency array. Actually, we'll get to the dependency in a second. Uh, make sure guys you pass in the existing uh where's this? Okay, there we go. It's right in here. Handle file select. Make sure you pass that in here. And for this, you don't need a dependency. Okay. And inside this function, first we're going to essentially check if there are files. If not, we're just going to return. Okay. Now, if there are files, then what we're going to do is we're going to we're going to loop over all of these files and we're going to filter for where they start with an image. If they don't, let's say user is dropping something random, we're filtering for that. We don't want that. And then we're going to limit it only to six total files at all times. Okay? And then we're going to map over that and we're going to create a new set of data for each file. Very straightforward. Okay? So let's go ahead and do that. So array.f from creates an array of all of these files. We're going to filter for image, slice them down, and then map over. Okay. Now, if the new images is greater than zero, then we're going to set our image state to hold everything it already has plus our new image. Okay, new images. Then now we're going to start uploading these each one at a time. Okay. So we're going to say for each of these new images, we're going to first mark these as uploading. So inside set images, we're going to go into that object and inside each image object object right here. Same thing. We're just setting uploading to true. Okay. And next we're going to create a try catch after this. So try um hello please give me try catch. Okay there we go. Try catch. And inside this try catch. Okay looks like it's creating a lot of problems. Try catch. There we go. Much better. So inside this try catch we're first going to upload our image. So let's go ahead and say upload image just like this. Now where is this upload image? Well we're going to create it right up top. So what we're going to do is we're going to scroll up here. Okay, this should be fine. And we're going to do the following. So I'm going to say con upload image equal to use call back again. And this has an async callback function that returns a promise. And this promise returns us a storage ID. Okay, so once that image is uploaded, we need the storage ID so we can store it locally. Now we're going to have a try catch. Very simple. And inside the try, first we're going to generate the URL. Second, we're going to upload it to Convex. Okay. And essentially, it's going to upload to the upload URL that we generated here. We're going to put that in here and upload that. Okay. It's a post request. And the body is going to be the file itself that's being passed into this callback function. Okay. If result is not okay, throw error and then grab the storage ID. Then we're going to say if the project ID exists and this project ID is all the way coming from use params. If that exists, then we're going to say add the inspiration image for that storage for that project ID and add the specific storage ID. Okay, so that's that way we're connecting both of those. And then finally, we're going to return the storage ID. If not, throw an error. Straightforward. Now, in the dependency array, we're going to have the following values. Okay, generate upload this one and the project ID itself. So that is our upload function. So down here we're essentially uploading this file to convex storage. Then now we have to mark it as completed. So we had uploading here. We have to mark it. So map over those. So set image. We're going to say previous map or image. ID is the same as this image we just uploaded. And then we're going to upload this state to say uploading completed. Okay. False. That's it. Now if this threw an error, what are we going to do right here? We're going to say catch set the images and we're going to set this to true uh false and set error here to upload failed. Very straightforward stuff. Now in the dependency array, we're we're going to need the images. So I'm going to say images length and upload image. All right. And there we go. Now we are done with this. I'm just kidding. We're not done. We're not done yet. Let's go ahead and bring in the stuff that we created. Okay. So here we have handle drop the handle drag uh both of this. So handle drag and hand handle drop pasted right here. Awesome. And then we also have the handle on click which essentially clicks on the file input for you to click and upload an image as well if you like if you like. Okay. And now let's grab the ref and let's pass the ref into this input field. And let's also have this handle file select which we created up here. We created up here. And this is essentially doing, you know, what whatever we just went over, right? So, it is essentially getting all of our images, limiting it, all that kind of stuff. And we're also uploading it piece by piece. Okay. So, that's what this image uh this image component here uh input component here does. All right. Now, the other thing I want to do in here is when we're rendering this paragraph now, we're going to check if the image.length, length. So let's remove this is greater than is less than six and if if if so we're going to say drop an image here. If not we're going to say maximum image reached. Okay awesome. Now after this section guys so 1 2 3 so one two two divs hit enter. And now if the image length right here is greater than zero like this, then inside this we're going to essentially render out a div. So let's go ahead and remove this and just say div like this. And inside this div, we're going to have another div that's going to render out the uploaded image. So let's click enter inside this. We want the uploaded image. So you see it's another div here with a label upload image the image.length uh sorry images and then a button called clear all images. Okay. So let's also import this trash icon. Let's let's go up top and now let's create the clear all images. So I'm going to go up top and I want you to take this up as a challenge now and pause this video and try to build this function. Okay, for all my developer nerds, this is the opportunity for you to get better and better at coding. Okay, so what do you have to do here? I'm going to give you the answer. I just want you to learn how to read from what we've already done through pattern recognition and then create your own function. Okay, this function should clear all the images. So essentially locally we want to remove okay we want to remove the states locally and we also want to remove the inspiration image from that storage from that project ID that we stored okay remember where we stored the storage ID right we have to remove that inspiration image so go ahead pause this video and try to give it a shot and if you don't know how to do it I'm going to show you exactly how to do it okay welcome back hopefully you got the right answer. If not, no worries. This is all you had to do. So, first clear all images. We're going to filter. That's pretty much it. Okay. So, filter the image the user wants to use. So, we're going to filter this right here. And we're going to store that those images in here. Okay. So, store the images in here. And then we're going to loop over all of these images. We're going to make sure the project ID and the storage ID exist. And then we're just going to fire the remove inspiration image which we created above. Okay, that's pretty much it. That's all you had to do for removing. So now let's go down here and this should solve that error for you. So if you did all of this, great job to you. If not, no worries. You're still learning and this is a process of learning. Okay, so I hope you spend more time to learn more about web development or at least pause the video and try to read what I type. Okay. So now after this div, we're going to hit enter here. We're going to create another div that looks like this. And inside this div, we're going to loop over all of those images. And we're going to do the following. So I'm going to hit enter here. I'm going to say image like this. So loop over images map. And then we're going to render out a a beautiful div here. So this div is going to look just like this. And inside this div, don't forget to pass in the key. All right, I'm I'm assuming you're going to po pause and type all of this. I don't think you have to say it every single time, but just making sure you pass in the key right in here. Okay, and obviously you did it for all the other things we're we're also discussing here. So now let's bring in the image. So we can render out the image like this. Okay. And then we're going to also set some pro uh some properties on top of this. And if the image is uploading, we're going to show that it's uploading with a spinner. And if it's not, well, then we'll show a button, right, to delete. But if there's an error, we also want to show the error message. So I'm going to say image. And we're going to print that on the screen. Now, after this, let's go ahead and render out the the button so the user can remove the image. Okay. And now we have this remove function here. This is different from remove all images. So let's go up top and let's create this. Now obviously you know what I'm going to do. This is another challenge for you. Okay. So go ahead, pause this video and try to build this function. Okay, welcome back. Hopefully you got the right answer. If not, this is all you had to do. So first you want to filter. So find the image. The image doesn't exist. We're just going to return. But if the image does exist and it has a storage ID and it's from the server and we have the project ID as well, just fire the remove inspiration image. Okay, that's it. That's all you have to do. And from your local states, make sure you filter by whatever they they just tried to delete. All right, awesome. Cool. Now, let's proceed from the section after this button. So, after this button down here, we're going to have an image uploaded. And so image uploaded and the image is not uploading. And here we're just going to show this design right here. Okay. And this is essentially a div that it just has some uh it's just a design essentially to show it's just sugarcoated stuff. It doesn't have any value. Okay. But it's just going to show like this green icon. You'll see what it looks like in just a second. Okay. Then after this, you're going to hit enter and you're going to say images.length is less than six. show another button just like this. So the user can essentially uh click and upload a button right here. Upload an image right here. Okay, that is the upload image essentially. I think that's what I have it set as. Let's take a look and let's just let's just give this a shot. Okay, so I found this image here. I'm just going to drag and drop it and let's make sure it's uploading. Awesome. There we go. It has uploaded successfully. And now we have the inspiration image attached to this successfully. Okay, but we have to remove this. So let's go ahead and try to remove this. So if I click on X here, this should remove this image. Okay, awesome. No errors. Nice. And I also want to refresh and just see what happens. Okay, let's also try to let's just try to mess around a little bit, right? So let's open this image, let it upload, and then let's refresh. And there you go. You see the inspiration image uh showing up for this right now. One thing I would like for you to add in the future is right now the inspiration image is tied to the entire project. So a challenge for you and I'm not going to give you the answer to this because I don't have this feature built in. But the challenge is to have the inspiration images for every single frame independently. Okay? So that way the user can have different inspiration images for every frame which uh lowers the credits that the user consumes, lowers the cost, helps you profit more and at the same time you're it's like you're you're you know putting the the the data in one place. You're encapsulating everything into one location. Okay. So that's it. So now we can see this upload. Let's also click on clear all. And there we go. It deletes everything. So now I'm going to bring back my my inspiration design. Where are you? Okay, I just brought it in. And I also want to make sure I can delete all of the stuff. Let's just try to delete this. Let it save. Okay, let's refresh. Okay, so what's going on? Something is going on. I think H Oh, okay. So, I just needed to refresh and delete it once more and it's it's deleted. So I think what was going on is it's probably a race condition or I mean it's not a race condition or it's probably because the set timer was too close to each other and as a result it was trying to delete one and then while it deleted it the next one came in and that probably just reversed but now the data is removed. Okay, so let's go ahead and let's build out a frame. So I'm going to make this look like a desktop frame and inside this we're going to do the following. So I want to resemble this design. Okay, and this is just a pricing card. So, what I'm going to do is I'm going to draw three pricing cards here. So, pricing card number one, number two, and I'm going to also try to move this. Uh, let me draw this and then we'll uh let me pause the video and let me draw it. Okay. Okay. So, I just purposely drew like an ugly version to see how well, you know, that the AI is going to handle it, right? We're going to give it a shot. All I want to make sure is that everything is saved. Okay, so everything is saved. Awesome. So, I've made sure that everything is saved, and I purposely just drew something that doesn't look as great to see how well of a job the AI can do. Okay. And let's go ahead and click on generate. So, the first thing that should happen, if I'm not wrong, is we should have a download show up. Okay, that's good news. Let's go into download and let's just save that. And okay, we're seeing our component render. Nice. Come on. Give me Give me something here. All right. Oh, wow. Let's go, guys. Look at that. We're drawing. Okay, it's doing all of it. Okay, let's make sure it's creating the cards. Let's go. This is awesome. Take a look at that. We just made a combination of design and AI. No one has ever attempted something like this, right? It has always been It's always been let design take the wheel. Let design uh I'm sorry, let cursor AI do everything and build everything and there's no designer sense in this. So without me even drawing something here, just giving it the bare minimum, it has taken context from all of them and it has also looked at the image and it's drawn exactly what we wanted. Okay, this is awesome. Like you are going to accomplish so much more by building an app that no one has done before. Okay. And I have never seen anything like this so far. So, I think you're you're on the right path. Okay. There's still more. There's still so much more we got to do, but I want to test a few more things. The first one is let's see if this saves. So, I'm going to refresh the browser. Okay, there we go. Awesome. So, everything is saving perfectly well. And you can look through this, you know, you can cycle through it. It's a real design. It's it's real stuff here, right? So, you're good to go. But there's something called generate workflow. But we have not set up the uh you know we haven't given it the instruction to do so. And also I just noticed noticed this. No way. No way. It's actually responsive. Give me a second. Oh wow. This is awesome. So it becomes responsive. And the reason why it does is because it uses Tailwind CSS. Remember? So we told the AI to use Tailwind CSS. Now this is HTML, right? This is HTML, but because it's using Tailwind, you're going to get the benefits of using our theme palette that we have inside our style guides. So, you see it's using the same accent color. And we also have the benefit of it becoming responsive. So, just a few more tweaks. It's almost there. You just have to sit down and figure out how you'd like to, you know, improve this user experience. Whether it is show it as desktop and mobile toggle, you know, there are so many different ways. You just have to figure out what's best for your users. And I promise you, if you speak to your users, they'll tell you exactly what they want to see. And you can you can expand on this. This is just prompt engineering. So, you might want to tell it to use exactly what it sees inside this. For example, pay attention to gradients. Pay attention to border gradients. Pay attention to text gradients. You can tell it all this stuff, right? So, that's pretty much it for this section. Let's go ahead and wrap up the section and I will see you in the next one. Now that we have generated a design using AI, the next stage is to create a workflow. And the workflow is essentially how we can create multiple pages using one single context. Okay. So right here we have one context saying this is what the design should look like. But we want multiple flows from this. And a flow could be anything like what does the user see after this page? Whether it's a checkout page, whether it's a landing page, what what are these things? Right? So, that's what we are going to give the AI the complete freedom to generate for us. Now, you could also tell it what you want to, but I guess that's just more of an add-on on top of this feature, but let's see how much we can do in this one single video. Okay. So, the first thing you're going to do is you're going to scroll into the index.tsx under your shapes right in here. and you're going to find this add frame button. Okay, so inside this um actually sorry guys, you're going to go into this index.tsx and you're going to see some to-dos here. So we need to add the chat window and we need to provide all of the props in here. So down here we have this toggle chat, we have export design and we have generate workflow. So we have to provide all of this. So this can go inside the frame. Okay. And our frame is also going to need this uh element inside this and it's going to need to essentially use this in here. Okay, so we need to verify all of this. So going back to our to our index.tsx under the canvas in here, as we can see, we have this use inspiration already set. The next one is for the global chat window. Okay, that's what we're going to focus on right now. And the reason why we're focusing on this because we need to generate I mean we're supposed to be generating workflows. The reason is because this function is inside the use global chat um hook. Okay. So let's say use global chat like this. Let's invoke it. Let's copy this name here. Let's just copy this. And then we're going to go ahead and open up our folder structure. And we're going to uh go back into our used canvas which I think we can do through here. Okay. So, I'm just going to click on the use inspiration. So, it just hacks me right through to that file. Okay. And so, now we're going to create that hook called use global chat. So, go ahead and say export const use global chat. And this is going to be a hook just like this. And first things first, we're going to need to keep track of when the chat window opens. So, I'm going to say use uh set chat, right? Set is chat open and is chat open as a state. Then we're going to create this function here called use workflow generation. Okay, so this is a slightly longer function because it has a lot of stuff that happens in here. So let's go ahead and copy this right here. Let's scroll up top after this return statement and I'm going to say export const use workflow generation just like this. First we need dispatch in here. So let's go ahead and bring our dispatch. Then the next thing we need is a use generate workflow mutation. So I'm going to go ahead and say use generate workflow mutation just like this. And this is going to give us is loading which is essentially is generating workflow. We're just going to rename that really quick. Okay. Now we need to grab this. So the use generation workflow has to come from our Redux API. So let's go into our Redux. Okay. And inside this we're going to create another API called generation. And inside that you're going to create an index.tsx. Okay. And now inside this let's go ahead and create that API. So the first thing we need is create API. Okay. Create API like this that comes from from React uh quer from our Redux toolkit. And then in here all we're going to do is the following. So first let's f let's focus on this create API. So I'm going to say const generation API create API and the reduce path reducer path is generation API. Then for our base query we're going to say fetch base query. We're going to set it to API/generate. Now this is something that we already have. And let's just make sure we already have this endpoint. So there we go. We already have uh API/generate but we don't have the Okay, we do have the root route. So this is API/generate/root.tsx. tsx. Okay, route.tsx. Awesome. That's how our builder's uh working right now as well, right? And for tag name, we're going to set it to generation. Next, down in here, we're going to create generate uh the generation, the AI generation, redesign UI, generate a workflow, and redesign workflow. Okay, so there's four different mutations that we're creating here. The first one is general stuff. So we're going to say URL/generate post request with the body. For redesigning, we're going to say redesign post request just like this with the body as well. For workflow generation, we're going to say workflow/workflow post and we're going to say data like this. Now for workflow redesigning, we're going to do the following. So we're going to say workflow-esign. And then finally, we have to export all of this. So I'm just going to export all of this right here. And then we're going to open up our folder structure. We're going to go into this index.tsx in here. And we have to import our generation API. So let's go ahead and put a comma and let's say generation API and let's bring it in from our generation folder. Okay. Right in here. Awesome. Now let's go back. Let's go back one more step. And now let's import our mutation. So our user our use generate workflow uh mutation. Now the next thing we're going to do is first we need to grab all of our shapes. Okay, that way we can work with this uh work with this to generate a workflow out of it. So I'm going to say all shapes equal to the following. Okay, then we're going to create this generate workflow function and it's going to do the following. So it needs to generate uyu ID. Okay, the generated UYU ID is a parameter and we're going to accept that in here. And then we're going to f we're going to use a try catch. So let's pass in a try catch. And inside our try first we're going to get the current shape. Okay. And we're going to essentially say all shape.find where the shape ID equal to the generated UU ID. And then we're going to say if this does not exist then the generated UI is not found. Now why are we doing this? The reason why we're doing this is a workflow is built off of why this why is this called shape first? You got to keep that other thought in your mind as well. So generate workflow works because it looks at a frame that just generated a new screen. So a new screen essentially and we're looking at that as a shape because remember our shape render is rendering a generated UI screen if you remember if you remember. So that's why it's we're considering it as a shape. So that's why we're making sure that its type is generated UI type shape. Okay. And if it does not exist, we need to throw an error because we cannot generate a workflow off of that shape. Next, if there's no UI spec data as well, we're just going to throw an error. Now, we need to grab the project ID. And this comes through our params. So, let's go ahead and import use search params. And let's grab the project ID. And if there's no project ID, obviously throw an error. And if this does exist, everything is good to go. Then we're going to create a constant here called page count. Okay. Oops. What's what just happened here? Okay, so I have to put that once more. There we go. And now that we have this constant here, we're essentially going to limit the number of workflows to this constant. Okay. And we're also going to just show a toast message saying generating real quick so we can see what's going on. Then now we're going to arrange these workflow pages side by side next to the left side screen. Okay? So if one workflow is generated, the next one is going to be next to its side on the right side. And we're going to do that by separating them by 100 pixels. Next, the spacing between these. So, the spacing of these current of the current shape width is going to need to be 450 pixels or the current width plus 50 uh plus 50 uh pixels spacing. So, that's what we're doing in here. This is the mathematical formula. You can pause and type it out. Okay. Then, the next one is we're going to need to start generating all of our pages. So let's go ahead and loop over how many number of pages we have and this is going to give us access to the following data. So we're going to get the index and we're just going to uh skip the first value. Okay. So we're going to grab these two. And now in here we're going to say try catch like this. And inside this try catch the first thing we're going to do is we're going to send an API request to the specific workflow endpoint for the specific page. So I'm going to say the following. Please pause the screen and type this out without making any spelling errors. Okay. All right. So, we're going to say await. And since we're using await, this needs to become async / API generate workflows. It's a post method and the headers are going to be as follows. And for the body, we're going to pass in the following data. Okay, make sure you pass this in. Now, I'm going to shut down my server and I would recommend you do this guys. So go ahead, shut down your enrock and also shut down your website uh your local host URL as well, your server as well. Okay, that way we don't hit any sort of um you know limits. So next thing is if the response was not okay, we're going to say failed and we're going to throw an error and then we're going to set the position of the page and calculate where this workflow page should go. So the way to do that is we're going to say workflow page is x base x plus index time spacing. y is going to be as follows and the width and height is going to be as follows as well. Next we're going to create an ID and we're going to use nano ID for this. Okay, you can use UYU ID if you like as well but uh we're doing this because we want to immediately add the new shape to the canvas. All right, and that shape is going to be as follows. So we're going to say dispatch add generated UI. The everything that's inside the workflow position, but the ID is going to be the workflow ID. The UI spec data is null. We're going to start for uh we're going to start with null so that we can render it render everything in live. And then the source frame ID is going to be the current source frame, the current frame that we're using. So it can refer to refer to that. And then in here we're also going to say is workflow page and set it to true. And also make sure you remove the URL from here guys. So I totally forgot I shut down the Enro server but I had the URL up and running and that was going to continuously make calls to that to that endpoint. We don't want that. Okay. So make sure you shut this out and you open up localhost 3000. So that just solves that error for us. Okay. Now we're going to need to stream all of this data to the front end. So after this we're going to say reader get reader like this. We're going to create a decoder, say text decoder, and then we're going to create the accumulated HTML. Very similar to what we did earlier, right? So you want to create the accumulated HTML variable to store all the new data. And now if the reader exists, we're going to say while true, we're going to read this data. And then if this is completed, we're going to return break. And if not, we're going to create a chunk. And in here, we're going to say decoder.deode this value. And we're also going to add the accumulated data. Next, we're going to update our local state to show this new stuff. Okay, to show the new accumulate h accumulated HTML inside that workflow ID. And this workflid is essentially that shape ID. Okay, that's what we're doing here. And now down here, hit enter after this blue bracket. And we want to return the page index. And down here, I'm also going to show an error if something went wrong. Okay. Finally, after this, so we have three brackets right here at this one, we're going to hit enter and we're going to say promise.all and we're going to pass in all of the workflow promises. Okay, so this one right here, we're going to pass it into that. Okay, so it needs to fulfill all of that. That way we can wait for all these workflow pages to finish generating. Next, we need to show the results. I'm going to say success count equal result.filter and make sure R do.success success for each of them have some values and we're just going to getlength and failure count for those that failed. Now if the success count is equal to four, we're just going to show some messages in here. This is going to help us debug everything. Okay. And now if else if this is uh this is greater than zero, then we're going to show generated four workflow pages successfully. And down here, if there is a failure, so failure count is greater than zero, fail to generate XYZ. Okay. Finally, right here, we're going to say else, we're just going to say the I mean fail to generate the workflow as a whole. Okay. Then go ahead and print the error and also show a test message uh toast message at the bottom. And then finally after this we need to return the generated workflow and the generated workflow uh the is generating workflow as well. All right nice. So that essentially wraps up this function. So now we can move down here and we can grab this data. So first we are storing the is chat window open and chat open and then the generated workflow that we just created and we also have to store the active generated UU ID and set active UYU generated ID for something later on. Okay so now we're going to create some helper functions from here right remember. So the first helper function we're going to create is to export this data or actually let's do this guys. So let's go to the bottom here. We all we need is the generate workflow, right? So, I'm going to return um everything that I have right now and we'll always I mean we can always come back to this but we have to make sure we put a to-do up here saying add chat window whatever this is right so complete the open chat close chat and toggle okay this is enough uh for me this is chat not chate now let's go back and now let's import our use global chat. Okay, awesome. And let's dstructure whatever values we need from this. Okay, and now that we have these values, let's scroll down here. Okay, so we have the chat window. Nice. We can show the chat window. And this is only if the generated UYU ID, the active generated UU ID is set in here. But for now, we are good to go on that. We have the toggle chat. We have the generate workflow. So let's go ahead and bring this in. We have export design which is not important for now but we can always come back to that later on. And now I'm just curious to go ahead and give this a shot. So I'm going to open up my terminal and I'm going to start enrock and I'm going to start my front end. And now let's go ahead and go back one step. Let's refresh. So this gives me that. Okay. Login. Awesome. Great. Now I don't know. I don't know how good Oh, this is not going to work. I just forgot we we missed out the most important part which is to actually handle the workflow generation, right? So go in here, you want to shrink everything. So we have to create the API endpoint. So go into API, go into generate and you're going to create a route.typescript or actually this already has a route.typescript guys. Sorry about that. Um we have to create the other one which is the workflow generation, right? So first thing you're going to do is you're going to create workflow generation. So inside generate you want to create workflow and inside this an index.typ uh sorry guys a route.typescript and inside this function we're going to do the following. So inside this I know I typed out a b bunch already. It's fine. Don't worry about it. I'm going to explain. Okay. So here we have a post endpoint and this is under the generate/workflow route.typescript. Okay. And inside this we're going to have a post request like I said and this is going to have a simple try catch. Actually when you shrink everything this way it looks so much simpler to read, right? I love it this way. So I love this feature in uh in cursor or visual studio code essentially. So first thing is we have to grab the body and we have to extract all of this data. Then we're going to make sure this exists because if it doesn't, we're going to say missing required fields and throw an error. Then down here, we're going to check the user's credits through our credit balance query. We're going to grab all of the data. We're going to make sure it's not equal to zero. That means they actually have some balance. But if they do not have any balance, then we have to return an error here saying no credits available. Then once this is completed, we're going to consume a credit. Now, for creating a workflow, you might want to consume more or you might want to move this to where we're actually calling the API endpoint for every single credit. Okay? I mean, it is happening here. So, this is fine. Actually, now that I think about it, it probably makes more sense to have it in here because this workflow generates one I I believe it generates one page only, right? We're calling the workflow five four five times uh three four times and that's why it gener so we're good to go never mind forget whatever I just said now if this is not okay we're going to return a 500 serverside error then we need to get the project ID from the request body so that we can grab grab all of these style guides so style guide query pass the pro pass the project ID in here to get the style guide and we're going to grab the following data from the value JSON okay we're going to grab its value JSON and get color section and typography section Next, inspiration images are going to come this way. So, inspiration image query, pass in the project ID. We're going to grab all the images. Then, in here, we're going to say image URLs equal images.m map and we're going to filter where we have a URL. Next, let's grab the colors, grab the grab the typography, and here we're going to design define the page types for dynamic generation. Now this is not a good way but I just want to put it here for demonstration purpose. Okay. So for dashboard analytics we need a page with charts, metrics, KPIs. For settings configurations page with preferences, account management etc. For user profile page with personal information and activity and same thing for everything else. So essentially we are hard coding the four pages that it will generate. So I do not recommend you do it this way, but and if you want to leverage AI, here's what you here's the enhancement you have to make on top of this. So you will need to essentially store data from the first generation. So when the user has all of this inside this frame, you're going to need to create I mean when the user creates that first generation by clicking on the generate button up top here, you're going to need to also tell the AI to tell us the flow the flow of what else is needed on top of this page it just gen just generated. I can't speak English. And so now that you have the four different pages, you can dynamically pass those in here. and AI will generate those pages based on what you put in. I hope that's making sense. If not, please reach out on the Discord. There's thousands and thousands of developers and SAS business owners in there who are helping each other. Okay? I promise you, you will get the help if you ask for the help. And not just ask, if you support and help other people, other people will help you as well. Okay? So, join the Discord. It's free. Why not, right? Join the Discord. It's one of the biggest SAS developer communities out there. The Discord's in the description. Click on that, join, and then whenever you need the help, you can reach out in there. Okay? And by the way, once a month, I hop in there and I also do a free coaching call and I help you guys with your SAS. And other members of my team sometimes also hop in. They teach you how to design. They teach you how to code. Like this happens every now and then. And we do this for free. So if you want to get want to get that stuff as well, join, turn on notifications, and just be a part of a great community. Okay? So hopefully you get the help if you don't know how to do this. But I promise you, you have learned so much. This feature is just scratching the surface compared to what we have just accomplished. Okay. So now that we have got our page types here, we're going to say selected page type at the page type at page index. We're going to grab this one and then we're going to say build the users. So how are we getting this page index? So the page index essentially comes from right here. Okay, from our body and we're passing that in based on it's an index of us looping. If you remember, we only took the underscore index when we were doing map. If you remember that, that's what we're passing in here. Then we're going to build this prompt here. And this prompt says your task uh your task was to create a workflow page that completes the main provided page design and the main page reference. We're just pushing that into this. That's it. Okay, that's the secret. That's the secret sauce, I guess. But obviously, please spend some time improve this. I want to see what you guys can create out of this stuff. Okay? And let me know. I'm I'm very curious to see what you guys create. Okay? Then next, we're having dynamic page requirements, design consistency, technical requirements. So, for now, whatever we generate from this workflow will not make sense. Okay? It's not going to make sense because remember, we hardcoded the page types. But we're still good to go. Okay? We're still good to go. Then down here, we're also passing the colors. We're al also passing the color swatches, I mean, and uh passing in whatever typography information it requires and all of our design inspiration images as well. So, we're passing that in here. And for our user prompts, so I think we have another user prompt somewhere in here or another. Okay, there we go. So, prompts.generative UI system. So, this is a system prompt. And remember, I told you you will get this for free as well. All the prompts will be for free and I will only give that inside the Discord or from the YouTube kit. Okay? And our YouTube kit comes from the Discord as well. So please join the Discord. You're going to get a ton of value from it. Okay? So once that's done down here, we're streaming the response. So now we're going to say create the stream by saying stream text. Again, we're going to use anthropic. So I have to go and add some more credits so we can see this work. And then we're going to pass in our user prompt, the images as well, the system prompt, and a temperature. Now, this temperature is not too important, but you can mess around with it. But I found this to work the best. So, I have this data right here costed me probably $15. Okay, nothing crazy, but I hopefully I save your $15 worth of credits, which is a lot of coding. Then down here we're going to say convert this to a streamable response by saying readable stream. And this readable stream comes from our AI package. Okay. So we're going to import that and we're going to let me just make sure it does come from AI. Uh let's go up top here. Readable comes from that does not come from AI stream. So that is a local function a native function I believe. So, okay, sorry about that, guys. So, we're going to create a readable stream and we're going to start this right here saying async start is a controller. So, I think under the hood, it's going to call this. I think that's how it works cuz this is a class, right? Hm. Okay. So, we're going to say async start and then in here we're going to say try catch a wait for each of these for each of the chunks that are in our text stream. We're going to say encoder new text encoder and we're going to cue up each of these. Okay, that's it. And then we're going to close the controller and catch any errors down here. Then we're going to return this by saying new response and pass in the string. Okay, then down here, we're going to catch any errors that show up from here and return a 500 error. Awesome. We're so close. We're so so close, guys. I'm so excited if you are still watching this video. Um, and u thank you for giving me the honor to teach you all of this stuff. Okay, I quite frankly love SAS so much that I'm willing to give away all this value for free so that you can benefit in the long term. And if you find all of this valuable and you would like to learn even more, then I highly recommend subscribing because by subscribing, you are going to get more of these highquality videos on your feed. Okay? So, help me get the opportunity to teach you even more. That's all I ask in return. Okay? So, the next thing here is we're going to go back into our API folder and I'm going to shrink everything really quick. go into app, go to API, and we're going to go into generate once more. And now I'm going to create another uh endpoint called workflow redesign just like this. And inside that, a route.typescript. Now, this is pretty much going to be the exact same thing, but with a slightly different prompt. So, it's not really needed. We'll go across this later. I just want to make sure it it works. But um actually might as well go across it right now. I don't want to I don't want to come back to this again. Okay. But we're extracting the same data from the body. We're making sure it exists. And if not, we're throwing an error. We're checking credit balance. And then we're consuming a credit and making sure that's successful as well. Let's not print this right here. Then we're going to grab the style guide query. So we can grab the style guide for this project. And then we're going to update the prompt. So the user prompt now says you're redesigning a specific workflow page, not creating a new page from scratch. Okay. And we're passing in the user's message. So this here needs the chat window. That's why I thought it's not required for now, but might as well create it or we're going to forget and then we're going to come back to this. I don't want that to happen. So this has the same prompt and I I'm going to give this to you for free as well. You can get it from my Discord or you can get it from the YouTube kit, whatever you find in the description. Okay. So, and the same exact thing happens here. We're sending our styles. We're sending our typography. And we're also sending the user's prompt saying, "Please generate a professional redesigned workflow page that incorporates a request to change while maintaining the core functionality and design consistency. Then, we're going to stream this response using anthropic. We're going to pass in the user's prompt, our generative UI system prompt in here with temperature 0.7. Then, we're going to create the readable stream. same exact process and we're going to write it back to the front end. Okay, awesome. Now there's one more which is the redesign route. So redesign route.typescript and this is pretty much the same again. Okay, but let's go ahead and look at it while we're already at it. So we're going to dstructure all this data from the body again. Make sure it exists or else throw a 400 error. Make sure we can check the credits if any exist. If not, if it if not, throw an error. If it does, then say you have more to consume. So, charge one. And if something happened wrong, throw a 500. Next, we're going to grab the style guide, grab the colors, sorry, grab the typography, and then we're going to grab our inspiration images. So, store that in here, grab the ones that actually have a URL, store the colors, store the typog, store the typography, and then we're going to store a user prompt in here. Please redesign the UI page based on my request. User message. The current HTML is essentially what comes from the API endpoint uh body. Right? We're going to say user message. Current HTML for reference is XYZ. Paste that in there. And then we're going to say wireframe snapshot. So wireframe context is something else that we're providing in here, which is essentially that image that the user sketched. So technically speaking, you don't need this here. Okay? because we already have the users's design. So if you want to save credits, this is another opportunity for you to save more credits in here. So you could remove the wireframe. Okay, if we even pass it in. I think we did. Okay, we did pass it in as images, but you could remove that if you want. Next, this user prompt will also be inside my Discord. So you can grab it from there. Then if the colors length exist, we'll map and render colors. Typography exist, map and render typography. And then we're going to render our image URLs. Again, like I said, it's not needed, but you could put it in there if you'd like. And then we're also going to say user prompt just like this. We're going to add the following to it. And then we're going to stream this response by adding this new wireframes in here and the images in here as well. Same thing for the generative UI system prompt. And the temperature is the same. Then create the readable streaming to the front end and throw an error if anything happened. Easy, right? Isn't coding easy when you look at it this way? And I promise you this, if you learn coding this way, which is a stepby stepbystep structure, that means you don't care about the syntax and you learn structure of code, you are officially a SAS developer in 2025. Because in order to know how to build SAS applications right now, you only need to know structure. AI will help you do the rest. In fact, I do not write a single line of code anymore. AI helps me with everything. I just know what happens every single step of the way. And if you want to learn more about this, if you want to learn how to build AI applications, I'm definitely going to be creating something that's going to help you learn how to code using AI. Okay? And so maybe I'll put some links down below, maybe a wait list, maybe a joint list, or maybe an opportunity for you to join and learn right now. And if so, uh, feel free to feel free to grab that if you think this is an important part in your career, which is learning how to leverage AI to build applications so fast that you will outperform anyone. Okay? And that's the guarantee I assume that's probably the guarantee I have in there cuz I'm so confident with AI now. And I I honestly don't go above and beyond and crazy with AI. Like I've seen some people overdo it, spend $700 on AI. I don't do that. I make sure that I consume no more than my given limit. So I always know how to optimize my prompts. I know how to use the right LLM at the right time so that I do not spend an extra dollar on top of what I need. Now every now and then I do go above and beyond. Uh I mean not every now and then, only the last time, right? Because cursor changed their rules and I had to make sure I adapt to all of this. And so I was just testing out the water to see how much I can spend, how less I can spend, and how much value I can get out of it. So in that, you know, this month, yes, I did go a little over budget, but even then, I'm well under what people typically spend. And uh yeah, so I promise you AI is changing. I mean, everything it's changing the way coding works. And if I was I'll be very honest with you, if I was hiring someone, I would not hire someone who does not use AI. That's just the truth about it. I do not care however talented you are, but if you don't know how to use AI, I physically can hire you because you get outperformed by one other dev. So, five devs get outperformed by one dev on our team, which is crazy good. That's awesome for the team, for the company, for that person as well because they learn a ton and they also make a a lot more money because they are the only person making more money now, right? So please learn how to use AI. Okay, that's pretty much it. So we have set up the redesign route. So these routes should work. I hope our redux is also set and if not, we're going to see some errors and I'd like to see that so I can fix it. Okay, so let's go in here and let's try to click on the generate workflow and let's give this a second. Okay, failed to generate. I'm assuming it's Redux. Nope, not Redux. Let's refresh. Okay, it's because we did not set up our front end. So, let's go in here. npm rundev and our convex is running. Our enrock is not running. So, let's get that get that up and running as well. And let's refresh our browser. We see a 200 here. Awesome. Now, let's go back in here. Okay. And I don't like my doc on the screen. There we go. And now, let's go ahead and click on generate workflow. Fingers crossed. Wish me all the luck. Okay. Generating. Oh my god, it already failed. Uh, what's the issue? So, fail to generate page. We see fail to generate page index + one response subject response status. Can you give me the response, please? Okay, give me a second, guys. I got to do some digging around. Okay, I know what's going on. So, I was testing a lot of AI stuff off camera, and so I lost a bunch of credits. So, I believe that's what's causing this. So, let's go ahead take a few minutes. Let me recharge my Anthropic. Okay, my Anthropic API. And I recommend you do this as well if you need need to test right now. Okay, I just want to say something, right? Anthropic made it so easy for me to pay. They just took my money in less than 1 second. This is awesome. You guys need to follow uh a similar work uh similar workflow while accepting payments, right? So, always make sure you have your customer's credit card on file and make sure that you can you get authority to charge that card. And the way you do that is by showing them, hey, do you want us to charge this card? That's it, right? You can put it into your terms and service, but you want to make sure that they're aware that it's in there. And usually, if it's not in there, that's when you go through a bunch of whole legal problem, right? A lot of legal problems essentially. And you don't want to do that. So, always make sure you ask them in a very simple, straightforward way. Do you want us to charge this credit card? Yes or no? No. Okay, add your new credit card. Yes. Okay, charge. That's it. Done. Right. Okay, cool. So, they took my money in less than a second. And now I'm ready to try this once more. And I'm also equally as excited. So, let's go in here and I'm going to refresh this. There we go. Everything is up and running. Generate workflow. Fingers crossed. Ah, what's going on now? Let's see. Let's try that once more. Maybe I need to refresh properly. And let's make sure all of this is running too. Okay, everything is running. Let's refresh. Fail to generate workflow pages. H interesting. Okay, so I'm going to show you guys how I debug. I typically don't like to post something like this because I'm I'm always quiet, but if you want to watch, this is what debugging actually looks like. Okay, so I'm going to say fail to I'm not going to talk, guys. Just just watch me. Okay, so fail to generate. All right, so we see a couple things here. we see generate in here fail to generate and I should have probably console this. So let's console fail to generate and pass pass in the error. There's another fail to generate. This is index page index. So it's not this error. Okay. So it's something else index + one. There we go. So something happened here. What is this? So generate workflow. So this is supposed to fire but it did fire and the response came back as empty. Okay. Hm. So that means Okay. So we see a 400. So let's go into this workflow. I think I already know what's going on. I think we are not passing any of the data into the it's the first error that's being thrown because it's so fast. So no AP. There we go. I told you. So there's no page index or there's there's something here that's missing. So I'm going to console.log. Ah, come on. Put put the data in here, please. Let's go ahead. Let's remove this. Pass the data. And we don't need this. I'm just going to select this. Ctrl D. D remove, comma. There we go. And we do not need this as well because I do not want a boolean version of this. So, I'm going to remove this, too. There we go. Let's refresh this. And let's look at our console here. Okay, we're seeing a ton of injust calls, but I think this is just to see if things are running. U not sure. I'll have to I'll have to probably look at that later. Uh, but it's not I'm not too concerned about that stuff. So, for now, I think injust is just calling to make sure it knows our functions. I think that's why it's doing it because we're in local development. Or maybe not. I think something like that. Okay. But in here, let's go ahead and generate. Did I click it? No, I did not. There we go. Okay. Four errors. Where's the console? Oh, my screen color just changed. All right. Give me a second, guys. Okay. I think it's because I have credits, but I don't have credits here. So, that's probably what's going on. I did not even look at that. Yeah, that's probably what's going on because this message wasn't even printed in the console. So obviously it has to be this because it's a 400 status error and because we don't have any, it cannot consume. So it's not going to do this cuz we would have seen 500. So that's what's going on. All right, so that's how you debug. Okay, now because I am top G, I'm just going to go into Convex. I'm going to click on to users, actually subscriptions. Aha, there we go. And I'm going to give my guy as many credits as I'd like. Okay, so let's go ahead and save this. Let's refresh that. Let's go to our front end. Oh, that instantly refreshed. I did not even need to refresh. That is so cool. Okay, let's go back here. And I'm already seeing things fly around and that's probably because it tried to reattempt generating the designs, which is not a good sign slash is a good sign, right? But let's just see what it does. Let's just give it a second. Okay. So, I'm going to try this once more. Let's go ahead and generate workflow. It says generating workflow pages. Okay. Boom. Boom. 1 2 3 4. I see. I I get I'm getting some good news. Okay. It looks like it is generating. Okay. All right. Awesome. Wait, why is it saying workflow automations? Oh, I think it's trying. Okay. It's because it's building those pages that I told you we hardcoded, right? So that's that's pretty much what's going on here. So we have an analytic dashboard. Okay. Obviously these don't look super pretty and it's because we haven't updated the prompt enough, right? So please take the time out of your day to update these prompts as much as you need. And just look at this. Look at what you have accomplished. This is one of the coolest accomplishments as a developer, right? This if I created this when I was starting out, this would have been the coolest thing ever. Like everything is happening in real time being streamed to the front end and it looks beautiful. Well, okay, that's not beautiful. I will take that. It looks average. That in itself is beautiful. And all four workflow pages have been generated successfully. This is amazing, guys. You have made some awesome progress in this project so far. You have converted an image to a full design. You have generated workflows off of those designs. And you've also streamed all of this to your project. Now, just imagine how capable this project would be if you just fixed it a little, added some more shiny features into it, made this look nicer by just updating the prompt and focusing on maybe rendering chats and UI components. Or I'm going to give you another hack. Okay. Wow, I had this a why did I have this idea now? So, what if you could link a set of pre-built components from the Shatsian blocks? That would be awesome. Right. So what I mean is link the Shatsian component block ids. So let's say you found um let's first of all I want to shut down my server. I don't want it to keep calling. So let's go in here. Let's shut this down. And I think this is actually calling our endpoints which is not good. Uh I'm going to see what's going on here. If I can find it, awesome. If not, uh just please take a look into it. Okay. So um let me go ahead and find this. Oh my god. I should have done this. This would have this would have killed the this app like this would have been the most killer app ever. What if you just use these? So help AI a little bit more, right? Tell it to you. Let's say you use chats and UI in the first place and you can essentially give it these commands or you could give it at least the code from here. Um or because you know it does have URL lookup, right? It does have URL lookup. So you could tell it to look up these URLs and use the components from these different designs based on the current scenario. So if it's a sidebar, give it a sidebar type design. If it is a calendar, give it a calendar that's already created. So you could do this with Shatsian's blocks. Oh my god, how did I not think of this? There you go. That's how I come up with ideas. So if you guys are wondering, how do I create these ideas? How do I think about all of these things that that pretty much stand out in the market? It's because I'm constantly looking to improve what's what already exists or I'm looking to create something so different from what already exists that it uniquely sells in a vacuum. Okay, that means it's the only solution that exists out there. That's I'm trying to accomplish that every single day. So, even though this is as as good as it can get, I'm sure you can do even better. Okay, awesome. Now with that being said, let's go ahead and wrap up this module and I will see you in the next one. Now we have made so many changes inside our application. It's about time we run Code Rabbit in order to review all of our mistakes, find bugs, and solve them. So let's go ahead and click on yes here so we can start reviewing. And the way to do this is if you are on your main branch, the moment you check out into a new branch and the second you add your comments, you add all of your files by doing get add period sign and then you add a commit message that's going to show you a little prompt here at the bottom left corner if you used code rabbit's plugin inside your Visual Studio Code or your cursor. Now, if you did not do this and you essentially were you you basically did it inside the browser which is inside GitHub that's fine too. You can also get some feedback on the browser but I want to do it in here because I want to see the changes inside my files and I'm going to also use AI if I need to fix any of these changes. Okay, so let's go ahead and review all these changes and I want you to also do this with me and if you have any bugs go ahead and solve them. Now I'm going to look for any big bugs and if I find some something really re really critical I'm going to solve them uh you know then and there itself and then maybe towards the end I'll tell you but if it's all simple small stuff like hey remove to-do or hey you're supposed to use a different ID here that kind of stuff should be fine to go. Okay so let's go ahead and say continue. So review is already in progress. Let's take a look. So it says starting review. Okay there we go. So let's just give this a second and then we'll continue. Okay, so take a look at this guys. I just took a few minutes to go just grab some coffee and Code Rabbit did everything it had to do and it updated it like 21 minutes ago, 22 minutes ago. And so first thing it created a full description of every feature that goes into this, right? But let me show you what I really like about this. So first thing is it speaks about a summary of each file. This is nice. And then check with check check this one out, right? It created a diagram diagram flow for every single feature. And it's not just gibberish. It makes total sense. Let's just look at the payment section, right? So you can see how this actually works. What is this? Okay, we can scroll up and down. Let's see if we can scale this. Okay, so first for billing essentially we have the first get user ID that goes to billing checkout and then next that creates the checkout session. So that goes to polar and then polar essentially returns a checkout URL to um to our front end. Okay, redirect to Polar. So right here we're redirecting to Polar and then once the payment is made, so this is the pay billing UI, right? So the billing UI refreshes and redirects to Polar because we just got the checkout URL. And then after that the post web hook essentially right here uh which is a signed web hook and it's telling us all this stuff and I'm I'm sure it's going to explain as well but essentially it tells us okay now we got the signed URL. So and now the user has made a purchase. So it emits a polar web hook received. Okay. And check this out. It also knows that we used ingest. So it tells us what ingest does in here. So ingest essentially runs a handler. So seven 8 it upserts from polar. So it goes to polar and it grants credits if needed. And that essentially goes to the handle polar event right here which is in uh in injust I believe. So and then here we have convex subscriptions and credits. So here it's telling us the next stage is we're going to save and grant these credits and we're going to update their subscription right here. So, first we're going to send uh after updating the credits, we're going to go back to our polar endpoint and we're going to update the subscription. Okay? And then once that's done, we're going to sync our event. So, emit synced event. This is so cool. It's really nice, right? And so, this is how the autosave works. So, let's take a look at this too. You see canvas autosave. We grab all this data and we send it to this API/ project. Then once this is done, the autosave request is fired inside ingest and this runs a workflow and that autosave essentially fires, goes to uh goes to convex, it saves that sends us a response back to this. Awesome, right? So there you go. If you have any questions here, just ask code rabbit. Now code rabbit has a ton of code comments and obviously I need to go through this. So you see it's saying missing O ownership check enables unauthorized autosave rights. This is huge. So right here it looks like what we did inside this handler is where is this? So after the async handler in here, boom, we just grab this data and we instantly save the data. We don't want to do this, right? We first want to check if the user ID exists. So we're going to get the user's ID. we're going to throw an error if they're not authenticated. You want to check if the project belongs to them and only then are we going to do all everything after that. So, this is something you're going to want to change. Okay. Next in here, it found another potential and it caught so many bugs. Okay. It's going to take me forever to fix all of these, but uh these are not potentially breaking issues, but definitely a way to strengthen your your authentication. Okay, so we read this. Let's go to the next one. This one is avoid user enumeration makes this several severe internal uh and normalized email. What is this server? Sorry guys. Make this server internal and normalized email. So essentially it's telling us to normalize the email here. So normalized email. Okay. Okay. Got it. So this is you see it's not breaking changes right here so far. It's just enhancements. So essentially trim the data. And the other thing it's telling us to do here is to change this stuff to a server only function. So in order to do this, you'd have to write server only up top and then use it that way. Okay? So that way it never runs on the client. Next, we have non-null operations. So you can do some checks in here. Um, extract user ID from authentication session, not from a query param. That's a good way to tell us what to do here, but I think so. Um, okay. Okay, you'd probably need to expand this even more and read through that. But what else? Let's see. So, harden the route runtime environment checks plus error handling. Oh, very nice. Okay, this is good. And this does it for polar. So, add input config validation try catch. So, misisconfiguration returns a controlled whatever instead of crashing. Okay, this is good. So, we can definitely add this in here. And in fact, what I'm going to do, guys, is I'm going to add this into the codebase. So, if you purchase the codebase, I'm going to put this uh all these changes into it. Okay? As much as I need on every single thing, only the things that are breaking changes or that enhance the security drastically, I'm going to add that into it. Okay? So, just give me a second. So, the first thing I'm going to do is I'm going to go into route.typescript. This is under right here that says null safety check. So let's let's just click on this and let's go ahead and accept this change. Awesome. And then I also have the following right here which is miss missing error handling from fetch mutation. Okay. So what happens after the try catch? Okay. See there we go. We did not use a try catch here. And so if there's any errors we can't tell what what exactly happened. So let's go ahead and accept this one as well. Okay. And looks like it kind of broke this. So, let me just go ahead and fix this uh real quick. Okay. So, I think this is not a breaking change because we already have a try catch here. So, this should be fine. U I the only reason why you need another try catch in there is to encapsulate that specific error. Okay. So, we're good to go in there. Now, potential issues with the filteration. Okay. Let's see what this is. So, this is essentially after filtering the image URLs. Uh the image URLs could be empty. Okay. Um so if you Okay, go. Got it. So let's add the check in here. That's pretty important. Awesome. And then credits are consumed even if generation fails. Got it. So essentially right here, if this fails, so okay. H. Okay. So what it's telling us to do is to make sure this succeeds first. So if I hit check, let's see what happens. Okay. I I figured it's going to break because it's not a it's not like a a direct change, right? So, let me see what it tried to add. So, it added between Okay, just to show you how to do this, guys. So, if you add something and that breaks, then you can undo the change right here. Okay, so I undid the change and I redid it and that fixed the problem. So, now we're making the call first and only if this succeeds are we making the change. So, let's let's go back one more step. And now let's add this in place here. Okay, there we go. We're done. Awesome. Now let's look at the inconsistent pattern check. So let's add this in as well. So it's checking for balance and Okay. So Oh, okay. This is also one of those one of those issues. So let's go ahead and un uh revert this change. Okay. And so all it's saying is make sure you follow the right the right consistency. I'm not too worried about this. So, let's go ahead and shrink this real quick. Okay, so it caught a critical bug right here. And I didn't notice this at first, but you see it gives you some keywords called improved, remove, fix, and critical. Now, I would definitely focus on this. Okay, so I'm going to look through all these files. I've already showed you how to accept changes and how to revert them and uh what you need to do. And if I need to change this, I'm going to go ahead and change those in place. Okay. Okay. So, I see what's going on here. It's not It is a critical bug in the sense that it doesn't break the app, but what it's saying here is that we're always taking the first subscription, right? So, we're taking the first subscription that belongs to the user and it's saying, well, why do you indicate that there's going to be more than one subscription? That means you have a flawed architecture for subscriptions. And so it's telling us that even if you have multiple subscriptions, you're only supposed to keep the most recent and active subscription inside the database. So cancel any duplicate transactions. Okay, so that means in here where you're essentially getting all of the user data. Let's see if I can find it. Um it should be somewhere in here. Okay, where we're fetching. Okay, so somewhere in here where we're getting all of the user subscriptions and or all user subscriptions. So fetch API to subscription get all for user with the user ID. Okay. So this is all of your subscriptions. So all it's telling us is why do you need all of this? So if you find that they're saying instead of console logging it, disconnect it, delete it. Okay. And so uh that's all it's trying to say. So we're good to go in here. So it's not really a critical bug, but it's sensing that you have a critical logical error here which could maybe in the future affect you. Okay? So just keep this in mind as well. I'm going to copy this comment and I'm going to put it inside the pro codebase. So when you purchase this codebase, you will find all of the code comments that code that I think that code rabbit wants you to change directly in there. So you can put some time into it and fix those bugs. Okay. So I want to also point out this one here. So essentially inside your generate folder, you see how we're first consuming the credits from the user and only then um I mean and after consuming the credits, only then are we generating the AI response. This is not a good user experience because you're going to have a ton of refunds if this happens. Okay? Always consume the credits after you're done with the AI response because then the error is on you. Okay? If it's on you, then you shouldn't charge or punish the customer. So, make sure you move that below this as well. Okay, I'm going to go ahead and put a comment inside the Pro codebase for this. Okay, so this is one potential um I guess security threat, which is dangerously set inner HTML. So, it looks like our sanitization implementation wasn't good enough. Okay, it's good, but it only checks for HTML related stuff. And so, it doesn't look for nested scripts and all of the others. So, I'm going to go ahead and put the updated code inside the Pro codebase. All right, awesome. I just went ahead and merged all of our code. It looks like not too many errors were critical, but some errors were some logical errors. So, I put those that were breaking inside the Pro codebase. And uh apart from that, I mean it's still going to work, but when I say breaking, I mean in the future. So what that means is maybe in the future if some edge case takes place that could break your code. That's what I meant by could break, right? And so I added those as code comments inside the codebase. If you'd like to fix that, go ahead. Okay? If not, no worries. You'll still be fine. So now let's go ahead and create another branch and set usself up for the next section, which is chats. And all you have to do is say get checkout-bs just like this. Okay. And once you're done, let's move on to the next session. All right, guys. Now, you want to go ahead and open up your index.tsx inside your canvas, which you should find inside components canvas index.tsx in here. And now we can provide these features. Now, please make sure to shut down your server and also shut down your enrock. Okay, we don't need it right now. So, going in here, the first thing I see is we haven't set up these states. So let's go ahead and first complete our use global chat cuz we have a couple more things that we just left off remember. So let's go ahead and do that. So inside our use global chat we have completed till the workflow generation. Now we have to provide the export design helper. So I'm going to say const export design is an async function just like this. And this function first is going to take in some parameters. So let's bring that in which is the UYU ID of the generated file that the screen that we're trying to edit and the element itself. Then if there's no element we're trying to export just show an error that looks like this. And then after that we're going to have a try catch. And this try catch is going to do the following. So we're going to check just like this. We're going to say get the file name with the following ID. And then we're going to click on we're going to essentially say export generated uh generated UI as PNG. Okay. So go ahead and scroll up top or actually you could go into libs frame.napshot and we could essentially create this function in here. So export const export as UI as PNG. And this obviously needs the element and the file name. So let's bring that in as well. And then in here first we're going to say try catch. So I'm going to say try catch. And inside the try catch we're going to first get the bounding uh get the bounding elements like this from the rectangle. And then we're going to essentially grab our can sorry we're going to create a canvas because we're essentially doing what we did above here which is remember render shape on canvas right? Something very similar to that. Okay. So we're going to grab the canvas. We're going to grab its height and width and we're going to set that. And then we're going to need to create a context so that we can draw into it. Then if there is no context created, throw an error. And then we're going to set some styles. So fill is white. And we're going to also create the canvas with this width and height. Okay. Then we're going to find the context area by doing the following. And this is essentially the div with the actual UI context appended to it, right? With that user ref, I I believe. No, it's not a user ref. It is or it is a user ref, I believe. So, query selector div style pointer events auto. It might be the one with the user ref, but anyways, it's just the one with the actual UI content inside. And then down here, we're going to say await u capture visual content. And this is essentially going to get us the content the way it should appear onto the design. Okay, onto the image. So to create this again, scroll up top and up here we're going to say const this is equal to an async arrow function. And inside this we're going to say ctx just like this with the width and height. And now we're going to import this new package called HTML to image. So, you remember how we drew everything in here, right? That's awesome. It's very easy to do. You just draw it out and we're good to go. But in this section, drawing this stuff out would be crazy if we did it by oursel, right? And so, what we need to do is import a package called HTML to image. And I think HTML to canvas is another one that does pretty much the same thing. But, uh, this is the package that we're going to be using. So, go ahead and open up your folder structure. And you want to say npmi. We're gonna say HTML to image. You want to say at you're going to put 1.11.1.13 and you're going to hit enter. Okay. And let this install and and sorry in the meantime we're going to go in here and inside this section we're going to go ahead and await and dynamically import this. Okay. So await import HTML to image and we're going to grab PNG. And now we're going to say data URL is equal to the content div. So that we want to that that we want to convert. And we're going to give it some width and height. We're going to give it the background color and a bunch of other values. So please pause the screen and type. Okay. And then once that is done after this, we're going to create a filter in here. And this filter is going to need to do the following. So we're going to say if node type is equal to node text node then we're going to return true. If not then we're going to check here if the ele so node element right here is an element node and if so then we're going to grab that element and we're going to make sure it does not include in this. Okay. So we're trying to do the opposite and if everything looks good here let's return true. So this filter should succeed after this. Okay. So once this is done now we need to create an image from all of this. I'm going to say create image new image and then after that I'm going to say await new promise and we're going to say image.onload ctx.draw image. We're going to pass in the image width and height show a message and resolve. If there's an error reject and if not we're going to essentially say image.src equal data url. Okay that's pretty much it for this function. So now let's scroll down here and we see an await here. And so this function needs to change to async. So let's go ahead and do that. And that should solve this error here as well. Now make sure you also have this else block that's going to throw an error. Okay, awesome. And then we're going to have um another helper here. Not a helper, sorry guys. We're going to essentially convert um the canvas to a blob so that we can download it. So canvas.blo. to blob and we're going to download it right here. And then we're going to say if blob like this. Then we're going to just print this message here. And then we're going to say download to blob and we're going to pass the file name and the blob. Okay. And it's going to download it as an image. PNG. Then that's pretty much it here. But we're going to throw an error if something happened here. Okay. That's it. So now we have created this frame extracted general uh generated UI as a PNG. Now, let's go back here and let's import. Okay, let's import that. Awesome. And now we're showing a toast message for success and a toast message for error. Great job. Now, we need to have our chat controls, which is actually very simple. So, in here after this blue bracket, hit enter. We're going to create open chat. We're going to create close chat. And all it's doing is just setting those variables. Okay, setting our states. And finally, we're going to have a toggle chat. Okay, so this is going to do the following just like this. And then now we're going to need to update our return statement to have all the new values in here. So now we're essentially creating everything in here, encapsulating it, and then returning it back. That's how a hook works, right? So now we can go in here and we can bring in all of the new uh awesome stuff that we just created. So remove this and I'm going to say the following. Nice. Now down here, first thing we want to do is show the chat window when it's open. So I'm going to say if the active generated UU ID exists, then render the chat window. And down here, I'm also going to open the toggle chat and I'm also going to bring in the exported design. Okay, inside this I think we also have to have generated UI. That's good to go. Let's remove that and everything else being passed in. Okay, frame button. Let's remove that to-do as well. Now, let's go back up top and now let's copy this title because we have to create a new component called chat window. And this happens inside our canvas itself. Inside that we have shapes and inside this we have something called generated UI. And inside here we're going to create chat.tsx. Okay. And inside this component, let's go ahead and return a snippet. And this is obviously going to need those props. So, let's bring in those props real quick. And I'm going to dstructure and grab them from here. Now, we're going to essentially say if not open, then return null because it's not open. Very simple. And all it's going to do is it's just going to render out something that looks like this. So, it's not going to look exactly like this because remember I told you how to pivot the idea, but something just like this. Okay, it's just a chat chat box that shows up. So, I'm going to remove this for now. And actually, I do not want to open up the browser last second and then create some sort of infinity, you know, uh loop. I'm sorry, not infinity loop. I don't want to end up uh getting rate limited by Enro, right? So because I see that Inro keeps calling our endpoint uh I mean gets called by ingest and I think that's because of the way I have it set up or it's because there's a 400. So I might be doing something a little wrong but regardless it's still working or maybe it's checking to make sure the the the ingest functions haven't updated, right? Maybe we need to turn that off. But regardless, inside this now the next thing we need to do is we're going to need to return a div here. So remove this return a div. Okay. And this needs a CN function. So let's bring that in as well. And then in here we're going to create another div just like this. And inside this div, looks like there's some kind of error here, guys. Or is this just TypeScript? Expected a curly bracket. Okay, there you go. Get what you expected. And then now in in here, we're going to essentially say design chat. Okay. And this is going to need um an icon called refresh. And our label component. Let's bring that into. And it says design chat. Okay. And then we're going to have a div. So this div right after this is going to have the following. And inside this div, we're going to loop over something called as the chat state. Now remember I told you every single screen is going to have its own chat state. Every single frame is going to have its own chat state. And so we're going to need to store that somewhere. So where are we storing that? That's going to be stored inside another hook here. And this hook is called use chat window. Okay. So go ahead and copy this. and we're going to need to pass get grab all these values. So, this is going to be quite a lot of coding. Okay, just bear with me. We're almost there. We're so close to the finish line. And I want you to have this project ready to go. Right. So, go into your canvas. We're going to scroll down here. You're going to say export cons chat window like this. And then in here, first we're going to create some states. So go ahead and import uh create these states, sorry, the scroll area, the input dispatch, and the input value. Okay, then we're going to need to grab the chat state from our app selector from our Redux store. So let's go ahead and bring that in as well. And I'm going to say chats at the specific generated user ID, sorry, UYU ID. So it's essentially for every single screen, it's going to have its own chat history. So you can chat with the AI and update that design. Okay. And we've already created the API endpoints to handle that. So we've already we're already 10 steps ahead. Okay. So now we're going to get the current shape and we're going to get all shapes in here as well. And now that we have this, we're going to make sure um actually we're going to create a function here called get source frame. And this is going to help us uh find the original frame that this this generated UYU ID was created from. Okay. And that way we can use that as the main page to res redesign whatever we need. So what I'm going to do here is I'm going to say const get source frame equal to an arrow function. And this arrow function is going to return us either frame shape or it's going to return null. Okay. And so inside this first if there's no current shape the type is not generated U ID return null. Next, if this is the case, then you're going to say return null. Again, if you cannot find the source frame ID, then we're going to say if the source frame is found at that specific uh from all the shapes and its type is not frame, then you want to return null as well. And finally, you're going to want to return the source frame down here if everything passes through. And we're going to type cast it to frame shape. Now this is going to have an initialization um effect which we're going to use obviously using use effect and this is going to dispatch to our store to initialize our state. So now we need to create this slice from our Redux store. So this is the perfect time to introduce this. So go into Redux and then you want to go into your slices and you want to create another slice here called chat and index.typescript. Typescript and inside this let's go ahead and create our slice and let's import the slice utilities that we need and inside this let's go ahead and provide the slic's name which is chat and then it's going to need the initial state which is another variable we need to create so this is simply going to be an empty object for the chat but the chat state itself is going to have a different type and That type is going to be as follows. So it's just a record with string and generated UI chat. Now this is essentially going to have the going to have a couple types here. So we have the generated UU ID. So that means a screen the messages which is another type. We'll get that in a second. Is streaming and streaming message ID. Then in here let's go ahead and create the final type for the chat message. It's going to be as follows. If it's the user, we can use this type ro to essentially show a different bubble color, right? That's why we need this. And then down here, we're passing in the initial values. Awesome. So, that should be good to go. And now, I'm going to create these reducers. So, in here, you're going to hit enter, enter, and you're going to create the first reducer that helps us initialize the chat. So, this uses um this is obviously a payload action. And if you don't know what this is, this is just Redux related stuff. Okay, so an action is how you change the state. It's a type that helps you change the state essentially. Okay, so if you pass in the type called it's it's a it's like a string, right? Imagine you pass in a payload action and the action tells the reducer to perform a delete action. That's what the action is. So now we're going to get state.s chats at this and if that exists then we're going to I mean if that does not exist then we're going to we're going to create and initialize this chat. Okay, next we need to add a user's message. So after this this is another reducer that helps us add the following data. So we're going to say grab this from the payload and find the chat that comes from the state.s chats and then if the chat exists then we're going to push it to our new array. Okay, awesome. Now we need to start streaming and so that's another reducer. So start streaming takes in state and action and essentially we get the chats and then we set the chat is streaming to true. Set streaming message ID to message ID and then we push our new message. What's next? Next is updating the streaming content. So, let's hit enter after this and we're going to do the following. So, please go ahead, pause and type. This should be very straightforward. Nothing too crazy, but we're just updating whatever content is coming in with the new chat. Okay, so we're saying message index chat memes messages.find basically and then we're just saying if you cannot find it, we're going to set that to the new content. Okay. Finally, we're going to have one called finished streaming response. And this one is going to do the following. Okay. So, go ahead and pause and type this as well. And then we're going to have handle error. So, if an error took place, we're going to handle the error by adding that as well. So, if there's an error here like this, so error came in from the payload, then we're going to check if chat exists. And if chat exists, then we're going to say is streaming false, streaming message ID null. And then we're going to push the error in here by passing in this error message inside content. Okay, for clear chat, we can clear chat history using the following. There we go. And then we're going to have a remove chat as well, just like this. Now, finally, let's go ahead and export all of this from the bottom here. all of our reducers from this chat slice and let's export it just like this. Now go in here and you're going to bring in chat and you're going to import this as well. Nice. Awesome. So now let's go back. Boom. Boom. And let's import our initial chat. Great job. Now the next thing is we need to autoscroll. So every time a chat message comes in and every time this chat state which we're storing here, every time this updates from our Redux store, we need to fire something to move to that specific scroll location. So the scroll height, we do that by we we do that through a use effect. Very straightforward. So chat state messages and then if scroll ref exists, go to that exact scroll height. Next, we're going to need to focus on the input. So, if we open the chat window, go ahead and set focus on that input ref. Okay. Then what's next? Now, we're going to have the send message. So, this is another function in here. And this function is first going to trim all of the messages. And we're going to make sure the chat state is stream uh is not streaming, but if it is, we're going to return. And now we're going to grab the values here for the message and we're going to trim everything and store it in here. So if this trim results in a faulty value because of this, we're going to essentially return, right? So here we're going to get a truthy value obviously. So let's store that. Now we're going to do a try catch. Okay, there we go. Awesome. And first we're going to add the user's message to the chat to create more of a real time, you know, um, effect, right? So, let's bring that in. So, it looks like it's optimistic UI. And now we're going to start streaming. So, I'm going to say response ID response date now. And then we're going to dispatch this start streaming response action to the store so we can show a loading animation or whatever we need on the front end, right? And then we're going to say check if the uh workflow page exists. I'm going to do that by saying the following. And now after all of this, we're going to need to grab the project ID. So I'm going to grab it from our params. And if it doesn't exist, throw an error. And then we're going to say base request data like this. And then we're going to grab the API endpoint that's required for redesigning. And remember, we already went 10 steps ahead and created that already, right? So, let's go ahead and provide that. And now I'm going to say create a wireframe snapshot variable. And it's either string or null. And I'm going to say if the workflow page exists, then we're going to do this. Else, we're going to do something else. In here, we're going to say API API endpoint because it exists is going to be API generate. and we're going to only redesign that specific workflow. But if not, then we're going to essentially only update the um only update the main page using this one. So, first let's use get source frame and this essentially comes from a helper up top. So, let's go ahead and create this get source frame. I thought we did it already here. Um we did not do it. Oh, we did. get oh frame. There we go. That's why I was so confused. So now we have the get source frame. Now we have to make sure the source is a frame. So if source is frame then try catch. And what seems to be the issue here? It's probably because it's not been read. Okay. Why frame location? All right. No worries. Um all right. So inside this we're going to first create get grab all the shapes like this and then we're going to create generate the frame from the snapshot in here. So con snapshot equal weight generate frame snapshot pass in the frames and all our shapes. Then down here we're going to say convert blob to base 64 just like this. So create an array buffer and then we're going to store that into this. Okay. And now we're going to send the raw data base 64, not the UI, not the um sorry, not the data URL or the URI if you want to call that URI. Okay, so finally done. Now we're going to just console a message here if something took place. And we're also going to want to have an else condition at this green mark that prints saying no source frame available. Okay. Now, after this blue, hit enter. We're going to say u request data this way. And we're going to store our base request data and the wireframe snapshot because we're going to prepare the final request data based on our page type. Okay. And then we're going to use fetch for streaming this. So, I'm going to do the following. Go to this endpoint. And this endpoint is whatever we just, you know, dynamically generated. And if the response is 200, good to go. If not, then we're going to say get reader. And then we're going to say decoder. We're streaming essentially, right? We've already done this before a million times. So now we have to get the accumulated HTML. And now I'm going to say if reader exists, we're going to do a while while loop. And we're going to say the following. while true read decodes each chunk and add the chunk to the accumulated HTML and we're going to update that to our store so it updates locally and we're also going to update the shape with HTML in real time right here by saying update shape so that specific generated UU ID which is that screen is going to update with the following UI spec data okay finally we have to also change our finished streaming right because we're already completed so down here say the following update I'm sorry design uh sorry finished streaming response let's import this one as well then finally show an error if an error took place in here using a toast and we have to import our add error message and we're completed with that section now at the bottom here for keyboard handling so handle key press so if the user hits enter we have to send that right it's a very straightforward thing we don't have to do anything crazy just create this uh function here um that essentially prevents default and then sends the message. And if the user clears a chat, we're going to just click on clear chat. Okay, with our generated UU ID, of course. And now let's go ahead and return all of the values we just created. Awesome. Now, let's go back and import our massive use chat window. So much work in this, right? Okay, now what's next? So imagine if you built this from scratch. Imagine how long this would have taken you. It's taken us so long just to read what's already typed. Imagine how long all of this could take you, right? So that's why honestly the team did team crushed this. Okay, we worked so hard on this project and I'm so happy with the results and I cannot wait to see what you guys have to do with this project. Honestly, I'm super excited. Even for the most basic projects, you guys have crushed it. So I'm sure this project is going to be phenomenal. Okay. So now inside this div, we can go ahead and say chat state. render all a uh render a message just like this. And um if there are messages, we're going to show a button here to delete this to clear all of the chats. And if not, we're going to have uh I mean not if not, we're also going to have a close button to essentially close all of our chats to close that chat window. And then after this div one, two, hit enter. We're going to create a scroll area. And inside the scroll area, this comes from chaten. Okay, import that. And then we're going to have a div inside here. And this div is going to say chat window dot messages if that's equal to so if it's truthy then and also we have some length in the messages. Sorry guys we don't have a message we don't have length nothing has been done yet right then we're going to do the following right in here we're going to say please enter a message but if the chat messages do do exist then we're going to return the following. So I'm going to say chat messages.mssage.map chat state messages.mmap and we're going to grab the message and I'm going to return a div with the following class names and inside that another div and inside that another div here with the message content and I'm going to say a loading right here message streaming then show a loader if not just show the date and time. Okay, awesome. We're so close. We're so so close. All right. Now, after the scroll area, go ahead and hit enter. Create a div in here. Create a div in here as well. And inside this, another beautiful div. Okay. And now this is going to have the input element so that we can get the user's text, right? So, let's say input hello input. There we go. input and then we're going to have a button after this. So hit enter here have a button uh component and then I'm going to also have the send icon into this. So if we have hit entered and the chat state is streaming then we're going to show a loader. If not we're going to show a send message. Then in here, we're going to say after this div, type your redesign request and press enter. Just so this is not good, but um you can say whatever you want. I just put something in here when I was coding. Okay. All right. That's pretty much it. Awesome. Now, let's go back. Chats.typescript is completed. Let's bring in our beautiful chat window. And let's make sure we're removing this removing our to-do. Just like that. And let's see what happens. So, go ahead and click on this chat, this design chat. And it looks like a horrible design just showed up. Something went wrong with my design. Okay. What the hell? All right. I'm so sorry, guys. I was just making some uh UI changes there. I mean, UI errors there. I fixed it. And I am not going to give you the answer because I want you to take up a small challenge. Okay? It's just CSS stuff. I've taught you so much. I'm sure you can do that. Okay? Go in there and fix the CSS. See what's going on. Ask AI. Try to fix that bug. It's just I'm going to give you a hint. It's something to maybe do with flex or something to maybe do with grid. That's it. That's all you're going to get. Okay? And maybe something to do with either the way we have put the elements below each other. It's just the order or the way we moved it into the divs incorrectly. So now if you click on design chat, you're going to see this awesome looking Apple UI kind of uh glass glass, I guess glass uh what do you call it? Liquid glass display. Okay. And now it's saying go ahead and redesign this. So I want to redesign this. And I'm going to just say I need a gradient, a purple gradient that is right on top here. Okay. So, I'm going to say the following. Okay, so I just typed out something. I'm going to go ahead and hit enter. And I want to also copy this just in case. And let's see what it does. Okay, so it added the gradient, but it just made it very subtle and you can't really see it. So, I'm going to do something else and just see how it handles that. Okay. Okay. So, the task was just to update this color right here. It did a good job, but it looks like it forgot the background color, and so that could be a challenge. All right, so here's what I would recommend. You might want to enforce, do not change anything that exists on the page. But the whole point here is to test to make sure that this is doing a decent job at least. And it did do a decent job. The task was to use gradient text for the title and the card amount. And I told it to make this card stand out a little bit more. And it used the styles that we already have. Now I'm going to refresh this because I want to see. Okay, awesome. It stored that. And inside this, it's supposed to also store the chat history, but I think we are not storing that. So, um, actually, I don't think we are storing that, guys. We're storing it temporarily, I believe. So, hm. Okay. Um, let me say, let me just try something. I want to just tell it to do whatever you think is best and build out a full landing page for this section along with the pricing cards that we already have. Make the colors dark mode or make the page dark mode only. I I don't know. I just want to try. Let's just give this a shot. Okay, it's not doing a great job, but hey, come on. We We just built Okay. Oh, okay. I thought it was gonna stop right there. All right, never mind. So, it's building testimonials for us. Uh I really think you guys can crush this if you give it a little more time and you focus on improving the the prompt. That's all you need to do. Improve the prompt a little bit more. I'm sure the prompt alone is going to make a huge difference in this AI app. Okay? Because right now, I mean, it's doing a good job. Like, think about this. This is pure HTML CSS. That's really good, right? Look at this table. This is not chats and UI. This is a real table, right? It built it out from scratch. And this uses cursor. Ouch. I just hit my foot. Okay, I'm fine. Don't worry about me. Um, okay. So now, yeah, we have a beautiful application. We haven't done anything crazy and in less than probably, I don't know, for me, this took me exactly 4 days. I've been I've been recording day and night, but that's what you guys see. It took us months to actually build the application. But for you, if you sat and did this just like how I did from start to finish, or if you just got the codebase, you would you would have been set up on the the very first second. But if you decided to watch this video and learn and build along with me, that's totally fine as well. You have an MVP that you can show to someone, right? And get feedback. Get feedback from your customers and they will tell you, man, like I promise you, if you show this to someone, if you show this to a designer, they're going to be impressed, but they're not going to like what they see yet because you need to optimize, you need to improve the prompt. You need to uh train it with your own model. And remember, I gave you those those key that those tricks and tips, right? You maybe want to use chats and components under the hood or you could also set up a default template, right? you could fake it like okay let me give you some true raw facts of what SAS applications actually do under the hood so even though you think it is building its dashboard from scratch it's actually not what they are doing is they're using a template think about it do you think they can generate every single response using AI no definitely not especially clo this is very expensive like to generate this is going to cost you maybe 70 80 cents or sometimes even a Okay. And that's I told you the reason is because we have images involved. If you're not using vision AI, you're good to go. You're just using claude sonnet. That's probably maybe 30 cents per per, you know, per prompt, whatever, right? It is expensive. But I'm just saying that if you spent some time on that, trained it, and also use the tips and trick I tricks I gave you, which is to um you know, fake it, right? You could fake it by creating some templates through shhatsenian blocks or you could also well you don't have to fake it. That's essentially what I mean by what I'm what I mean by what I just said is not faking but creating a pre-built template. So provide that to AI and that's what apps are actually doing right now. For some of them that they know are going to be duplicated. The pricing cards are the same, right? if there are any apps out there just like this, instead of costing you so much, they're going to just use that little um template, right? And that's going to save them a ton of money as well. So, your goal right now is to remove a little bit of the AI features because right now we're using it everywhere. And the whole point is for was to show you the power of what you could do in here, right? But I want you to go in there and I want you to transform this like spend your spend quality time with your team and decide what's best to improve the performance and also to improve costs and to improve the user experience of this application. All right, and with that being said, that brings us to the end of this lesson. Now, in the next couple modules, we're going to be looking at the next most important steps of hosting and deploying your SAS. So, let's move on to the next module. All right, guys. I am super excited for you because you are now in the final stages of your SAS. In this section, we're going to be focusing on deploying and launching our application. But before we do so, there are a couple things we need to look into. Now, this is my suggestion. This is how I would approach it and I recommend you do the same. You could have your own approaches, no problem. But this is just what I would do in your scenario. There are two different ways you can approach this. Okay? So I'm going to first give you the options and then I'll show you exactly what I would do here. Okay? So that hopefully it makes more sense for you too. So the two options are number one, you fix everything, get everything up and running, you make sure the code runs the way you want it to. you tested all that kind of stuff and then you launch. Or the second option is you don't launch right now. You get user feedback from the product you have already built. You get them to test it and then you improve the product along with whatever they want while you also test it on the back and then you launch. Okay? There these are two different options, two different ways of approaching this and you could do it the way you like, no problem. But I'm just going to tell you what I like. So I prefer, here's what I prefer. So I prefer launching first with the illusion funnel. So this is a strategy that I created when I started my businesses and this is what I teach all of my clients inside Prodigy's University as well. All that kind of fun stuff. And I'm just going to help you right now. Okay. So the illusion funnel is very straightforward. All you have to do is create a landing page. You create a landing page about your product and you drive traffic into that landing page and that landing page is going to sell the outcome to the customer. Okay? It's going to sell the outcome of the SAS and your only goal is to get them to show interest. So, you're not selling, right? You're going to tell them join the weight list, whatever that is, or join this XYZ thing, join this um beta program, whatever that is, based on how where your app is right now. Get them to give you their email. You need their contact information. The number one rule that I've I've learned in business is if you can get someone to give you their valuable time, which is limited, and their most valuable asset, it's more likely that you're going to get them eventually to give you a dollar. Okay? So, get their time first. So, that's what I would recommend you do here, which is try to get them through the door to show interest in this product. This way you scoop the market because there's not not a lot of people are going to do this uh build this app and actually launch. In fact, 90% of the people who are watching this video right now probably stopped watching. So if you were still watching this, you're you're one of those very few people who are actually going to launch, start, market, get customers. So you got to keep that in mind, okay? You're not going to have any competitors. I almost guarantee you. I could take the road map. I could give the road map and everything a person needs to get to that end goal and they still wouldn't. This is just how the human mind works. It's unfortunate, but it's your opport. It's your chance to take advantage of that or you can just let it go. All right? And so this is the the moment for you to take advantage of this. And so what I recommend is scoop the market by first showcasing your product online. Okay? Do not focus on launching this e regardless if you bought the codebase or regardless if you coded this from start to finish. It doesn't matter. First launch, first market. So even if you don't have the codebase right now guys, you can create a landing page and sell the outcome of this. Now how do you sell the outcome of something that doesn't actually exist? Well, you can do this through Figma designs. You can do this through showcasing show showing animations. You could show a demo. You could like this is how you promote the product. Okay. And so one one example is if you don't want to get the codebase set, you can get the Figma design, right? You can grab that from the description, you can launch with that. That is one option. Or if not, you can just create little illustrations online, whatever that is that that looks similar that shows how the customer can get that specific outcome and you can show show the customer that. Or if you built this project from start to finish, first of all, keep in mind you need to get you need to get our license, okay? But um it's okay if you're if you're just promoting it and in the sense that you're just setting it up, that's okay. If you can code this with us, that's that's fine. But if you're going to launch and you're going to accept a customer, please respect um you know the team and uh you can use the link in the description in order to do that. Okay? You get a license and right now you're there is a discount. I'm sure there's some sort of offer that I've put in place that is a limited time deal. So make sure you grab that so you get this license along with the code and all of the assistance. Okay, but like I said, so launch it first. Get people's opinions, get their perspective on your code, sorry, on your project and on on your product. So that way you can add those new features in place while you fix it in the back end. Okay, hope this is making sense. So these are the two different ways to approach it. And I would pick the illusion funnel. I created it knowing that it's going to work and I've still have been using it my entire life. And this strategy works. Okay, this strategy works. This is how I validated every single business I've ever started. Not just for me, but all of my clients. So, I know it's going to work for you as well. Okay? And make sure you are following FDC guidelines. Don't just say the product is out, the product is ready. Don't accept a payment without a product in their hand. You'll get in trouble. You have to let them know openly that this is a wait list. Okay? And if you're accepting payments, tell them early early comers or weight list charge, whatever that is. That's how you can accept money. You can't accept money saying you're going to get a product and then they never get a product. That is scamming someone. So please, please make sure you follow FTC guidelines. Okay? So let everyone know, let your website visitors know that, hey, this is how you can sign up and here's how I'm going to contact you to share more information. And that brings us to step two, if you chose the option I suggested, which is the feedback system. So implement the feedback system to get them to reach out to you and tell you exactly what they liked, what they didn't like, and suggest other features that you can add into the app. Okay? And keep that cycle going until you have 100 leads. If you have 100 leads, 30 will show interest. maybe 10 or five to 10 will actually hop on a sales call with you and then you'll close at least two to three. Okay, these are the numbers not from our business from also working with all of our other clients and you know a bunch of other businesses around that are in the field of SAS and actually this this this is these are the numbers from any business really. Okay, so um looking at all the businesses I have started these are the numbers. All right. So, if you can just get 100 leads through the door, you are guaranteed to make two sales. Think about it that way. Okay? I'm not saying you are going to, but I'm saying these are these are just the numbers that I have seen myself. So, get 100 leads through the door and implement uh implement everything I have taught you so far, which is care for your customer. Uh, I'm not going to get bore you and give you all the crazy sales tactics and all that right now because that's too much for you to take and I don't know if you're even ready for that in this one in this in this video because you've already spent 10 plus hours building this out, right? But um, just saying just be yourself and make sure you can put this product in front of them as a way for you to help them. Don't focus on the sale. The sale doesn't matter. Okay? Focus on helping this person. They in fact you are supposed to be helping them. If you can help them, why would they not give you their money? Just think about that, right? So focus on helping them and they will reward you in return for more help. Simple. Okay? So if you don't make money right now, that's okay. Start for free. I started for free for two years. I didn't make any money in my businesses. Okay? So that's what I would recommend for the other for the other dudes here who want to just launch as fast as possible. That means um you you get the codebase you want to launch and have a have some code and the app ready to go so that way customers can buy from you. Then here's how I would recommend and actually this is the way I would recommend for both both options which is going with the um with the illusion funnel method or the second one is which I'm about to explain. Okay. So essentially remember I told you you can test the app fix it up make sure it's ready to go and then launch so that you can accept a customer right um what I would recommend is first run code rabbit okay run code rabbit inside your visual studio code so that way you can see if there are any bugs in your application it's free just use it use the link in the description it is free to use um and obviously if you need some sort of crazy advantage with code rabbit you can grab their pro tier Right. But um just use your free tier, set it up inside your Visual Studio Code and search for critical bugs. Okay? If you find something that Code Rabbit said is a critical bug, fix it. Fix it before you launch. Do not put a shitty product in front of someone. All right? It's better to have a minimal product. That's why we call it MVP. A minimal product that does almost what it said it does. That's it. and just about that then have a product that prom that that promises way more but delivers nothing. Okay, so that's how that's what I would recommend. So first test it with code rabbit. Step number two which is the most important part if you are going to launch period is to test your application using automation scripts. So I don't know if you guys have heard of justest and react testing library but that is what I would suggest you should do as well. So just and react testing library are these two testing I guess uh libraries that can help you test your components and the uh and your pages from the lens of a screen reader. Okay. So use react testing library and just to test all of your code. Now parent that's awesome but how do I actually do all of this? Well, you're going to use AI and I would recommend you use cloud code for uh for running test cases or writing test cases, sorry, because it just does the job way better than cursor AI. Okay, way better. Um, cursor cursor AI almost never gets it done. I don't know why. Um I don't know if it's because well on auto yes definitely it's never going to get it done on on uh cloud for incursor maybe but then you're going to hit your limits really quick but with cloud code you got that 5 hour window right now. Okay so use cloud code and first thing you're going to do is you're going to write a create a file here just create a file inside your underscore test folder. So underscore test underscore. Okay. And inside this in inside this file you're going to write test cases which are essentially the the suit of the test case and the test case itself. Okay. So this is the suit. This is the test case. And in the in the in the test cases you're just going to break down what you want to test. Okay. So in this example this is a real production grade application that I'm building. All right. And just to show you what this looks like is I've created my payment test file right here. And inside this I have a test case called product with uh height PPP true plus regular discounts just as an example. Right? That's the test case. So that's what I want to test for. But how does that work from the user's perspective? Dialogue opens shows loading skeleton standard discount screen appears. next button, whatever. Each and every single step is broken down in here. Why? The reason is because we are not testing for code implementation, but we're testing behavior. And this is what we call behavior-driven testing. Okay? So, you want to test your code from a behavioral standpoint, not from the code that has been written because the code will always change. Okay? So, test your code by telling Cloud AI to use these test cases to test the components. So to test all the components so that you so that it it testes tests it from a behavioral standpoint using react testing library. Okay. The next thing you want to tell it is do not use mock components. That means you have to render the re the component itself that you're testing. You cannot just say mock component and just create a fake component because sometimes uh AI does that. Okay. it fakes the tests and gives you a false positive and that that kind of beats the whole purpose of testing. So make sure you tell it clearly explicitly like hey I need you to test the component itself and the page itself. Do not try to test only uh do not try to mock a component like create a fake version or duplicate version of the component and test it that way. Now it can duplicate and and mock functions. That's fine. Okay. And sometimes that's gonna test a little bit of the code, but that's okay. Um, as long as it is testing this way. You see here, for example, we're saying user, so upsell screen shows, whatever, right? And we're showing mock product. We're passing the product info into the real component itself. This is a real, you know, React component. It's not a mock component that I created. And then we're waiting to expect a specific element to show up in the screen this way. And then after that, we're checking to make sure the text that we're looking for appears. This is how you want to test. Okay? You're testing like you are um the screen reader. You're the user. That's it. You're not testing your code. So once you get all the tests to pass, you're good to go. Now, how much should you test? Usually we do I think it's 730 7030 rule or 8020, right? So 80% testing. So just test for 80% testing coverage. How do you do this? There is a testing coverage command that you can fire. Just tell AI and it will do it. Okay? AI will do everything for you. Just tell AI test my code uh for 80% testing coverage uh with behavior driven testing only with all the things that I just explained and you are going to have a solid solid code base. If you find any failing test cases or any failing uh you know or some some bugs in the code, fix it. Okay. Like I said, we built this entire project in two and a half weeks. So, it's not going to be perfect. Obviously, you can give me one year and then you're going to have a production grade codebase, but this is two weeks. So, you can imagine that, you know, there are going to be some here and there's where we slipped up, you know, some some codebase errors, whatever that is, silly stuff, right? And so, you have to fix those before you go live. So, whether you purchased it or whether you watch this video from start to finish, make sure you do this and make sure you are you are protected before you launch, okay? make sure the the code base mainly is protected, it's safe, it's not broken before you launch. All right, so that's all I wanted to say before we hop into deployment. So what I'm going to do now is I'm going to also use my uh code rabbit extension to look for errors. Okay, so let's go ahead and skip to that part. All right, so the next stage is we need to run the build command. So go ahead and open up your terminal and you're going to say npm run build. Go ahead and hit enter. And this is going to build a minified light version of your codebase. This folder or the build output is what we're going to use to deploy through our deployment platform. So go ahead, pause this video and do this. Now, when you try to do this, you are going to see a lot of linting errors, which is totally normal. All you have to do is solve them. So, one of the ways I I prefer doing this is by copying all of my linting errors from my terminal. And I just use AI. Okay? And AI will go in and solve all of your all of your linting errors, TypeScript errors in less than less than a minute for you so that you don't have to worry anymore. Right? So, go ahead, pause this video, solve those linting errors that that show up after the bun uh after the npm run build command. Okay, welcome back. Hopefully, you solved all of your errors as well. This is what it should look like once you have successfully built the project. Okay. So you should see an output like this with no more linting errors. Now the next question you might have is what deployment platform should we use to deploy the SAS? Because deployment is such a small step but at the same time it plays a big role over time in your SAS application. Okay. So I'll give you an example. Let's say if you had a new feature, what would it look like to have that new feature as part of the new as part of that codebase that is live, right? So you see deployment is not just having your code live. That's not deployment. It is the whole package. That means not only that which is obviously having your code live and fast, right? But also how do my new features incorporate? How can I test out my new features? How can I have an isolated environment where my codebase can run so that my users don't end up seeing all of my testing code? This is all important and I'm going to show you every single step. And usually a lot of creators don't show this because it's very timeconuming and it's not part of their development cycle. So we just skip over it. But I'm going to show you an amazing tool that helps you do all of what I just said. Savella is a hosting solution for Nex.js applications. just like ours. And the best part is they have every single feature that I just spoke to you about. So one of those features are the ability to directly integrate from your main branch. So from your GitHub repository directly into Savella's deployment. So this means automatic deployments and all you have to do is just say get push and you're set, right? that pushes your pushes your code into your main branch and that spins up the deployment cycle on autopilot and then that pushes your code. Now, my f one of my favorite parts there's there's a lot of other features that I like, but one of my favorite features is this one right here. So, testing your changes before you merge in different environments. So, this is what we call CI/CD in the world of development. Okay, so they create a CI/CD pipeline for you. If you like, you can opt into it. And essentially, you can set up the app in different environments before you merge. And there's two different ways you can do this. So, one way is how most providers do it is through the git flow, right? Which means you have three different branches. One for dev, one for staging, one for production. And you push all your changes to those branches, and you step by step keep pushing to the next branch. And each branch is hosted on this. Okay? So, each different environment has each different branch. That's okay. But I don't like that flow because there's no source of truth, right? What you essentially end up with if you went with a git flow, which is still good. It's just a different preference. I just like the trunkbased flow because you have one source of truth, your main branch, but your main branch is deployed on different environments so that you can test it first before you move forward. So pretty much the same thing except that it's there's a source of truth now, right? And the the nicer the nicer part of this is you can isolate all of your data. So isolate the environment variables only for that specific environment and also isolate all the data so it doesn't get corrupt. So users will not affect their real data and at the same time they will never see what your new features are before you know you you're actually committed to release them. So before you push some features obviously you would not want your other users to see them right cuz you want to test it. So, this is the perfect opportunity to set this up and it comes with it and it's you can do this in a in pretty much one second. Okay, I'm going to show you every single thing in this video. The other thing is we're using a Nex.js stack and Seella is compatible with a bunch of frameworks which is good for us as well. Now, this is something that you may not need, you may probably not want right now, but in the future this is important. Okay, so there is something called vertical and horizontal scaling. So a lot of people say that this application or what any application is not scalable unless you have AWS and all these kind of crazy technologies. Um which it's not always true but essentially how it works is vertical scaling is think about it as a as a battery right you are essentially ex increasing the size of the battery that that means you are giving more power to the battery. Okay, that is vertical scaling and that's how you can scale your app in one way. So you can create multi you can just you know extend how much more powerful it is extend its capabilities and that's the vertical scaling part of your application. Now what is horizontal scaling? Horizontal scaling is like having slightly bigger batteries maybe you know just a little bit more but having diff having multiple batteries. So that means if one battery runs out, the other battery will also continue to power it. So I guess that's one way to think about horizontal scaling, right? There's there's more to it, but just for anyone and everyone to understand it, that's pretty much what horizontal scaling is. And um they do it for you, right? So there's other providers out there that only offer vertical scaling which is still really really good but um if you expect or anticipate to build an application that has a ton of traffic right then horizontal scaling is a must you need it. Okay. Uh, so for example, if you're building something like a a blog post application, so not only are you going to deal with the traffic on your site, but you're also going to need to deal with the traffic each content creator has on their own version, their own site version inside your application. And so if you opt with Sevela and you get the horizontal scaling, you can essentially create a different instance of your application so it doesn't shut down your server. Okay? And that happens on autopilot. So it's autoscaled. So that's awesome as well. The next one is security. And I like this because if I were to do this from scratch to protect myself from DOS uh DOS attacks, um we would usually use Cloudflare, right? And so when we use Cloudflare, we have to manually set up all that stuff uh reverse proxying and all that kind of crazy stuff, right? With with the Cloudflare as a middleman. If you were to set it up that way, um it's going to take you some time and you're handling it on two different platforms, right? But they do it for you before you even hit deploy. Like it's already set. So, uh it's a much much better user interface, much better user experience, especially for devs who don't really care about all the technical stuff, but you still want, you know, you still want the technical stuff. You just don't want to look at all of that, right? So, Savlla does all of this in one single click. And yeah, you also get the other features like uh runtime logs to see if something crashed, u you know, web analytics, all that kind of stuff. So that's that's why I would rather have you go for a tool like Sevela. So you get all these features together and the best part is their pricing is super affordable. Okay, pricing is like nothing beats their pricing. So, I would highly highly recommend uh trying Seilla over someone else. And you can use the link in the description. That's going to essentially uh get you your free account as well. I think they have a free account to uh you know, just get started, right? So, grab your free account from the link in the description and then we'll move on. And before that, I just also want to let you know that Savella is the sponsor of this video. So, thank you so much to Sevela for making this possible for the Web Prodigies community. That way this course can be completely free for them to watch. Okay, and with that being said, let's proceed. So go ahead and log in and create your account using the link in the description. That should give you a free account to get started. So next, it's going to ask you to log in with a bunch of providers. Please use GitHub. That's the only way for you to connect all of this seamlessly, right? So make sure you log in with GitHub. Then go back to your dashboard right here. I'm already inside the company, so we're good to go there. But make sure inside your dashboard. You can also click here if you can't find the dashboard and then click on add service and click on add application. Then we're going to go ahead and connect GitHub. So go ahead and click on connect GitHub. And then once you click on the button guys, it's going to ask you to edit edit your GitHub permissions. So click on that and it's going to open up into a different uh section that looks like this. and just make sure you give it all repository access so you don't have to go back and forth wondering why you don't have why you are why Savannah doesn't have permissions. Okay, so go ahead and install this. Okay, I've already gone ahead and installed Savlla correctly. Make sure you refresh this repository list so that way it grabs the new information. Awesome. There we go. Now you can see the codebase uh essentially the um you can see all of your repositories. So go ahead and click on the one that you just uh just pushed. Make sure you push your new build. Okay. So once you're done push uh creating uh creating the build file and solving all of your errors, make sure you push that build. Then it's going to ask you to set up the default branch. So just go ahead and set that to main. And the next thing you want to do is you want to click on automatic automatic deployment on commit. Actually um we I think it should only work on merge. So let's see if we need to change this later on. Okay, then I'm going to leave everything else as is and just go ahead and select the resources. And I think the hobby plan gives you this one for free or I'm not entirely sure which one, but I'm just going to select this one right now. And if you do not see this create button glowing here and it's deactivated, that probably might be because you already have an application. And for me when I first spun up uh my new Sevela account I was just messing around and and so I clicked under boilerplate NexJS template and that deployed and so as a result it was uh I had completed my free tier right. So go ahead and then open this and then select the hobby plan. And now if you see this once you have confirmed that you have no other applications inside your dashboard then go ahead and click on create. All right there we go. And in about probably 2 seconds you can see they have already set up Cloudflare's DDoS protection. Okay, this is what I was talking about when u essentially you can turn this on from Cloudflare but you have to do the setup and so they connect this for you and they show you that it's connected to your application and so your app is protected from DOS. So, if you're under attack, um this will automatically spin up under attack mode. And so, once you verify, I think this all of this stuff looks good for now. You don't need to create anything else. But, uh what we're going to do is we're going to go ahead and click on deploy now right down here. And okay, we're not going to skip app building. Let's just go ahead and click on deploy application. Sorry guys, just go ahead and cancel the deployment from here. We have to upload all of our environment variables. Now, I cannot show you this process because it has some confidential information. So, you will not see this section. All right? You cannot see my environment variables. So, I'd like for you to just read some documentation if you need to. There are the Savannah docs. I mean, there are docs right here. You can read how they upload the uh environment variables, but essentially you just have to click on add environment variables and then you can paste it in here. Okay. All right. Awesome. I've gone ahead and pasted all of my environment variables, but um there are some things we have to keep in mind. The first one is that we're not going to be able to access anything because we have to still change our convex site URL, right? Remember, we're using the Enrock endpoint. So, this means once we deploy, it's going to give us a new address, a new website location, essentially a new domain. We're going to grab that domain and then we're going to need to set it up everywhere inside our Google cloud console, inside our uh inside convex, inside polar, inside, everywhere that we have this running. Okay, so let's go ahead and now go back to our overview tab. And now let's click on deploy now and click on deploy application. All right, so looks like we're we're run we're up and going. I mean that was pretty quick. It took me 3 minutes to deploy, which is awesome. And so, here's what you got to do, guys. Click on this link. It's going to take you into your Docker uh sorry, into your deployment logs if you need to uh take a look at what's going on. Okay. So, for for some reason it failed on your end, make sure you open the deploy the uh deployment logs and you can take a look at it. But now, if you want to access the the URL, go to networking and you're going to find the seella.app domain. And if you open it, well, if everything is working correctly, we should see um we should see the next.js location. Okay, that the next.js page because that was our landing page, right? There we go. Awesome. But I I'm still I'm still wondering if this is going to run or not. So, let's let's just try. So, I'm going to go to the dashboard route. And now, if everything is set up, it should route us to our authentication page. Let's go. Oh my god, we have a real application that is live. All you have to do is just change the domain. We're so close to the finish line. So, let's go ahead and see what else I need to change here. Just give me one second. So, if you try to use the app, you're going to notice that it's going to redirect you to the wrong URL, right? Because our Google authentication is going to redirect you to the old URL, the Enro URL. And so I just want to give you a quick um checklist. All right. So first you need to update the URL inside. So you want to go into your SELLA dashboard which I can't show you guys. So you just have to take my word on this. Okay. So click on environment variables and then you're going to scroll to the convex uh you're going to scroll to your live URL and wherever you had the Enro URL, you're going to paste the new URL you got from this networking tab. Okay, then inside injust you also have to sync the new URL. Okay, so um let me go and let me go to that page and also show you that too. So here you go. So I have set up my new endpoint, right? My new SLA app and it also uh is in sync with my two functions that I created. Okay. Then I also created another endpoint uh inside my web hooks for polar and I copied that secret the web hook secret key and I went into my environment variables and I changed that as well. Now, turns out if if you guys remember, we were facing some bug where ingest uh not injust, but it it was hitting one of our web hook routes every like 10 seconds or so, right? Turns out that is coming from here. That's because we have selected every single thing here, right? And not just this, we have selected all the other events for the product as well. And so, as a result, Polar is going to do what it's supposed to do and check consistently. All right? So, that's why it's hitting that route. uh over and over again. So I would suggest that only limit the events that you need. So right now we selected everything because we were in development, right? So in production only keep the subscription stuff if you have subscriptions. Okay. If you need refund stuff, keep that as keep that as well. So So you don't need to get all of these events. I don't think you need co checkout created. Yeah, you don't need that. You don't need customer created. You don't need this. You just need the subscription payment. So you can update that on the front end, right? So make sure you limit as much as of the events as you can. Over time it's gonna obviously it's not going to be expensive, but over time it it'll just add you it'll save you a few extra bucks. That's it. Okay. And uh same thing for the products as well. So that's the next one that you need to update. And then like I said inside your Google Cloud Console, you're going to go into the URL. So in here, you're going to go into this one and you're going to change this to your new URL. Okay? So, it's saying Enro right now, but if I refresh this, let's let's just give this a second. There we go. So, it's showing my new Seilla app, right? So, make sure you add that new URL in here as well. And uh I think that should be it. That that's pretty much everything you need. And now, don't forget you also have to redeploy your application. Okay. So, the good thing with Savella is when you change your environment variables, it's going to give you like a pop-up on the screen. It's going to show you a popup and that popup will will ask you to redeploy because a couple changes were made. Click on that and redeploy. Okay. And once it's redeployed, it's going to take you into your uh I mean it's going to essentially say, "Hey, good to go. Running." And you can also see these are logs. You want to see deployment logs right here. You should see this. Okay. If you see this, everything is back up and running. And then when you try to access your if you try to access the login route and you try to log in, it's going to redirect you to the correct URL. Okay. And then that will force send you into the billings page. Okay. So, if you see this and you've done everything that I just told you to step by step and followed my instructions, you should see the checkout page the moment you click on subscribe. Okay. So, let's go ahead and click on subscribe. Fingers crossed. Let's go. There we go. Awesome. So, I'm going to quickly put some mock information. So, just give me a second. Okay. So, I just entered some information using the random address generator. Let's just uh let's just give that a second. Okay, awesome. Let's go, guys. This is so nice to see. So, now the next thing is we need to create a project, right? So, let's go ahead and create new project. Boom. It shows up there almost instantly because we're using uh Optimistic UI, right? And then let's go ahead and click on this project so we can see the canvas. Okay. Nice. We can see the style guide. Oh my god, this is so nice. All right, so we can see uh everything without any errors. Now, if you do see any errors that might just be very minimal, tiny small little things, okay? Like for example, we look we forgot to look at the project ID. That would break the app. Don't don't get, you know, all worried about it. It's not too big. It's it's tiny little bugs that I'm sure you can fix. Okay? And uh you've already come so far. This is more than enough. Like if you were to give this to a customer and uh they use it and I mean they used it this way like they would still be happy, right? But you need to make sure you improve the product. So now I'm going to first go to my style guide and let's go ahead and generate our mood board. Okay, so I just generated the style guide using our generate with AI button. Let's go ahead and take a look at what it generated for us. Nice. Uh pastel colors. Awesome. And some minimal font. Okay. So, when I tried this on a different project, it had some different font, but here it looks like it's it's uh well, actually, oh, oh, that's nice. So, it looks like it's Oh, never mind. Okay. So, yeah, it it turns turns out it's using uh this is the font it thought is what was in the image. So, we should be fine to go. Let's just go back to our canvas and let's sketch out a frame. Okay. So, I'm going to draw a frame here. And inside this frame, I'm going to put in our website design. So, let's just Why did my dictionary show up? All right, there we go. Um, let's do this once more. So, delete the frame. I'm sorry. Delete that. Draw this. And let me just draw whatever I need to, guys. Give me one second. Okay. So, I made I made something. I don't know if it's good or not good. But, uh, I I think this looks fine. All right. I try to make it a little more complex as well by putting accordians and, you know, all these kind of interactions. Uh, I just wanted to see how it deals with it. It's probably not going to do a great job, but hey, might as well, right? Might as well give it a shot. This is how you understand the capabilities of your SAS and then you can improve on this. And one thing, guys, everything in this project is about prompting. So, as long as you can tweak that prompt that I gave you, you should get a better output. Okay? So, please let me know what you guys come up with and uh maybe I can see if I can help you out there. Okay. So, I'm going to go ahead and click on generate design. Okay, it downloaded my image. Let me open that as well. Okay, looks awesome to me. It has everything that I have on the image. Uh, let's go ahead and wait for the final output. Wow, this is amazing. It did a really good job and I think we just need to tweak the prompts. But it is like it's doing a really good job so far. So what happened here I believe is that you have to write a prompt that that tells it to look at the dimensions of dimensions of this image and make sure that the output is in that design. So for example if this is like a rectangle obviously it has to be desktop mode. So what it's trying to do is it it's trying to make it look like a mobile mode. You get what I'm saying? And uh as a result it's it's doing it I mean it's doing a responsive design essentially but it's it's putting it into this huge container but it's making it look like a mobile device. So it's technically this would have worked really well. Okay. It's just that it it made it look like a mobile device. That's the only problem. But this dashboard looks pretty good. This this kind of reminds me of Shaden's dashboard. Right. And then I think it kind of messed up here but I think this was essentially the account settings. But then we also have the user profile uh you know products purchasing history as well and we also have some product inventory all this kind of fun stuff. All right looks awesome. So everything is working. You are very close to launching your first SAS. Great job. The other feature that I wanted to try out was the chat feature. So if I click on this chat box right here for this specific frame now I can essentially communicate with this design. So, what I'm going to do is I'm going to tell it to I'm going to just tell it to update the design overall just to make it look nicer and also fix the navbar. Okay, I hope that doesn't cause too big of a actually I probably should have been a little more specific, but let's just see what uh what AI is going to generate for us. Okay, so it did a lot of fixing here and there. I mean, it it oh sort of fixed it, but sort of also did not. But I think we're getting very close. I like how it updated this uh this table to have this rounded I guess it's like a skinnier header. I've never seen that before. Very unique. Um it fixed the navbar. It messed this part up, but it fixed the navbar. So that's good news. But it changed this button. I think it was looking to enhance it and then it it just messed that part up. But I also like the shadows. The shadows are perfect. So that's good news. So we are very close, right? I just want you to spend a little more time on improving the prompt. The prompt is key. As long as the prompt is simple, straightforward, and it limits the context and the freedom the AI has, um, the better your output is going to become. Okay, awesome. Great job. So, the next question you might have is how do you change the domain name of your new application that you've just deployed? So, first thing is go back to the SLA uh homepage. You want to click on applications, then click on your app. It's going to take you back into this uh this section, right? Then you want to click on domains, but obviously this is their uh paid version. You get this for free, which is a dossella.app for free. But if you want your own custom domains, then you need to upgrade. So go ahead, pause the screen and just upgrade by putting your credit card information in here. Now, if you click on this, it's going to show you something that looks like this. And it's going to take you into the processes section. And then if you click on unlock these resources, then it will take you directly into the payment section. And then go ahead, click on add payment method and add your payment method. All right, awesome. Hopefully you added your credit card details in there and you have upgraded your account. The next stage is I want to show you how to essentially set up these pipelines for your branch. Okay, so go back into Savlla's homepage. Then you want to click on applications. Don't click on this yet, but up here you're going to see add pipeline. Okay. Go ahead and click on this and make sure you have selected the trunkbased dep development environment. Okay. And then go ahead and set a name. And then once you're done, click on add pipeline. And that's going to create uh these three pipelines for you. Okay. So they have dev and production in here. And the next stage is essentially creating these different environments. So most of you guys might probably just need a staging environment to any production environment and that's fine. And if that's the case, you you're free to proceed from here. But if you need another staging environment, maybe you might need a QA environment, right? Go ahead and click on stage right here. And then you want to create your QA stage and create this stage. Okay, I'm going to skip this just for simplicity because I don't really need it. But if you need to create that QA stage, go ahead, pause this video and do that. Awesome. Now there's this other feature here called create apps for pull uh for your pull requests and this feature is available only obviously once you provide your credit card details. Okay. So until you provide that you wouldn't get this but you you don't need it for now but I think it's a nice feature to have because if you just want to test individual branches uh you can do that as well right so you can create uh you can create apps here from your pull requests and different branches which is nice right so that's another way if you want to set up pipelines but uh this approach that I'm about to show you is a simpler I guess simpler dev flow okay so first go ahead and create an app inside each environment. So, inside your dev environment, we're going to click on create app like this. And then make sure you select existing app and then select the existing app that we just uh deployed. And go ahead and click on add app. Okay. And that's going to add your application in here. Next, for the production environment, you have to create an app for that as well. So, go ahead, click on app here. And you have to click on your existing app. Okay, I have just added my payment details as well. So let's go ahead and create the production version. So click on this and then here it's going to say existing app but uh we we don't want this. Essentially we just need to create a new app. Okay. So I'm just going to call this S2C production just like this. Okay. And leave the location as whatever they're giving uh or suggesting and just go ahead and click on add app. Okay. So this is how you you're essentially creating a container where the app goes and stays. Okay. Think about it that way. So now when you make a change to your uh to your codebase and keep in mind you have to have your um your your commit-based u redeployment set up. Okay, that means when you commit something to this branch when you push something to the main branch it should redeploy for you. If you don't have that set up then uh you'll have to do all this manual. So I think by default it should be set up for you. Um we can also give that a shot. You can try it out right now right now. just go back to your codebase, make a small little comment, and then push that push that comment to your main branch, and then just see what happens. Okay, so let's go ahead and try it out. All right, guys. So, it looks like I haven't turned on my autom automatic deploy on com uh on commit. And so, the way to do that is to go back into your applications, click on the dev version of your uh of your app, and then you're going to find the latest push. So, I just made a push, but it wasn't deployed. Okay? And I don't know if it's this one or if it's uh you know anything that happens from here in the future. So what I have to do is click on settings and then update the source. So it says source private GitHub repository, right? You want to click on update source and then in here you want to select automatic deployment on commit. Okay. And go ahead and click on update. All right. So I just pushed something literally 2 seconds ago and a message showed up in here saying deployment is in progress. Okay, awesome. This is exactly what we were looking for. We want the automation to fire off automatically and I mean we essentially want our deployment to start automatically every time we push to main. So while our application is deploying, I want to show you something that's really nice inside our pipelines. So if you go into environment variables, you can essentially copy all of your environment variables and you can transfer them into your different environments as well. So what do I mean by that? If you go back into applications, click into your trunk pipeline and then in here, let's say you want to have a different environment key for this application version. Click on it and then go into environment. And now you can paste that entire environment file that you just copied. So what you're doing essentially is isolating the environment file to that specific uh deployment pipeline. Okay? So this way your data is not going to mix up and your users are not going to be uh you know speaking to the real app with the real database. I mean they're sorry they will be speaking to the real app with the real database but not the other way. Okay. Um so in in testing you will have your own testing API keys your own testing uh environment variables and so everything will be test data only. Okay. This is another awesome feature. So I highly highly recommend you set this up as well. All right. Awesome. So my deployment is completed. Now, let's go back here. Let's go back into application. Click on the trunk pipeline. And as you can see, it's going to give you this URL right here. Okay, you can click on this and you can view this app in this specific URL. Okay, I've already signed in. So, it's going to take me into this app. But, um, the thing that I wanted to point out is the URL that we're using here. So, this URL is for dev, right? So, remember I told you to update the domain, right? That domain if you upload if you updated it in this app is going to be the domain for your dev version. But if you have a production version you are going to have a different URL. You can you can see this here as well. You see if you go into domain it's going to give you this but this is a 404 because we haven't deployed an app to this uh specific um you know location. And so what we need to do now is first you can copy this link. you can send it to your team members to debug or test whatever you're doing inside the development environment. And then once you're once you're ready to go, once you're set to promote this to production, you just click on this button and that's pretty much it. So what it's saying here is a deployment to production will happen without rebuilding the source app. This is awesome because it's almost instantaneous. So I just clicked on the button and it's deploying the already pre-built package the pre-built uh application into the production environment. So once this is deployed if you click on this link now you will access the real production version of your application. So what you have to do here the most important part is to have different URLs. Now some companies will have a staging environment as a subdomain. So they'll have staging dot um your application like web prodigies.com something like that and then if it's a staging environment they'll have like a single signon login system right or they'll have some kind of uh some way to authenticate their own team members. So that's something that you could create as well you could create a second authentication token and you can use that to essentially log in all of your team members only. So only your team members can access the uh those routes right. So if you have u like a testing environment your website.com make sure you filter for that. That's what I mean to say. Okay. So um make sure you have a different URL and you can set that up through a subdomain. Okay. And you can do that directly inside domains. You can add your domain. Obviously you know I haven't done it for this one but you could essentially upgrade and add your domain inside this location. So for the moment of truth, if you open this up, you should see the new updated version of your new application. Okay? So all the new changes you made will be inside this specific deployment branch. Now, if you're wondering how you don't have this in your, you know, how we didn't show this in the in the video, it's because this is a limited time founders beta program. So, Web Prodigies is launching this program to experiment some newer products and uh provide even more value than what we're offering right now. So, this is only available for people who purchase the codebase obviously and it's only available for a few people because we're looking to experiment uh experiment this at a lower price point with fewer number of people. Okay? That way we can get good feedback and test this out to see if this new program works for works for you guys. Okay? So, if you purchase the codebase, you'll have the opportunity to qualify for this. So, you can you can join this program and get assistance. And there's a ton of awesome stuff that you're going to get inside this. But obviously, like I said, this will not be available to the public. This is only for people who purchase the codebase and then decide to upgrade into this uh beta program. Okay, but that's pretty much it. Now, you can see that I've deployed my application and my production branch now has the updated code. you have you have essentially set up a full SAS application with a a a CI/CD pipeline and you've also deployed your app to different environments using different environment variables and you also probably at this at this time you also probably set up your domains. So now you have your real application ready to go. All right guys, and that wraps up this video. We have come so far. We have learned so many things and I'm so proud of you because you are now officially a SAS owner. You have your SAS up and running and people can essentially buy your subscription and over time just just think about this, right? All you probably need is a 100 people paying you $100. That's it. And that will I'm sure that that's sufficient enough to replace most nineto-ive jobs because that is $10,000 per month. You just need a 100 people paying you $100. Well, you don't even need that. you probably only need uh maybe 50 people paying you $200, right? You could reduce this amount. You could increase this amount. Like you have so much flexibility, but it's it's just as simple as understanding the target and hitting the gas pedal as hard as you can until you reach that number. Okay. Now, before you go, don't forget to join our Discord. There's more than 7,000 Oh, actually, I didn't even know this. We have more than 8,000 people. 8,000 SAS entrepreneurs and SAS developers from around the world who are crushing it, who are starting their own SAS companies, who are making money. And I hope you guys get to experience this as well. And so, I'd like to invite you to join this Discord. It's absolutely free. You can get some support from other people, or maybe you can just hang out and learn from everyone else. Once you join the Discord, don't forget to just go into the general chat and just introduce yourself, right? let everyone know you're here and what are your goals and uh try to help each other. If you see someone struggling and you want to provide that help, please do. Okay? Because the more you give, the more you get in return. What I've seen is when someone gives more in the community, u they receive more from other people as well because they build trust with everyone. And this is an awesome way to also build a development team, right? Over time, you're you guys are probably going to need to branch out, expand a little bit, have more people work on the team so you can outsource some more dev work, right? This is the way to do it. Okay, so I hope to see you guys in this Discord. And that's it for this video, guys. Thank you so much to you for watching this video and giving me the honor to teach you everything I know about SAS. And thank you so much to all the sponsors for supporting this video so we could push this out for free. All right, thank you so much for watching, Prodigies, and I will see you in the next one.