import { execFile } from "child_process";
import fs from "fs/promises";
import path from "path";
import { promisify } from "util";

const execFileAsync = promisify(execFile);

export interface WorkspacePaths {
  root: string;
  repo: string;
  worktree: string;
}

export interface WorkspaceManagerOptions {
  baseDir?: string;
  defaultBranch?: string;
  gitUserName?: string;
  gitUserEmail?: string;
}

export class WorkspaceManager {
  private readonly baseDir: string;
  private readonly defaultBranch: string;
  private readonly gitUserName: string;
  private readonly gitUserEmail: string;

  constructor(options: WorkspaceManagerOptions = {}) {
    this.baseDir =
      options.baseDir ??
      process.env.WORKSPACE_ROOT ??
      path.join(process.cwd(), ".workspaces");
    this.defaultBranch = options.defaultBranch ?? "main";
    this.gitUserName = options.gitUserName ?? "AppForge AI";
    this.gitUserEmail =
      options.gitUserEmail ?? "appforge-ai-bot@appforge.internal";
  }

  /**
   * Initialize the workspace for a project.
   */
  async initProject(projectId: string): Promise<WorkspacePaths> {
    const paths = this.getProjectPaths(projectId);
    await fs.mkdir(paths.root, { recursive: true });

    const repoHead = path.join(paths.repo, "HEAD");
    if (!(await this.pathExists(repoHead))) {
      await fs.mkdir(paths.repo, { recursive: true });
      await this.execGit(["init", "--bare", paths.repo]);
    }

    const gitDir = path.join(paths.worktree, ".git");
    if (!(await this.pathExists(gitDir))) {
      await this.execGit(["clone", paths.repo, paths.worktree]);
      await this.configureRepo(paths.worktree);
    }

    // Ensure default branch exists with an initial commit
    if (!(await this.hasCommits(paths.worktree))) {
      await fs.writeFile(
        path.join(paths.worktree, "README.md"),
        `# ${projectId}\n\nGenerated by AppForge AI.\n`
      );
      await this.execGit(["add", "."], { cwd: paths.worktree });
      await this.execGit(
        ["commit", "-m", "chore: initial project scaffold"],
        { cwd: paths.worktree }
      );
      await this.execGit(
        ["checkout", "-B", this.defaultBranch],
        { cwd: paths.worktree }
      );
      await this.execGit(["push", "-u", "origin", this.defaultBranch], {
        cwd: paths.worktree,
      });
    }

    return paths;
  }

  getProjectPaths(projectId: string): WorkspacePaths {
    const root = path.join(this.baseDir, projectId);
    return {
      root,
      repo: path.join(root, "repo"),
      worktree: path.join(root, "worktree"),
    };
  }

  getDefaultBranch() {
    return this.defaultBranch;
  }

  async readFile(projectId: string, relativePath: string): Promise<string> {
    const absPath = await this.resolvePath(projectId, relativePath);
    return fs.readFile(absPath, "utf8");
  }

  async writeFile(
    projectId: string,
    relativePath: string,
    contents: string,
    commitMessage = "chore: update file"
  ): Promise<string> {
    const { worktree } = this.getProjectPaths(projectId);
    const absPath = await this.resolvePath(projectId, relativePath);
    await fs.mkdir(path.dirname(absPath), { recursive: true });
    await fs.writeFile(absPath, contents);
    await this.execGit(["add", this.sanitizedPath(relativePath)], {
      cwd: worktree,
    });
    await this.execGit(["commit", "-m", commitMessage], { cwd: worktree });
    const sha = await this.execGit(["rev-parse", "HEAD"], { cwd: worktree });
    return sha.stdout.trim();
  }

  async writeFiles(
    projectId: string,
    files: { path: string; content: string }[],
    commitMessage = "chore: apply AI changes"
  ): Promise<string | null> {
    if (!files.length) return null;
    const { worktree } = this.getProjectPaths(projectId);
    for (const file of files) {
      const absPath = await this.resolvePath(projectId, file.path);
      await fs.mkdir(path.dirname(absPath), { recursive: true });
      await fs.writeFile(absPath, file.content);
      await this.execGit(["add", this.sanitizedPath(file.path)], {
        cwd: worktree,
      });
    }
    await this.execGit(["commit", "-m", commitMessage], { cwd: worktree });
    const sha = await this.execGit(["rev-parse", "HEAD"], { cwd: worktree });
    return sha.stdout.trim();
  }

  async listFiles(projectId: string): Promise<string[]> {
    const { worktree } = this.getProjectPaths(projectId);
    const results: string[] = [];
    const walk = async (dir: string) => {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name === ".git") continue;
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          await walk(fullPath);
        } else {
          results.push(path.relative(worktree, fullPath));
        }
      }
    };
    await walk(worktree);
    return results;
  }

  async checkoutBranch(
    projectId: string,
    branch: string,
    { createIfMissing = true }: { createIfMissing?: boolean } = {}
  ): Promise<void> {
    const { worktree } = this.getProjectPaths(projectId);
    const exists = await this.execGit(
      ["show-ref", "--verify", `refs/heads/${branch}`],
      { cwd: worktree, allowFailure: true }
    );
    if (!exists.success && !createIfMissing) {
      throw new Error(`Branch ${branch} does not exist`);
    }

    if (!exists.success && createIfMissing) {
      await this.execGit(["checkout", "-b", branch], { cwd: worktree });
    } else {
      await this.execGit(["checkout", branch], { cwd: worktree });
    }
  }

  async commitAll(
    projectId: string,
    message: string
  ): Promise<string | null> {
    const { worktree } = this.getProjectPaths(projectId);
    const status = await this.execGit(["status", "--porcelain"], {
      cwd: worktree,
    });
    if (!status.stdout.trim()) {
      return null;
    }
    await this.execGit(["add", "."], { cwd: worktree });
    await this.execGit(["commit", "-m", message], { cwd: worktree });
    const sha = await this.execGit(["rev-parse", "HEAD"], { cwd: worktree });
    return sha.stdout.trim();
  }

  private async configureRepo(worktree: string) {
    await this.execGit(["config", "user.name", this.gitUserName], {
      cwd: worktree,
    });
    await this.execGit(["config", "user.email", this.gitUserEmail], {
      cwd: worktree,
    });
  }

  private async hasCommits(worktree: string) {
    const result = await this.execGit(["rev-parse", "--verify", "HEAD"], {
      cwd: worktree,
      allowFailure: true,
    });
    return result.success;
  }

  private async resolvePath(projectId: string, relativePath: string) {
    const sanitized = this.sanitizedPath(relativePath);
    const { worktree } = this.getProjectPaths(projectId);
    return path.join(worktree, sanitized);
  }

  private sanitizedPath(relativePath: string) {
    const normalized = path.normalize(relativePath).replace(/^\.\//, "");
    if (normalized.startsWith("..")) {
      throw new Error("Invalid path outside workspace");
    }
    return normalized;
  }

  private async pathExists(target: string) {
    try {
      await fs.access(target);
      return true;
    } catch {
      return false;
    }
  }

  private async execGit(
    args: string[],
    options: { cwd?: string; allowFailure?: boolean } = {}
  ): Promise<{ stdout: string; stderr: string; success: boolean }> {
    try {
      const { stdout, stderr } = await execFileAsync("git", args, {
        cwd: options.cwd ?? this.baseDir,
      });
      return { stdout, stderr, success: true };
    } catch (error: any) {
      if (options.allowFailure) {
        return {
          stdout: error.stdout ?? "",
          stderr: error.stderr ?? "",
          success: false,
        };
      }
      throw error;
    }
  }
}
